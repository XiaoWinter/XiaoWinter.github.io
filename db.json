{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/categories/index.md","hash":"3f94296185e6722420763d726cd8aaf2ddfe83c6","modified":1625292633064},{"_id":"source/_posts/七小时时差.md","hash":"cfd93cad8eb68140e3ccb95c54e1b084a4228cee","modified":1625383933605},{"_id":"source/_posts/流处理.md","hash":"5cf61b1585b519aa7e7c94de14329247073e855e","modified":1625383963988},{"_id":"source/_posts/流处理2.md","hash":"3885afca83927bac190cadc160a5284e8ccc8ef9","modified":1625384072845},{"_id":"source/_posts/流处理3.md","hash":"8e6bef818685f6a4f5dd12aac7bbdd0579ab4c75","modified":1625385834607},{"_id":"source/_posts/流处理4.md","hash":"6a22fd71b3e24638f4aa8bff6eb910777824840e","modified":1625383034802},{"_id":"source/_posts/流处理5.md","hash":"e59411aeab0b5c5e381ee11762c0f74d40720427","modified":1625388789362},{"_id":"source/_posts/计算机概论.md","hash":"78cf00d5985c0c5995ae741bf55d76227bbeff0d","modified":1625385598716},{"_id":"source/tags/index.md","hash":"601d6176cc2ff4da828866f74a2d351090287194","modified":1625292633066},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1625135741945},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1625135741946},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1625135741946},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1625135741955},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1625135741956},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1625135741957},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1625135741957},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1625135741958},{"_id":"themes/next/_config.yml","hash":"285129ac54f9d01ff77e75c8752100889a4bfc3b","modified":1625137261263},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1625135741959},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1625135741974},{"_id":"themes/next/next.yml","hash":"37ac2a5dae4fe2e0afdf9b4e61adbc66512c8427","modified":1625388578469},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1625135742032},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1625135741947},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1625135741948},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1625135741951},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1625135741951},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1625135741952},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1625135741952},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1625135741953},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1625135741953},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1625135741954},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1625135741954},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1625135741955},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1625135741960},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1625135741961},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1625135741961},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1625135741962},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1625135741962},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1625135741963},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1625135741965},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1625135741965},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1625135741966},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1625135741975},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1625135741975},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1625135741975},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1625135741976},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1625135741976},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1625135741977},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1625135741978},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1625135741978},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1625135741979},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1625135741979},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1625135741979},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1625135741980},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1625135741981},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1625135741981},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1625135741982},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1625135741982},{"_id":"themes/next/languages/tr.yml","hash":"46e09f2119cbfbcf93fb8dbd267dccabeb8b0cda","modified":1625135741983},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1625135741983},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1625135741984},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1625135741984},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1625135741985},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1625135741985},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1625135741986},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1625135742028},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1625135742029},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1625135742030},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1625135742030},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1625135742031},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1625135742031},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1625135742045},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1625135741948},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1625135741949},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1625135741950},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1625135741950},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1625135741966},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1625135741967},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1625135741967},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1625135741968},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1625135741969},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1625135741969},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1625135741970},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1625135741970},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1625135741972},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1625135741971},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1625135741972},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1625135741973},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1625135741973},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1625135741987},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1625135741988},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1625135741988},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1625135741989},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1625135741989},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1625135741994},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1625135741996},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1625135742003},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1625135742004},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1625135742004},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1625135742006},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1625135742009},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1625135742010},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1625135742013},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1625135742018},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1625135742022},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1625135742022},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1625135742033},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1625135742040},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1625135742041},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1625135742041},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1625135742042},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1625135742043},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1625135742043},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1625135742044},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1625135742044},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1625135742045},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1625135742046},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1625135742047},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1625135742047},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1625135742048},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1625135742048},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1625135742049},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1625135742051},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1625135742051},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1625135742051},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1625135742051},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1625135742053},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1625135742092},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1625135742105},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1625135742106},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1625135742107},{"_id":"themes/next/source/images/avatar.jpg","hash":"942f984439311aa572815294a10c37cf028ce267","modified":1624850542802},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1625135742108},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1625135742109},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1625135742111},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1625135742111},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1625135742112},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1625135742112},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1625135742113},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1625135742113},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1625135742114},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1625135742114},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1625135742115},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1625135742116},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1625135742116},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1625135742117},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1625135742117},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1625135742120},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1625135742121},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1625135741990},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1625135741990},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1625135741991},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1625135741992},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1625135741992},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1625135741993},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1625135741993},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1625135741994},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1625135741995},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1625135741997},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1625135741998},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1625135741998},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1625135741999},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1625135742000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1625135742000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1625135742001},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1625135742001},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1625135742002},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1625135742005},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1625135742006},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1625135742007},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1625135742007},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1625135742008},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1625135742011},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1625135742012},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1625135742012},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1625135742013},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1625135742014},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1625135742015},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1625135742015},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1625135742016},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1625135742016},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1625135742017},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1625135742017},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1625135742018},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1625135742019},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1625135742019},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1625135742020},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1625135742023},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1625135742024},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1625135742024},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1625135742025},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1625135742025},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1625135742025},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1625135742025},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1625135742026},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1625135742027},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1625135742028},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1625135742034},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1625135742034},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1625135742035},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1625135742036},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1625135742036},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1625135742037},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1625135742037},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1625135742038},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1625135742038},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1625135742039},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1625135742040},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1625135742102},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1625135742103},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1625135742103},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1625135742104},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1625135742104},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1625135742119},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1625135742118},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1625135742127},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1625135742128},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1625135742054},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1625135742054},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1625135742055},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1625135742066},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1625135742074},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1625135742075},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1625135742082},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1625135742081},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1625135742082},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1625135742085},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1625135742085},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1625135742087},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1625135742087},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1625135742091},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1625135742093},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1625135742094},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1625135742095},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1625135742094},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1625135742095},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1625135742096},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1625135742096},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1625135742097},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1625135742097},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1625135742098},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1625135742098},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1625135742099},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1625135742099},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1625135742100},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1625135742100},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1625135742101},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1625135742101},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1625135742102},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1625135742123},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1625135742125},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1625135742055},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1625135742056},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1625135742056},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1625135742057},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1625135742057},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1625135742058},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1625135742059},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1625135742060},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1625135742060},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1625135742061},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1625135742062},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1625135742062},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1625135742063},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1625135742063},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1625135742063},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1625135742064},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1625135742064},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1625135742065},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1625135742066},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1625135742067},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1625135742067},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1625135742068},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1625135742068},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1625135742069},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1625135742070},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1625135742071},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1625135742071},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1625135742071},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1625135742072},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1625135742072},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1625135742073},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1625135742075},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1625135742076},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1625135742076},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1625135742077},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1625135742077},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1625135742079},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1625135742079},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1625135742080},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1625135742080},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1625135742080},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1625135742083},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1625135742083},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1625135742084},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1625135742084},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1625135742087},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1625135742087},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1625135742088},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1625135742088},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1625135742089},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1625135742089},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1625135742090},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1625135742124},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1625135742126},{"_id":"public/atom.xml","hash":"338dd5ccd17c93f9190cfae961cae3bc87ef4a4d","modified":1625388993445},{"_id":"public/categories/index.html","hash":"d885ed844a151693faabb0e7a2e852bb04b7df86","modified":1625388993445},{"_id":"public/tags/index.html","hash":"163bf04ae72f76bec3fb42d15d736b14f0fcc0ef","modified":1625388993445},{"_id":"public/2021/07/04/流处理5/index.html","hash":"60bcc9134e20cd4199d4c91b0a2ada2dcfc663eb","modified":1625388993445},{"_id":"public/archives/index.html","hash":"1d453d06098e92dc7039b26cee8af7cbc294ae27","modified":1625388993445},{"_id":"public/archives/2021/index.html","hash":"298de799e8c46fd19bc03406828ae5e2f587230e","modified":1625388993445},{"_id":"public/archives/2021/07/index.html","hash":"e3b2554742de74a382252e7c955f905bb3c59023","modified":1625388993445},{"_id":"public/categories/安排定律/index.html","hash":"5f996d1ef398806d4423107eea171abcba064821","modified":1625388993445},{"_id":"public/categories/二进制数据-文件/index.html","hash":"58e38328b699239ff7d8b7c7c78d72102aae0b58","modified":1625388993445},{"_id":"public/categories/计算机基础/index.html","hash":"a6f58fbec0b4718cd216d1325e872ecfa0669f6f","modified":1625388993445},{"_id":"public/tags/权力/index.html","hash":"227619d8bdea3f3a4b7d151dbbf9350ff36b47cb","modified":1625388993445},{"_id":"public/tags/体制内/index.html","hash":"42b2f22e3a9d9c771d3a23a65b79b1b1ff1572c9","modified":1625388993445},{"_id":"public/tags/安排定律/index.html","hash":"3a3b1f38b535c6ca81b999fdf73cd0704492ea2c","modified":1625388993445},{"_id":"public/tags/ArrayBuffer/index.html","hash":"a7b7d9f658f148bd1720b8981bd6905cb41cd206","modified":1625388993445},{"_id":"public/tags/TypeArray/index.html","hash":"a486be65cc98a82d3e7d4952d980573fbd75095a","modified":1625388993445},{"_id":"public/tags/DataView/index.html","hash":"d28c3361a1c12a64effc6fd7d00af12ccf840515","modified":1625388993445},{"_id":"public/tags/二进制/index.html","hash":"f414987c46cb14cb6c600b4efc334ac2e574a07c","modified":1625388993445},{"_id":"public/tags/TextDecoder/index.html","hash":"79f80e6637296c5c464317d40133e340b18b7fad","modified":1625388993445},{"_id":"public/tags/TextEncoder/index.html","hash":"9c2e47d16e0d3a2bac1b900759c6cd2697b8bbb6","modified":1625388993445},{"_id":"public/tags/decode/index.html","hash":"496b2ac123889d8ec84484213969517ac9cd650d","modified":1625388993445},{"_id":"public/tags/encode/index.html","hash":"91a99d2323201a3a9154093f10b0c628b4cd60a0","modified":1625388993445},{"_id":"public/tags/Blob/index.html","hash":"3eb2972006710e956bb1ebb4e588bc8444d8654b","modified":1625388993445},{"_id":"public/tags/File/index.html","hash":"914ab7187770cc660fc4c2511dfbc4171bd9b67e","modified":1625388993445},{"_id":"public/tags/FileReader/index.html","hash":"3c4414561cba356894d443999e8d79fa98935c57","modified":1625388993445},{"_id":"public/tags/计算机概论/index.html","hash":"96f2eaf8e63ea7ab6aa1767e07bff6570d079c8f","modified":1625388993445},{"_id":"public/2021/07/04/流处理4/index.html","hash":"ab660f11a5fcda3c9b528602737c4fb59a2f9dc7","modified":1625388993445},{"_id":"public/2021/07/04/流处理3/index.html","hash":"d68b8a945ddba2de614950bce0493f45d1fc75e9","modified":1625388993445},{"_id":"public/2021/07/03/七小时时差/index.html","hash":"f5566a09162e4289385f184f948ece6cb6ec21d4","modified":1625388993445},{"_id":"public/2021/07/03/流处理2/index.html","hash":"151c0c238392e25312b0da3efa1f219cb709cb68","modified":1625388993445},{"_id":"public/2021/07/03/流处理/index.html","hash":"b59885bc3c192115a4788a60e4254114bd86d65e","modified":1625388993445},{"_id":"public/2021/07/03/计算机概论/index.html","hash":"0f5e760d0bd35135bc41c3eeb428ac3ac8d60668","modified":1625388993445},{"_id":"public/index.html","hash":"d2b6a7906270cef980f155b7273849b4d1ce29e7","modified":1625388993445},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1625388676212},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1625388676212},{"_id":"public/images/avatar.jpg","hash":"942f984439311aa572815294a10c37cf028ce267","modified":1625388676212},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1625388676212},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1625388676212},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1625388676212},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1625388676212},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1625388676212},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1625388676212},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1625388676212},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1625388676212},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1625388676212},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1625388676212},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1625388676212},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1625388676212},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1625388676212},{"_id":"public/css/main.css","hash":"671eac4c5a035561e69800a574d03274311c15c7","modified":1625388676212},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1625388676212},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1625388676212},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1625388676212},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1625388676212},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1625388676212},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1625388676212},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1625388676212},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1625388676212},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1625388676212},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1625388676212},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1625388676212},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1625388676212},{"_id":"source/_posts/test.md","hash":"def8b255d0d70557ddae52596a75f7d569501d51","modified":1625388950320},{"_id":"public/2021/07/04/test/index.html","hash":"09a4cc5ec94f2cc6ad53f975f4991f58be324d71","modified":1625388956061},{"_id":"public/categories/测试/index.html","hash":"4b610d0dad7899f023fa335b997bd198000068a2","modified":1625388956061},{"_id":"public/tags/测试/index.html","hash":"4de9eb8d1a04e78357f5061131510855c8b133e7","modified":1625388956061}],"Category":[{"name":"安排定律","_id":"ckqoye6hb00049su09fhueh0h"},{"name":"二进制数据,文件","_id":"ckqoye6hf00099su0517bazn3"},{"name":"计算机基础","_id":"ckqoye6hx00249su0cg257anm"},{"name":"测试","_id":"ckqoym55j0001i4u03f0uhmz3"}],"Data":[],"Page":[{"title":"分类","date":"2021-07-01T10:52:26.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-07-01 18:52:26\ntype: \"categories\"\n---\n","updated":"2021-07-03T06:10:33.064Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckqoye6h500009su09oj21urk","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"标签","date":"2021-07-01T10:46:54.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-07-01 18:46:54\ntype: \"tags\"\n---\n","updated":"2021-07-03T06:10:33.066Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckqoye6h900029su0d4ahaixs","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"【安排定律的表现】时差七小时","type":"tags","_content":"\n2004 年 10 月 19 日，一部描写在英国的中国小留学生学习生活的电影《时差七小时》在北京举行新闻发布会。这部投资可观的电影请来了香港偶像明星助阵，在媒体上的宣传也颇具规模，可是这部电影的女主角却在电影界无人知晓。这个被叫做妞妞的女孩，同时也是这部电影的编剧、出品人、制片人。她是谁，为什么能够得到这些很多人梦寐以求的机会？\n\n<!--more-->\n\n冠以“留学生指南”电影的《时差七小时》10 月 27 日开始在全国上映，上映 3 天，该片全国总票房 67 万，在南京、成都、重庆等地票房均只有一两万情况下，影片原产地深圳包揽了其中的 60 余万票房，呈现一枝独秀的奇特景观。10 月 31 日，有观众反映，深圳市有关部门联合出面，组织深圳市中小学生自费集体观看，但观映后发现，影片对青少年的教育意义却微乎其微。而其貌不扬的女主角妞妞的父母都有着各自敏感的身份———深圳市市委某领导和深圳一家由国家新闻出版署和深圳市政府共同领导下的某出版社负责人。此外，一部纯青春片却完全在国外取景拍摄，制作费用高达 2100 万巨资……一时间，影片故事以外的内容掀起重重波澜。妞妞是谁？\n\n《时差七小时》改编妞妞写的畅销小说《长翅膀的绵羊》，该书讲述了一个 16 岁的中国少女留学英伦的青春故事。该书还曾经在 2003 年被评为全国 2002 年度优秀畅销书，但是，该书的销量是由深圳消化了大部分。在妞妞的背景被了解之前，该片最大的卖点可能就是小说作者亲自上阵同陈冠希搭档拍戏了。\n\n因为是描述 16 岁少女留学生活的青春影片，人们好奇妞妞是何青春模样。直到《时差七小时》上映，人们才注意到妞妞的年龄远超出少女的范畴。她 1979 年出生，比片中搭档陈冠希还要大上一岁。而且妞妞并不属于青春娇俏的范畴，她确实“其貌不扬”，而且用制片方的说法：陈冠希看到她扭头就走，最后还是在导演“劝说”下才同意留下来。看过《时差七小时》的观众们在网络上留言：“妞妞并不青春”。为什么是妞妞？\n\n《时差七小时》的女主角最初采用网络征选，最终还是花落原著者妞妞身上着实有些蹊跷。影片完全是由深圳制作班底打造，由深圳市三家公司投资，深圳导演阿甘执导，而为妞妞出书的出版社正是妞妞妈妈的工作单位。妞妞在接受采访时表示，其实一开始她的父母并不主张她出演这部电影，当时她报名参加女主角的全球征选的那段时间是和父母关系最紧张的一段时间，但是留学生活中练就的敢作敢为促成了这件事。\n\n导演阿甘也表示，之所以让妞妞当主角，是因为当时没有合适的人选，情急之下做了这个选择，而原定的刘亦菲则因为“太漂亮”而落选，“她太漂亮了，不符合书中丑小鸭的感觉。”但是妞妞的表现也差点让阿甘崩溃，据工作人员介绍，妞妞在进组一星期之后还完全无法进入状态，甚至连如何走位都要导演一遍一遍示范。由于陈冠希档期已定，更换女主角根本来不及，阿甘才坚持下来。\n\n不过妞妞对自己在电影中的表现则非常满意，她说：“我正在考虑以后是继续写书，还是转行做个职业演员。”为什么要拍这部影片？\n\n据介绍，剧情是 16 岁的 J ean(妞妞饰)穿着土土的毛衣只身来到伦敦机场，操着稍显蹩脚的英文问路和打电话，殊不知被学校安排来接她的香港男孩 DJ(陈冠希饰)已经守候了 6 个小时。他们之间的友情乃至朦胧的爱情便渐渐产生……\n\n来自全国广州、深圳各主流媒体和国内知名专家的评价表明“影片反映了积极向上的当代青少年的生活，真实艺术地再现了中国少年留学生在海外的学习和生活”。“小说和影片关于顺境教育和挫折教育；乖孩子和承受力、自强力的培育；成长的选择与权利，以及主人公对东西文化冲突的思考都将引起孩子们的观看欲”。其实，类似励志的青春作品还有很多，比如《哈佛女孩刘亦婷》。相比之下，《时差七小时》只反映一小部分留学人员的个人生活，居然获得国内各级文化管理部门、主流媒体如此众多的“盛誉”。这其中的“文化气息”，似乎更加值得玩味。\n\n2100 万从何而来？\n\n《时差七小时》是第一部全部在国外取景拍摄的国产影片，2100 万投资也号称是国内“最昂贵的青春片”。制片主任居晔表示，深圳的民营企业在融资中提供了许多便利，企业都主动表示愿意投资。\n\n但是导演阿甘却曾经表示，虽然 2100 万人民币在英国算低成本，但在中国内地，收回成本的机会则比较渺茫。他只好把希望寄托在国内票房和海外版权，国内票房的目标定为 6000 万，海外版权的任务则是 30 万美元。就是冯小刚的影片也只能达到近 5000 万，国内票房 6000 万根本没有可能，而沈阳等一些大城市在 11 月份也没有上映该片的计划。按照北方院线徐经理的话讲：“该片无论是题材还是阵容都无法称得上国产影片中的大片。”有关部门为什么要组织观看？\n\n深圳市有关部门联合下发文件，要求初中学生安排在上课时间，自费购票观看《时差七小时》。影片《时差七小时》公映后，仅 3 天的时间就在深圳创下 64.5 万元的票房收入。当地文化部门表示，深圳是历来有扶持本土青春影片的习惯，比如《花季雨季》。这部《时差七小时》展现了一个新颖的题材，对学生们的成长非常有教育意义。他们承认确实曾向学校推介这部电影，但没有强制学生一定要看。但当地观众似乎并不买账，尤其是学生家长批评影片反映的这种个人化的生活与老百姓无关，教育意义不及《邓小平》等影片，并质疑有关部门硬销这部影片是否妥当。\n\n参考\n\n- [时差七小时-wikipedia](https://zh.wikipedia.org/zh-hans/%E6%97%B6%E5%B7%AE7%E5%B0%8F%E6%97%B6)\n- [追问《时差七小时》高官背景](http://culture.163.com/editor/news/041105/041105_101550.html)\n","source":"_posts/七小时时差.md","raw":"---\ntitle: 【安排定律的表现】时差七小时\ntype: \"tags\"\ntags:\n  - 权力\n  - 体制内\n  - 安排定律\ncategories: 安排定律\n---\n\n2004 年 10 月 19 日，一部描写在英国的中国小留学生学习生活的电影《时差七小时》在北京举行新闻发布会。这部投资可观的电影请来了香港偶像明星助阵，在媒体上的宣传也颇具规模，可是这部电影的女主角却在电影界无人知晓。这个被叫做妞妞的女孩，同时也是这部电影的编剧、出品人、制片人。她是谁，为什么能够得到这些很多人梦寐以求的机会？\n\n<!--more-->\n\n冠以“留学生指南”电影的《时差七小时》10 月 27 日开始在全国上映，上映 3 天，该片全国总票房 67 万，在南京、成都、重庆等地票房均只有一两万情况下，影片原产地深圳包揽了其中的 60 余万票房，呈现一枝独秀的奇特景观。10 月 31 日，有观众反映，深圳市有关部门联合出面，组织深圳市中小学生自费集体观看，但观映后发现，影片对青少年的教育意义却微乎其微。而其貌不扬的女主角妞妞的父母都有着各自敏感的身份———深圳市市委某领导和深圳一家由国家新闻出版署和深圳市政府共同领导下的某出版社负责人。此外，一部纯青春片却完全在国外取景拍摄，制作费用高达 2100 万巨资……一时间，影片故事以外的内容掀起重重波澜。妞妞是谁？\n\n《时差七小时》改编妞妞写的畅销小说《长翅膀的绵羊》，该书讲述了一个 16 岁的中国少女留学英伦的青春故事。该书还曾经在 2003 年被评为全国 2002 年度优秀畅销书，但是，该书的销量是由深圳消化了大部分。在妞妞的背景被了解之前，该片最大的卖点可能就是小说作者亲自上阵同陈冠希搭档拍戏了。\n\n因为是描述 16 岁少女留学生活的青春影片，人们好奇妞妞是何青春模样。直到《时差七小时》上映，人们才注意到妞妞的年龄远超出少女的范畴。她 1979 年出生，比片中搭档陈冠希还要大上一岁。而且妞妞并不属于青春娇俏的范畴，她确实“其貌不扬”，而且用制片方的说法：陈冠希看到她扭头就走，最后还是在导演“劝说”下才同意留下来。看过《时差七小时》的观众们在网络上留言：“妞妞并不青春”。为什么是妞妞？\n\n《时差七小时》的女主角最初采用网络征选，最终还是花落原著者妞妞身上着实有些蹊跷。影片完全是由深圳制作班底打造，由深圳市三家公司投资，深圳导演阿甘执导，而为妞妞出书的出版社正是妞妞妈妈的工作单位。妞妞在接受采访时表示，其实一开始她的父母并不主张她出演这部电影，当时她报名参加女主角的全球征选的那段时间是和父母关系最紧张的一段时间，但是留学生活中练就的敢作敢为促成了这件事。\n\n导演阿甘也表示，之所以让妞妞当主角，是因为当时没有合适的人选，情急之下做了这个选择，而原定的刘亦菲则因为“太漂亮”而落选，“她太漂亮了，不符合书中丑小鸭的感觉。”但是妞妞的表现也差点让阿甘崩溃，据工作人员介绍，妞妞在进组一星期之后还完全无法进入状态，甚至连如何走位都要导演一遍一遍示范。由于陈冠希档期已定，更换女主角根本来不及，阿甘才坚持下来。\n\n不过妞妞对自己在电影中的表现则非常满意，她说：“我正在考虑以后是继续写书，还是转行做个职业演员。”为什么要拍这部影片？\n\n据介绍，剧情是 16 岁的 J ean(妞妞饰)穿着土土的毛衣只身来到伦敦机场，操着稍显蹩脚的英文问路和打电话，殊不知被学校安排来接她的香港男孩 DJ(陈冠希饰)已经守候了 6 个小时。他们之间的友情乃至朦胧的爱情便渐渐产生……\n\n来自全国广州、深圳各主流媒体和国内知名专家的评价表明“影片反映了积极向上的当代青少年的生活，真实艺术地再现了中国少年留学生在海外的学习和生活”。“小说和影片关于顺境教育和挫折教育；乖孩子和承受力、自强力的培育；成长的选择与权利，以及主人公对东西文化冲突的思考都将引起孩子们的观看欲”。其实，类似励志的青春作品还有很多，比如《哈佛女孩刘亦婷》。相比之下，《时差七小时》只反映一小部分留学人员的个人生活，居然获得国内各级文化管理部门、主流媒体如此众多的“盛誉”。这其中的“文化气息”，似乎更加值得玩味。\n\n2100 万从何而来？\n\n《时差七小时》是第一部全部在国外取景拍摄的国产影片，2100 万投资也号称是国内“最昂贵的青春片”。制片主任居晔表示，深圳的民营企业在融资中提供了许多便利，企业都主动表示愿意投资。\n\n但是导演阿甘却曾经表示，虽然 2100 万人民币在英国算低成本，但在中国内地，收回成本的机会则比较渺茫。他只好把希望寄托在国内票房和海外版权，国内票房的目标定为 6000 万，海外版权的任务则是 30 万美元。就是冯小刚的影片也只能达到近 5000 万，国内票房 6000 万根本没有可能，而沈阳等一些大城市在 11 月份也没有上映该片的计划。按照北方院线徐经理的话讲：“该片无论是题材还是阵容都无法称得上国产影片中的大片。”有关部门为什么要组织观看？\n\n深圳市有关部门联合下发文件，要求初中学生安排在上课时间，自费购票观看《时差七小时》。影片《时差七小时》公映后，仅 3 天的时间就在深圳创下 64.5 万元的票房收入。当地文化部门表示，深圳是历来有扶持本土青春影片的习惯，比如《花季雨季》。这部《时差七小时》展现了一个新颖的题材，对学生们的成长非常有教育意义。他们承认确实曾向学校推介这部电影，但没有强制学生一定要看。但当地观众似乎并不买账，尤其是学生家长批评影片反映的这种个人化的生活与老百姓无关，教育意义不及《邓小平》等影片，并质疑有关部门硬销这部影片是否妥当。\n\n参考\n\n- [时差七小时-wikipedia](https://zh.wikipedia.org/zh-hans/%E6%97%B6%E5%B7%AE7%E5%B0%8F%E6%97%B6)\n- [追问《时差七小时》高官背景](http://culture.163.com/editor/news/041105/041105_101550.html)\n","slug":"七小时时差","published":1,"date":"2021-07-03T13:33:27.529Z","updated":"2021-07-04T07:32:13.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqoye6h700019su016lrhia9","content":"<p>2004 年 10 月 19 日，一部描写在英国的中国小留学生学习生活的电影《时差七小时》在北京举行新闻发布会。这部投资可观的电影请来了香港偶像明星助阵，在媒体上的宣传也颇具规模，可是这部电影的女主角却在电影界无人知晓。这个被叫做妞妞的女孩，同时也是这部电影的编剧、出品人、制片人。她是谁，为什么能够得到这些很多人梦寐以求的机会？</p>\n<span id=\"more\"></span>\n\n<p>冠以“留学生指南”电影的《时差七小时》10 月 27 日开始在全国上映，上映 3 天，该片全国总票房 67 万，在南京、成都、重庆等地票房均只有一两万情况下，影片原产地深圳包揽了其中的 60 余万票房，呈现一枝独秀的奇特景观。10 月 31 日，有观众反映，深圳市有关部门联合出面，组织深圳市中小学生自费集体观看，但观映后发现，影片对青少年的教育意义却微乎其微。而其貌不扬的女主角妞妞的父母都有着各自敏感的身份———深圳市市委某领导和深圳一家由国家新闻出版署和深圳市政府共同领导下的某出版社负责人。此外，一部纯青春片却完全在国外取景拍摄，制作费用高达 2100 万巨资……一时间，影片故事以外的内容掀起重重波澜。妞妞是谁？</p>\n<p>《时差七小时》改编妞妞写的畅销小说《长翅膀的绵羊》，该书讲述了一个 16 岁的中国少女留学英伦的青春故事。该书还曾经在 2003 年被评为全国 2002 年度优秀畅销书，但是，该书的销量是由深圳消化了大部分。在妞妞的背景被了解之前，该片最大的卖点可能就是小说作者亲自上阵同陈冠希搭档拍戏了。</p>\n<p>因为是描述 16 岁少女留学生活的青春影片，人们好奇妞妞是何青春模样。直到《时差七小时》上映，人们才注意到妞妞的年龄远超出少女的范畴。她 1979 年出生，比片中搭档陈冠希还要大上一岁。而且妞妞并不属于青春娇俏的范畴，她确实“其貌不扬”，而且用制片方的说法：陈冠希看到她扭头就走，最后还是在导演“劝说”下才同意留下来。看过《时差七小时》的观众们在网络上留言：“妞妞并不青春”。为什么是妞妞？</p>\n<p>《时差七小时》的女主角最初采用网络征选，最终还是花落原著者妞妞身上着实有些蹊跷。影片完全是由深圳制作班底打造，由深圳市三家公司投资，深圳导演阿甘执导，而为妞妞出书的出版社正是妞妞妈妈的工作单位。妞妞在接受采访时表示，其实一开始她的父母并不主张她出演这部电影，当时她报名参加女主角的全球征选的那段时间是和父母关系最紧张的一段时间，但是留学生活中练就的敢作敢为促成了这件事。</p>\n<p>导演阿甘也表示，之所以让妞妞当主角，是因为当时没有合适的人选，情急之下做了这个选择，而原定的刘亦菲则因为“太漂亮”而落选，“她太漂亮了，不符合书中丑小鸭的感觉。”但是妞妞的表现也差点让阿甘崩溃，据工作人员介绍，妞妞在进组一星期之后还完全无法进入状态，甚至连如何走位都要导演一遍一遍示范。由于陈冠希档期已定，更换女主角根本来不及，阿甘才坚持下来。</p>\n<p>不过妞妞对自己在电影中的表现则非常满意，她说：“我正在考虑以后是继续写书，还是转行做个职业演员。”为什么要拍这部影片？</p>\n<p>据介绍，剧情是 16 岁的 J ean(妞妞饰)穿着土土的毛衣只身来到伦敦机场，操着稍显蹩脚的英文问路和打电话，殊不知被学校安排来接她的香港男孩 DJ(陈冠希饰)已经守候了 6 个小时。他们之间的友情乃至朦胧的爱情便渐渐产生……</p>\n<p>来自全国广州、深圳各主流媒体和国内知名专家的评价表明“影片反映了积极向上的当代青少年的生活，真实艺术地再现了中国少年留学生在海外的学习和生活”。“小说和影片关于顺境教育和挫折教育；乖孩子和承受力、自强力的培育；成长的选择与权利，以及主人公对东西文化冲突的思考都将引起孩子们的观看欲”。其实，类似励志的青春作品还有很多，比如《哈佛女孩刘亦婷》。相比之下，《时差七小时》只反映一小部分留学人员的个人生活，居然获得国内各级文化管理部门、主流媒体如此众多的“盛誉”。这其中的“文化气息”，似乎更加值得玩味。</p>\n<p>2100 万从何而来？</p>\n<p>《时差七小时》是第一部全部在国外取景拍摄的国产影片，2100 万投资也号称是国内“最昂贵的青春片”。制片主任居晔表示，深圳的民营企业在融资中提供了许多便利，企业都主动表示愿意投资。</p>\n<p>但是导演阿甘却曾经表示，虽然 2100 万人民币在英国算低成本，但在中国内地，收回成本的机会则比较渺茫。他只好把希望寄托在国内票房和海外版权，国内票房的目标定为 6000 万，海外版权的任务则是 30 万美元。就是冯小刚的影片也只能达到近 5000 万，国内票房 6000 万根本没有可能，而沈阳等一些大城市在 11 月份也没有上映该片的计划。按照北方院线徐经理的话讲：“该片无论是题材还是阵容都无法称得上国产影片中的大片。”有关部门为什么要组织观看？</p>\n<p>深圳市有关部门联合下发文件，要求初中学生安排在上课时间，自费购票观看《时差七小时》。影片《时差七小时》公映后，仅 3 天的时间就在深圳创下 64.5 万元的票房收入。当地文化部门表示，深圳是历来有扶持本土青春影片的习惯，比如《花季雨季》。这部《时差七小时》展现了一个新颖的题材，对学生们的成长非常有教育意义。他们承认确实曾向学校推介这部电影，但没有强制学生一定要看。但当地观众似乎并不买账，尤其是学生家长批评影片反映的这种个人化的生活与老百姓无关，教育意义不及《邓小平》等影片，并质疑有关部门硬销这部影片是否妥当。</p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/zh-hans/%E6%97%B6%E5%B7%AE7%E5%B0%8F%E6%97%B6\">时差七小时-wikipedia</a></li>\n<li><a href=\"http://culture.163.com/editor/news/041105/041105_101550.html\">追问《时差七小时》高官背景</a></li>\n</ul>\n","site":{"data":{}},"length":2155,"excerpt":"<p>2004 年 10 月 19 日，一部描写在英国的中国小留学生学习生活的电影《时差七小时》在北京举行新闻发布会。这部投资可观的电影请来了香港偶像明星助阵，在媒体上的宣传也颇具规模，可是这部电影的女主角却在电影界无人知晓。这个被叫做妞妞的女孩，同时也是这部电影的编剧、出品人、制片人。她是谁，为什么能够得到这些很多人梦寐以求的机会？</p>","more":"<p>冠以“留学生指南”电影的《时差七小时》10 月 27 日开始在全国上映，上映 3 天，该片全国总票房 67 万，在南京、成都、重庆等地票房均只有一两万情况下，影片原产地深圳包揽了其中的 60 余万票房，呈现一枝独秀的奇特景观。10 月 31 日，有观众反映，深圳市有关部门联合出面，组织深圳市中小学生自费集体观看，但观映后发现，影片对青少年的教育意义却微乎其微。而其貌不扬的女主角妞妞的父母都有着各自敏感的身份———深圳市市委某领导和深圳一家由国家新闻出版署和深圳市政府共同领导下的某出版社负责人。此外，一部纯青春片却完全在国外取景拍摄，制作费用高达 2100 万巨资……一时间，影片故事以外的内容掀起重重波澜。妞妞是谁？</p>\n<p>《时差七小时》改编妞妞写的畅销小说《长翅膀的绵羊》，该书讲述了一个 16 岁的中国少女留学英伦的青春故事。该书还曾经在 2003 年被评为全国 2002 年度优秀畅销书，但是，该书的销量是由深圳消化了大部分。在妞妞的背景被了解之前，该片最大的卖点可能就是小说作者亲自上阵同陈冠希搭档拍戏了。</p>\n<p>因为是描述 16 岁少女留学生活的青春影片，人们好奇妞妞是何青春模样。直到《时差七小时》上映，人们才注意到妞妞的年龄远超出少女的范畴。她 1979 年出生，比片中搭档陈冠希还要大上一岁。而且妞妞并不属于青春娇俏的范畴，她确实“其貌不扬”，而且用制片方的说法：陈冠希看到她扭头就走，最后还是在导演“劝说”下才同意留下来。看过《时差七小时》的观众们在网络上留言：“妞妞并不青春”。为什么是妞妞？</p>\n<p>《时差七小时》的女主角最初采用网络征选，最终还是花落原著者妞妞身上着实有些蹊跷。影片完全是由深圳制作班底打造，由深圳市三家公司投资，深圳导演阿甘执导，而为妞妞出书的出版社正是妞妞妈妈的工作单位。妞妞在接受采访时表示，其实一开始她的父母并不主张她出演这部电影，当时她报名参加女主角的全球征选的那段时间是和父母关系最紧张的一段时间，但是留学生活中练就的敢作敢为促成了这件事。</p>\n<p>导演阿甘也表示，之所以让妞妞当主角，是因为当时没有合适的人选，情急之下做了这个选择，而原定的刘亦菲则因为“太漂亮”而落选，“她太漂亮了，不符合书中丑小鸭的感觉。”但是妞妞的表现也差点让阿甘崩溃，据工作人员介绍，妞妞在进组一星期之后还完全无法进入状态，甚至连如何走位都要导演一遍一遍示范。由于陈冠希档期已定，更换女主角根本来不及，阿甘才坚持下来。</p>\n<p>不过妞妞对自己在电影中的表现则非常满意，她说：“我正在考虑以后是继续写书，还是转行做个职业演员。”为什么要拍这部影片？</p>\n<p>据介绍，剧情是 16 岁的 J ean(妞妞饰)穿着土土的毛衣只身来到伦敦机场，操着稍显蹩脚的英文问路和打电话，殊不知被学校安排来接她的香港男孩 DJ(陈冠希饰)已经守候了 6 个小时。他们之间的友情乃至朦胧的爱情便渐渐产生……</p>\n<p>来自全国广州、深圳各主流媒体和国内知名专家的评价表明“影片反映了积极向上的当代青少年的生活，真实艺术地再现了中国少年留学生在海外的学习和生活”。“小说和影片关于顺境教育和挫折教育；乖孩子和承受力、自强力的培育；成长的选择与权利，以及主人公对东西文化冲突的思考都将引起孩子们的观看欲”。其实，类似励志的青春作品还有很多，比如《哈佛女孩刘亦婷》。相比之下，《时差七小时》只反映一小部分留学人员的个人生活，居然获得国内各级文化管理部门、主流媒体如此众多的“盛誉”。这其中的“文化气息”，似乎更加值得玩味。</p>\n<p>2100 万从何而来？</p>\n<p>《时差七小时》是第一部全部在国外取景拍摄的国产影片，2100 万投资也号称是国内“最昂贵的青春片”。制片主任居晔表示，深圳的民营企业在融资中提供了许多便利，企业都主动表示愿意投资。</p>\n<p>但是导演阿甘却曾经表示，虽然 2100 万人民币在英国算低成本，但在中国内地，收回成本的机会则比较渺茫。他只好把希望寄托在国内票房和海外版权，国内票房的目标定为 6000 万，海外版权的任务则是 30 万美元。就是冯小刚的影片也只能达到近 5000 万，国内票房 6000 万根本没有可能，而沈阳等一些大城市在 11 月份也没有上映该片的计划。按照北方院线徐经理的话讲：“该片无论是题材还是阵容都无法称得上国产影片中的大片。”有关部门为什么要组织观看？</p>\n<p>深圳市有关部门联合下发文件，要求初中学生安排在上课时间，自费购票观看《时差七小时》。影片《时差七小时》公映后，仅 3 天的时间就在深圳创下 64.5 万元的票房收入。当地文化部门表示，深圳是历来有扶持本土青春影片的习惯，比如《花季雨季》。这部《时差七小时》展现了一个新颖的题材，对学生们的成长非常有教育意义。他们承认确实曾向学校推介这部电影，但没有强制学生一定要看。但当地观众似乎并不买账，尤其是学生家长批评影片反映的这种个人化的生活与老百姓无关，教育意义不及《邓小平》等影片，并质疑有关部门硬销这部影片是否妥当。</p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/zh-hans/%E6%97%B6%E5%B7%AE7%E5%B0%8F%E6%97%B6\">时差七小时-wikipedia</a></li>\n<li><a href=\"http://culture.163.com/editor/news/041105/041105_101550.html\">追问《时差七小时》高官背景</a></li>\n</ul>"},{"title":"【浏览器怎么操作二进制】【一】javaScript二进制对象基本认知","type":"tags","_content":"\n#### [ArrayBuffer,二进制数组](https://zh.javascript.info/arraybuffer-binary-arrays)\n\n在 Web 开发中，当我们处理文件时（创建，上传，下载），经常会遇到二进制数据。另一个典型的应用场景是图像处理。\n\n这些都可以通过 JavaScript 进行处理，而且二进制操作性能更高。\n\n不过，在 JavaScript 中有很多种二进制数据格式，会有点容易混淆。仅举几个例子：\n\n- `ArrayBuffer`，`Uint8Array`，`DataView`，`Blob`，`File` 及其他。\n\n与其他语言相比，**JavaScript 中的二进制数据是以非标准方式实现的**。但是，当我们理清楚以后，一切就会变得相当简单了。\n\n<!--more-->\n\n##### [ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n\n**基本的二进制对象是 `ArrayBuffer` —— 对固定长度的连续内存空间的引用。**\n\n```javascript\nlet buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer\nalert(buffer.byteLength); // 16\n```\n\n它会分配一个 16 字节的连续内存空间，并用 0 进行预填充。\n\n`ArrayBuffer` **不是某种东西的数组**\n\n让我们先澄清一个可能的误区。`ArrayBuffer` 与 `Array` 没有任何共同之处：\n\n- 它的长度是固定的，我们无法增加或减少它的长度。\n- 它正好占用了内存中的那么多空间。\n- 要访问单个字节，需要另一个“视图”对象，而不是 `buffer[index]`。\n\n`ArrayBuffer` 是一个内存区域。它里面存储了什么？无从判断。只是一个原始的字节序列。\n\n[怎么理解 JavaScript 中的 ArrayBuffer？ - Jim Liu 的回答 - 知乎](https://www.zhihu.com/question/30401979/answer/48421340)\n\n**如要操作 `ArrayBuffer`，我们需要使用“视图”对象。**\n\n视图对象本身并不存储任何东西。它是一副“眼镜”，透过它来解释存储在 `ArrayBuffer` 中的字节。\n\n例如：\n\n- **`Uint8Array`** —— 将 `ArrayBuffer` 中的每个字节视为 0 到 255 之间的单个数字（每个字节是 8 位，因此只能容纳那么多）。这称为 “8 位无符号整数”。\n- **`Uint16Array`** —— 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。\n- **`Uint32Array`** —— 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。\n- **`Float64Array`** —— 将每 8 个字节视为一个 `5.0x10-324` 到 `1.8x10308` 之间的浮点数。\n\n因此，一个 16 字节 `ArrayBuffer` 中的二进制数据可以解释为 16 个“小数字”，或 8 个更大的数字（每个数字 2 个字节），或 4 个更大的数字（每个数字 4 个字节），或 2 个高精度的浮点数（每个数字 8 个字节）。\n\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/arraybuffer-views.svg\">\n\n`ArrayBuffer` 是核心对象，是所有的基础，是原始的二进制数据。\n\n但是，如果我们要写入值或遍历它，基本上几乎所有操作 —— 我们必须使用视图（view），例如：\n\n```javascript\nlet buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer\n\nlet view = new Uint32Array(buffer); // 将 buffer 视为一个 32 位整数的序列\n\nalert(Uint32Array.BYTES_PER_ELEMENT); // 每个整数 4 个字节\n\nalert(view.length); // 4，它存储了 4 个整数\nalert(view.byteLength); // 16，字节中的大小\n\n// 让我们写入一个值\nview[0] = 123456;\n\n// 遍历值\nfor (let num of view) {\n  alert(num); // 123456，然后 0，0，0（一共 4 个值）\n}\n```\n\n##### [TypedArray 视图](https://zh.javascript.info/arraybuffer-binary-arrays#typedarray)\n\n所有这些视图（`Uint8Array`，`Uint32Array` 等）的通用术语是 [TypedArray](https://tc39.github.io/ecma262/#sec-typedarray-objects)。它们都享有同一组方法和属性。\n\n请注意，没有名为 `TypedArray` 的构造器，它只是表示 `ArrayBuffer` 上的视图之一的通用总称术语：`Int8Array`，`Uint8Array` 及其他，很快就会有完整列表。\n\n当你看到 `new TypedArray` 之类的内容时，它表示 `new Int8Array`、`new Uint8Array` 及其他中之一。\n\n类型化数组的行为类似于常规数组：具有索引，并且是可迭代的。\n\n一个类型化数组的构造器（无论是 `Int8Array` 或 `Float64Array`，都无关紧要），其行为各不相同，并且取决于参数类型。\n\n参数有 5 种变体：\n\n```javascript\nnew TypedArray(buffer, [byteOffset], [length]);\nnew TypedArray(object);\nnew TypedArray(typedArray);\nnew TypedArray(length);\nnew TypedArray();\n```\n\n1. 如果给定的是 `ArrayBuffer` 参数，则会在其上创建视图。我们已经用过该语法了。\n\n   可选，我们可以给定起始位置 `byteOffset`（默认为 0）以及 `length`（默认至 buffer 的末尾），这样视图将仅涵盖 `buffer` 的一部分。\n\n2. 如果给定的是 `Array`，或任何类数组对象，则会创建一个相同长度的类型化数组，并复制其内容。\n\n   我们可以使用它来预填充数组的数据：\n\n   ```javascript\n   let arr = new Uint8Array([0, 1, 2, 3]);\n   alert(arr.length); // 4，创建了相同长度的二进制数组\n   alert(arr[1]); // 1，用给定值填充了 4 个字节（无符号 8 位整数）\n   ```\n\n3. 如果给定的是另一个 `TypedArray`，也是如此：创建一个相同长度的类型化数组，并复制其内容。如果需要的话，数据在此过程中会被转换为新的类型。\n\n   ```javascript\n   let arr16 = new Uint16Array([1, 1000]);\n   let arr8 = new Uint8Array(arr16);\n   alert(arr8[0]); // 1\n   alert(arr8[1]); // 232，试图复制 1000，但无法将 1000 放进 8 位字节中（详述见下文）。\n   ```\n\n   4.对于数字参数 `length` —— 创建类型化数组以包含这么多元素。它的字节长度将是 `length` 乘以单个 `TypedArray.BYTES_PER_ELEMENT` 中的字节数：\n\n   ```javascript\n   let arr = new Uint16Array(4); // 为 4 个整数创建类型化数组\n   alert(Uint16Array.BYTES_PER_ELEMENT); // 每个整数 2 个字节\n   alert(arr.byteLength); // 8（字节中的大小）\n   ```\n\n   5.不带参数的情况下，创建长度为零的类型化数组。\n\n<hr/>\n\n我们可以直接创建一个 `TypedArray`，而无需提及 `ArrayBuffer`。但是，视图离不开底层的 `ArrayBuffer`，因此，除第一种情况（已提供 `ArrayBuffer`）外，其他所有情况都会自动创建 `ArrayBuffer`。\n\n如要访问 `ArrayBuffer`，可以用以下属性：\n\n- `arr.buffer` —— 引用 `ArrayBuffer`。\n- `arr.byteLength` —— `ArrayBuffer` 的长度。\n\n因此，我们总是可以从一个视图转到另一个视图:\n\n```javascript\nlet arr8 = new Uint8Array([0, 1, 2, 3]);\n\n// 同一数据的另一个视图\nlet arr16 = new Uint16Array(arr8.buffer);\n```\n\n下面是类型化数组的列表：\n\n| TypeArray   |        |      | 位数 | 字节（BYTES_PER_ELEMENT） |\n| ----------- | ------ | ---- | ---- | ------------------------- |\n| Uint8Array  | 无符号 | 整数 | 8    | 1                         |\n| Uint16Array | 无符号 | 整数 | 16   | 2                         |\n| Uint32Array | 无符号 | 整数 | 32   | 4                         |\n\n| TypeArray  |        |      | 位数 | 字节（BYTES_PER_ELEMENT） |\n| ---------- | ------ | ---- | ---- | ------------------------- |\n| Int8Array  | 有符号 | 整数 | 8    | 1                         |\n| Int16Array | 有符号 | 整数 | 16   | 2                         |\n| Int32Array | 有符号 | 整数 | 32   | 4                         |\n\n| TypeArray    |        |        | 位数 | 字节（BYTES_PER_ELEMENT） |\n| ------------ | ------ | ------ | ---- | ------------------------- |\n| Float32Array | 有符号 | 浮点数 | 32   | 4                         |\n| Float64Array | 有符号 | 浮点数 | 64   | 8                         |\n\nUint8ClampedArray 用于 8 位整数，在赋值时便“固定“其值（见下文）。\n\n###### 越界行为\n\n如果我们尝试将越界值写入类型化数组会出现什么情况？<span style=\"color:red\">不会报错</span>。但是多余的位被切除。\n\n例如，我们尝试将 256 放入 `Uint8Array`。超出的部分没有存储，结果是 0。\n\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/8bit-integer-256.svg\">\n\n例如，我们尝试将 257 放入 `Uint8Array`。超出的部分没有存储，结果是 1。\n\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/8bit-integer-257.svg\">\n\n换句话说，该数字对 28 取模的结果被保存了下来。\n\n示例如下：\n\n```javascript\nlet uint8array = new Uint8Array(16);\n\nlet num = 256;\n\nalert(num.toString(2)); // 100000000（二进制表示）\n\nuint8array[0] = 256;\nuint8array[1] = 257;\n\nalert(uint8array[0]); // 0\nalert(uint8array[1]); // 1\n```\n\n`Uint8ClampedArray` 在这方面比较特殊，它的表现不太一样。对于大于 255 的任何数字，它将保存为 255，对于任何负数，它将保存为 0。此行为对于图像处理很有用。\n\n##### [TypedArray 方法](https://zh.javascript.info/arraybuffer-binary-arrays#typedarray-fang-fa)\n\n`TypedArray` 具有常规的 `Array` 方法，但有个明显的例外。\n\n我们可以遍历（iterate），`map`，`slice`，`find` 和 `reduce` 等。\n\n但有几件事我们做不了：\n\n- 没有 `splice` —— 我们无法“删除”一个值，因为类型化数组是缓冲区（buffer）上的视图，并且缓冲区（buffer）是固定的、连续的内存区域。我们所能做的就是分配一个零值。\n- 无 `concat` 方法。\n\n还有两种其他方法（替代）：\n\n- `arr.set(fromArr, [offset])` 从 `offset`（默认为 0）开始，将 `fromArr` 中的所有元素复制到 `arr`。\n- `arr.subarray([begin, end])` 创建一个从 `begin` 到 `end`（不包括）相同类型的新视图。这类似于 `slice` 方法（同样也支持），但不复制任何内容 —— 只是创建一个新视图，以对给定片段的数据进行操作。\n\n有了这些方法，我们可以复制、混合类型化数组，从现有数组创建新数组等。\n\n##### [DataView](https://zh.javascript.info/arraybuffer-binary-arrays#dataview)\n\n[DataView](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/DataView) 是在 `ArrayBuffer` 上的一种特殊的超灵活“未类型化”视图。它允许以任何格式访问任何偏移量（offset）的数据。\n\n- 对于类型化的数组(TypeArray)，构造器决定了其格式。整个数组应该是统一的。第 i 个数字是 `arr[i]`。\n- 通过 `DataView`，我们可以使用 `.getUint8(i)` 或 `.getUint16(i)` 之类的方法访问数据。我们在调用方法时选择格式，而不是在构造的时候。\n\n语法:\n\n`new DataView(buffer, [byteOffset], [byteLength])`\n\n- **`buffer`** —— 底层的 `ArrayBuffer`。与类型化数组不同，`DataView` 不会自行创建缓冲区（buffer）。我们需要事先准备好。\n- **`byteOffset`** —— 视图的起始字节位置（默认为 0）。\n- **`byteLength`** —— 视图的字节长度（默认至 `buffer` 的末尾）。\n\n例如，这里我们从同一个 buffer 中提取不同格式的数字：\n\n```javascript\n// 4 个字节的二进制数组，每个都是最大值 255\nlet buffer = new Uint8Array([255, 255, 255, 255]).buffer;\n\nlet dataView = new DataView(buffer);\n\n// 在偏移量为 0 处获取 8 位数字\nalert(dataView.getUint8(0)); // 255\n\n// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535\nalert(dataView.getUint16(0)); // 65535（最大的 16 位无符号整数）\n\n// 在偏移量为 0 处获取 32 位数字\nalert(dataView.getUint32(0)); // 4294967295（最大的 32 位无符号整数）\n\ndataView.setUint32(0, 0); // 将 4 个字节的数字设为 0，即将所有字节都设为 0\n```\n\n当我们将混合格式的数据存储在同一缓冲区（buffer）中时，`DataView` 非常有用。例如，当我们存储一个成对序列（16 位整数，32 位浮点数）时，用 `DataView` 可以轻松访问它们。\n\n##### 总结\n\n`ArrayBuffer` 是核心对象，是对固定长度的连续内存区域的引用。\n\n几乎任何对 `ArrayBuffer` 的操作，都需要一个视图。\n\n- 它可以是 `TypedArray`\n  - `Uint8Array`，`Uint16Array`，`Uint32Array` —— 用于 8 位、16 位和 32 位无符号整数。\n  - `Uint8ClampedArray` —— 用于 8 位整数，在赋值时便“固定”其值。\n  - `Int8Array`，`Int16Array`，`Int32Array` —— 用于有符号整数（可以为负数）。\n  - `Float32Array`，`Float64Array` —— 用于 32 位和 64 位的有符号浮点数。\n- 或 `DataView` —— 使用方法来指定格式的视图，例如，`getUint8(offset)`。\n\n在大多数情况下，我们直接对类型化数组进行创建和操作，而将 `ArrayBuffer` 作为“通用标识符（common discriminator）”隐藏起来。我们可以通过 `.buffer` 来访问它，并在需要时创建另一个视图。\n\n还有另外两个术语，用于对二进制数据进行操作的方法的描述：\n\n- `ArrayBufferView` 是所有这些视图的总称。\n- `BufferSource` 是 `ArrayBuffer` 或 `ArrayBufferView` 的总称。\n\n我们将在下一章中学习这些术语。`BufferSource` 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— `ArrayBuffer` 或其上的视图。\n\n参考文章\n\n- [现代前端 JavaScript](https://zh.javascript.info/arraybuffer-binary-arrays)\n- [MDN ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n- [MDN DataView](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView)\n- [怎么理解 JavaScript 中的 ArrayBuffer？ - Jim Liu 的回答 - 知乎](https://www.zhihu.com/question/30401979/answer/48421340)\n- [binary family](https://zhuanlan.zhihu.com/p/97768916)\n","source":"_posts/流处理.md","raw":"---\ntitle: 【浏览器怎么操作二进制】【一】javaScript二进制对象基本认知\ntype: \"tags\"\ntags:\n  - ArrayBuffer\n  - TypeArray\n  - DataView\n  - 二进制\ncategories: 二进制数据,文件\n---\n\n#### [ArrayBuffer,二进制数组](https://zh.javascript.info/arraybuffer-binary-arrays)\n\n在 Web 开发中，当我们处理文件时（创建，上传，下载），经常会遇到二进制数据。另一个典型的应用场景是图像处理。\n\n这些都可以通过 JavaScript 进行处理，而且二进制操作性能更高。\n\n不过，在 JavaScript 中有很多种二进制数据格式，会有点容易混淆。仅举几个例子：\n\n- `ArrayBuffer`，`Uint8Array`，`DataView`，`Blob`，`File` 及其他。\n\n与其他语言相比，**JavaScript 中的二进制数据是以非标准方式实现的**。但是，当我们理清楚以后，一切就会变得相当简单了。\n\n<!--more-->\n\n##### [ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n\n**基本的二进制对象是 `ArrayBuffer` —— 对固定长度的连续内存空间的引用。**\n\n```javascript\nlet buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer\nalert(buffer.byteLength); // 16\n```\n\n它会分配一个 16 字节的连续内存空间，并用 0 进行预填充。\n\n`ArrayBuffer` **不是某种东西的数组**\n\n让我们先澄清一个可能的误区。`ArrayBuffer` 与 `Array` 没有任何共同之处：\n\n- 它的长度是固定的，我们无法增加或减少它的长度。\n- 它正好占用了内存中的那么多空间。\n- 要访问单个字节，需要另一个“视图”对象，而不是 `buffer[index]`。\n\n`ArrayBuffer` 是一个内存区域。它里面存储了什么？无从判断。只是一个原始的字节序列。\n\n[怎么理解 JavaScript 中的 ArrayBuffer？ - Jim Liu 的回答 - 知乎](https://www.zhihu.com/question/30401979/answer/48421340)\n\n**如要操作 `ArrayBuffer`，我们需要使用“视图”对象。**\n\n视图对象本身并不存储任何东西。它是一副“眼镜”，透过它来解释存储在 `ArrayBuffer` 中的字节。\n\n例如：\n\n- **`Uint8Array`** —— 将 `ArrayBuffer` 中的每个字节视为 0 到 255 之间的单个数字（每个字节是 8 位，因此只能容纳那么多）。这称为 “8 位无符号整数”。\n- **`Uint16Array`** —— 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。\n- **`Uint32Array`** —— 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。\n- **`Float64Array`** —— 将每 8 个字节视为一个 `5.0x10-324` 到 `1.8x10308` 之间的浮点数。\n\n因此，一个 16 字节 `ArrayBuffer` 中的二进制数据可以解释为 16 个“小数字”，或 8 个更大的数字（每个数字 2 个字节），或 4 个更大的数字（每个数字 4 个字节），或 2 个高精度的浮点数（每个数字 8 个字节）。\n\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/arraybuffer-views.svg\">\n\n`ArrayBuffer` 是核心对象，是所有的基础，是原始的二进制数据。\n\n但是，如果我们要写入值或遍历它，基本上几乎所有操作 —— 我们必须使用视图（view），例如：\n\n```javascript\nlet buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer\n\nlet view = new Uint32Array(buffer); // 将 buffer 视为一个 32 位整数的序列\n\nalert(Uint32Array.BYTES_PER_ELEMENT); // 每个整数 4 个字节\n\nalert(view.length); // 4，它存储了 4 个整数\nalert(view.byteLength); // 16，字节中的大小\n\n// 让我们写入一个值\nview[0] = 123456;\n\n// 遍历值\nfor (let num of view) {\n  alert(num); // 123456，然后 0，0，0（一共 4 个值）\n}\n```\n\n##### [TypedArray 视图](https://zh.javascript.info/arraybuffer-binary-arrays#typedarray)\n\n所有这些视图（`Uint8Array`，`Uint32Array` 等）的通用术语是 [TypedArray](https://tc39.github.io/ecma262/#sec-typedarray-objects)。它们都享有同一组方法和属性。\n\n请注意，没有名为 `TypedArray` 的构造器，它只是表示 `ArrayBuffer` 上的视图之一的通用总称术语：`Int8Array`，`Uint8Array` 及其他，很快就会有完整列表。\n\n当你看到 `new TypedArray` 之类的内容时，它表示 `new Int8Array`、`new Uint8Array` 及其他中之一。\n\n类型化数组的行为类似于常规数组：具有索引，并且是可迭代的。\n\n一个类型化数组的构造器（无论是 `Int8Array` 或 `Float64Array`，都无关紧要），其行为各不相同，并且取决于参数类型。\n\n参数有 5 种变体：\n\n```javascript\nnew TypedArray(buffer, [byteOffset], [length]);\nnew TypedArray(object);\nnew TypedArray(typedArray);\nnew TypedArray(length);\nnew TypedArray();\n```\n\n1. 如果给定的是 `ArrayBuffer` 参数，则会在其上创建视图。我们已经用过该语法了。\n\n   可选，我们可以给定起始位置 `byteOffset`（默认为 0）以及 `length`（默认至 buffer 的末尾），这样视图将仅涵盖 `buffer` 的一部分。\n\n2. 如果给定的是 `Array`，或任何类数组对象，则会创建一个相同长度的类型化数组，并复制其内容。\n\n   我们可以使用它来预填充数组的数据：\n\n   ```javascript\n   let arr = new Uint8Array([0, 1, 2, 3]);\n   alert(arr.length); // 4，创建了相同长度的二进制数组\n   alert(arr[1]); // 1，用给定值填充了 4 个字节（无符号 8 位整数）\n   ```\n\n3. 如果给定的是另一个 `TypedArray`，也是如此：创建一个相同长度的类型化数组，并复制其内容。如果需要的话，数据在此过程中会被转换为新的类型。\n\n   ```javascript\n   let arr16 = new Uint16Array([1, 1000]);\n   let arr8 = new Uint8Array(arr16);\n   alert(arr8[0]); // 1\n   alert(arr8[1]); // 232，试图复制 1000，但无法将 1000 放进 8 位字节中（详述见下文）。\n   ```\n\n   4.对于数字参数 `length` —— 创建类型化数组以包含这么多元素。它的字节长度将是 `length` 乘以单个 `TypedArray.BYTES_PER_ELEMENT` 中的字节数：\n\n   ```javascript\n   let arr = new Uint16Array(4); // 为 4 个整数创建类型化数组\n   alert(Uint16Array.BYTES_PER_ELEMENT); // 每个整数 2 个字节\n   alert(arr.byteLength); // 8（字节中的大小）\n   ```\n\n   5.不带参数的情况下，创建长度为零的类型化数组。\n\n<hr/>\n\n我们可以直接创建一个 `TypedArray`，而无需提及 `ArrayBuffer`。但是，视图离不开底层的 `ArrayBuffer`，因此，除第一种情况（已提供 `ArrayBuffer`）外，其他所有情况都会自动创建 `ArrayBuffer`。\n\n如要访问 `ArrayBuffer`，可以用以下属性：\n\n- `arr.buffer` —— 引用 `ArrayBuffer`。\n- `arr.byteLength` —— `ArrayBuffer` 的长度。\n\n因此，我们总是可以从一个视图转到另一个视图:\n\n```javascript\nlet arr8 = new Uint8Array([0, 1, 2, 3]);\n\n// 同一数据的另一个视图\nlet arr16 = new Uint16Array(arr8.buffer);\n```\n\n下面是类型化数组的列表：\n\n| TypeArray   |        |      | 位数 | 字节（BYTES_PER_ELEMENT） |\n| ----------- | ------ | ---- | ---- | ------------------------- |\n| Uint8Array  | 无符号 | 整数 | 8    | 1                         |\n| Uint16Array | 无符号 | 整数 | 16   | 2                         |\n| Uint32Array | 无符号 | 整数 | 32   | 4                         |\n\n| TypeArray  |        |      | 位数 | 字节（BYTES_PER_ELEMENT） |\n| ---------- | ------ | ---- | ---- | ------------------------- |\n| Int8Array  | 有符号 | 整数 | 8    | 1                         |\n| Int16Array | 有符号 | 整数 | 16   | 2                         |\n| Int32Array | 有符号 | 整数 | 32   | 4                         |\n\n| TypeArray    |        |        | 位数 | 字节（BYTES_PER_ELEMENT） |\n| ------------ | ------ | ------ | ---- | ------------------------- |\n| Float32Array | 有符号 | 浮点数 | 32   | 4                         |\n| Float64Array | 有符号 | 浮点数 | 64   | 8                         |\n\nUint8ClampedArray 用于 8 位整数，在赋值时便“固定“其值（见下文）。\n\n###### 越界行为\n\n如果我们尝试将越界值写入类型化数组会出现什么情况？<span style=\"color:red\">不会报错</span>。但是多余的位被切除。\n\n例如，我们尝试将 256 放入 `Uint8Array`。超出的部分没有存储，结果是 0。\n\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/8bit-integer-256.svg\">\n\n例如，我们尝试将 257 放入 `Uint8Array`。超出的部分没有存储，结果是 1。\n\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/8bit-integer-257.svg\">\n\n换句话说，该数字对 28 取模的结果被保存了下来。\n\n示例如下：\n\n```javascript\nlet uint8array = new Uint8Array(16);\n\nlet num = 256;\n\nalert(num.toString(2)); // 100000000（二进制表示）\n\nuint8array[0] = 256;\nuint8array[1] = 257;\n\nalert(uint8array[0]); // 0\nalert(uint8array[1]); // 1\n```\n\n`Uint8ClampedArray` 在这方面比较特殊，它的表现不太一样。对于大于 255 的任何数字，它将保存为 255，对于任何负数，它将保存为 0。此行为对于图像处理很有用。\n\n##### [TypedArray 方法](https://zh.javascript.info/arraybuffer-binary-arrays#typedarray-fang-fa)\n\n`TypedArray` 具有常规的 `Array` 方法，但有个明显的例外。\n\n我们可以遍历（iterate），`map`，`slice`，`find` 和 `reduce` 等。\n\n但有几件事我们做不了：\n\n- 没有 `splice` —— 我们无法“删除”一个值，因为类型化数组是缓冲区（buffer）上的视图，并且缓冲区（buffer）是固定的、连续的内存区域。我们所能做的就是分配一个零值。\n- 无 `concat` 方法。\n\n还有两种其他方法（替代）：\n\n- `arr.set(fromArr, [offset])` 从 `offset`（默认为 0）开始，将 `fromArr` 中的所有元素复制到 `arr`。\n- `arr.subarray([begin, end])` 创建一个从 `begin` 到 `end`（不包括）相同类型的新视图。这类似于 `slice` 方法（同样也支持），但不复制任何内容 —— 只是创建一个新视图，以对给定片段的数据进行操作。\n\n有了这些方法，我们可以复制、混合类型化数组，从现有数组创建新数组等。\n\n##### [DataView](https://zh.javascript.info/arraybuffer-binary-arrays#dataview)\n\n[DataView](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/DataView) 是在 `ArrayBuffer` 上的一种特殊的超灵活“未类型化”视图。它允许以任何格式访问任何偏移量（offset）的数据。\n\n- 对于类型化的数组(TypeArray)，构造器决定了其格式。整个数组应该是统一的。第 i 个数字是 `arr[i]`。\n- 通过 `DataView`，我们可以使用 `.getUint8(i)` 或 `.getUint16(i)` 之类的方法访问数据。我们在调用方法时选择格式，而不是在构造的时候。\n\n语法:\n\n`new DataView(buffer, [byteOffset], [byteLength])`\n\n- **`buffer`** —— 底层的 `ArrayBuffer`。与类型化数组不同，`DataView` 不会自行创建缓冲区（buffer）。我们需要事先准备好。\n- **`byteOffset`** —— 视图的起始字节位置（默认为 0）。\n- **`byteLength`** —— 视图的字节长度（默认至 `buffer` 的末尾）。\n\n例如，这里我们从同一个 buffer 中提取不同格式的数字：\n\n```javascript\n// 4 个字节的二进制数组，每个都是最大值 255\nlet buffer = new Uint8Array([255, 255, 255, 255]).buffer;\n\nlet dataView = new DataView(buffer);\n\n// 在偏移量为 0 处获取 8 位数字\nalert(dataView.getUint8(0)); // 255\n\n// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535\nalert(dataView.getUint16(0)); // 65535（最大的 16 位无符号整数）\n\n// 在偏移量为 0 处获取 32 位数字\nalert(dataView.getUint32(0)); // 4294967295（最大的 32 位无符号整数）\n\ndataView.setUint32(0, 0); // 将 4 个字节的数字设为 0，即将所有字节都设为 0\n```\n\n当我们将混合格式的数据存储在同一缓冲区（buffer）中时，`DataView` 非常有用。例如，当我们存储一个成对序列（16 位整数，32 位浮点数）时，用 `DataView` 可以轻松访问它们。\n\n##### 总结\n\n`ArrayBuffer` 是核心对象，是对固定长度的连续内存区域的引用。\n\n几乎任何对 `ArrayBuffer` 的操作，都需要一个视图。\n\n- 它可以是 `TypedArray`\n  - `Uint8Array`，`Uint16Array`，`Uint32Array` —— 用于 8 位、16 位和 32 位无符号整数。\n  - `Uint8ClampedArray` —— 用于 8 位整数，在赋值时便“固定”其值。\n  - `Int8Array`，`Int16Array`，`Int32Array` —— 用于有符号整数（可以为负数）。\n  - `Float32Array`，`Float64Array` —— 用于 32 位和 64 位的有符号浮点数。\n- 或 `DataView` —— 使用方法来指定格式的视图，例如，`getUint8(offset)`。\n\n在大多数情况下，我们直接对类型化数组进行创建和操作，而将 `ArrayBuffer` 作为“通用标识符（common discriminator）”隐藏起来。我们可以通过 `.buffer` 来访问它，并在需要时创建另一个视图。\n\n还有另外两个术语，用于对二进制数据进行操作的方法的描述：\n\n- `ArrayBufferView` 是所有这些视图的总称。\n- `BufferSource` 是 `ArrayBuffer` 或 `ArrayBufferView` 的总称。\n\n我们将在下一章中学习这些术语。`BufferSource` 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— `ArrayBuffer` 或其上的视图。\n\n参考文章\n\n- [现代前端 JavaScript](https://zh.javascript.info/arraybuffer-binary-arrays)\n- [MDN ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n- [MDN DataView](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView)\n- [怎么理解 JavaScript 中的 ArrayBuffer？ - Jim Liu 的回答 - 知乎](https://www.zhihu.com/question/30401979/answer/48421340)\n- [binary family](https://zhuanlan.zhihu.com/p/97768916)\n","slug":"流处理","published":1,"date":"2021-07-03T06:26:20.973Z","updated":"2021-07-04T07:32:43.988Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqoye6ha00039su0bjhk8rwp","content":"<h4 id=\"ArrayBuffer-二进制数组\"><a href=\"#ArrayBuffer-二进制数组\" class=\"headerlink\" title=\"ArrayBuffer,二进制数组\"></a><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays\">ArrayBuffer,二进制数组</a></h4><p>在 Web 开发中，当我们处理文件时（创建，上传，下载），经常会遇到二进制数据。另一个典型的应用场景是图像处理。</p>\n<p>这些都可以通过 JavaScript 进行处理，而且二进制操作性能更高。</p>\n<p>不过，在 JavaScript 中有很多种二进制数据格式，会有点容易混淆。仅举几个例子：</p>\n<ul>\n<li><code>ArrayBuffer</code>，<code>Uint8Array</code>，<code>DataView</code>，<code>Blob</code>，<code>File</code> 及其他。</li>\n</ul>\n<p>与其他语言相比，<strong>JavaScript 中的二进制数据是以非标准方式实现的</strong>。但是，当我们理清楚以后，一切就会变得相当简单了。</p>\n<span id=\"more\"></span>\n\n<h5 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\">ArrayBuffer</a></h5><p><strong>基本的二进制对象是 <code>ArrayBuffer</code> —— 对固定长度的连续内存空间的引用。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">16</span>); <span class=\"comment\">// 创建一个长度为 16 的 buffer</span></span><br><span class=\"line\">alert(buffer.byteLength); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<p>它会分配一个 16 字节的连续内存空间，并用 0 进行预填充。</p>\n<p><code>ArrayBuffer</code> <strong>不是某种东西的数组</strong></p>\n<p>让我们先澄清一个可能的误区。<code>ArrayBuffer</code> 与 <code>Array</code> 没有任何共同之处：</p>\n<ul>\n<li>它的长度是固定的，我们无法增加或减少它的长度。</li>\n<li>它正好占用了内存中的那么多空间。</li>\n<li>要访问单个字节，需要另一个“视图”对象，而不是 <code>buffer[index]</code>。</li>\n</ul>\n<p><code>ArrayBuffer</code> 是一个内存区域。它里面存储了什么？无从判断。只是一个原始的字节序列。</p>\n<p><a href=\"https://www.zhihu.com/question/30401979/answer/48421340\">怎么理解 JavaScript 中的 ArrayBuffer？ - Jim Liu 的回答 - 知乎</a></p>\n<p><strong>如要操作 <code>ArrayBuffer</code>，我们需要使用“视图”对象。</strong></p>\n<p>视图对象本身并不存储任何东西。它是一副“眼镜”，透过它来解释存储在 <code>ArrayBuffer</code> 中的字节。</p>\n<p>例如：</p>\n<ul>\n<li><strong><code>Uint8Array</code></strong> —— 将 <code>ArrayBuffer</code> 中的每个字节视为 0 到 255 之间的单个数字（每个字节是 8 位，因此只能容纳那么多）。这称为 “8 位无符号整数”。</li>\n<li><strong><code>Uint16Array</code></strong> —— 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。</li>\n<li><strong><code>Uint32Array</code></strong> —— 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。</li>\n<li><strong><code>Float64Array</code></strong> —— 将每 8 个字节视为一个 <code>5.0x10-324</code> 到 <code>1.8x10308</code> 之间的浮点数。</li>\n</ul>\n<p>因此，一个 16 字节 <code>ArrayBuffer</code> 中的二进制数据可以解释为 16 个“小数字”，或 8 个更大的数字（每个数字 2 个字节），或 4 个更大的数字（每个数字 4 个字节），或 2 个高精度的浮点数（每个数字 8 个字节）。</p>\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/arraybuffer-views.svg\">\n\n<p><code>ArrayBuffer</code> 是核心对象，是所有的基础，是原始的二进制数据。</p>\n<p>但是，如果我们要写入值或遍历它，基本上几乎所有操作 —— 我们必须使用视图（view），例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">16</span>); <span class=\"comment\">// 创建一个长度为 16 的 buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> view = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint32Array</span>(buffer); <span class=\"comment\">// 将 buffer 视为一个 32 位整数的序列</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"built_in\">Uint32Array</span>.BYTES_PER_ELEMENT); <span class=\"comment\">// 每个整数 4 个字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(view.length); <span class=\"comment\">// 4，它存储了 4 个整数</span></span><br><span class=\"line\">alert(view.byteLength); <span class=\"comment\">// 16，字节中的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 让我们写入一个值</span></span><br><span class=\"line\">view[<span class=\"number\">0</span>] = <span class=\"number\">123456</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> view) &#123;</span><br><span class=\"line\">  alert(num); <span class=\"comment\">// 123456，然后 0，0，0（一共 4 个值）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"TypedArray-视图\"><a href=\"#TypedArray-视图\" class=\"headerlink\" title=\"TypedArray 视图\"></a><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays#typedarray\">TypedArray 视图</a></h5><p>所有这些视图（<code>Uint8Array</code>，<code>Uint32Array</code> 等）的通用术语是 <a href=\"https://tc39.github.io/ecma262/#sec-typedarray-objects\">TypedArray</a>。它们都享有同一组方法和属性。</p>\n<p>请注意，没有名为 <code>TypedArray</code> 的构造器，它只是表示 <code>ArrayBuffer</code> 上的视图之一的通用总称术语：<code>Int8Array</code>，<code>Uint8Array</code> 及其他，很快就会有完整列表。</p>\n<p>当你看到 <code>new TypedArray</code> 之类的内容时，它表示 <code>new Int8Array</code>、<code>new Uint8Array</code> 及其他中之一。</p>\n<p>类型化数组的行为类似于常规数组：具有索引，并且是可迭代的。</p>\n<p>一个类型化数组的构造器（无论是 <code>Int8Array</code> 或 <code>Float64Array</code>，都无关紧要），其行为各不相同，并且取决于参数类型。</p>\n<p>参数有 5 种变体：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> TypedArray(buffer, [byteOffset], [length]);</span><br><span class=\"line\"><span class=\"keyword\">new</span> TypedArray(object);</span><br><span class=\"line\"><span class=\"keyword\">new</span> TypedArray(typedArray);</span><br><span class=\"line\"><span class=\"keyword\">new</span> TypedArray(length);</span><br><span class=\"line\"><span class=\"keyword\">new</span> TypedArray();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>如果给定的是 <code>ArrayBuffer</code> 参数，则会在其上创建视图。我们已经用过该语法了。</p>\n<p>可选，我们可以给定起始位置 <code>byteOffset</code>（默认为 0）以及 <code>length</code>（默认至 buffer 的末尾），这样视图将仅涵盖 <code>buffer</code> 的一部分。</p>\n</li>\n<li><p>如果给定的是 <code>Array</code>，或任何类数组对象，则会创建一个相同长度的类型化数组，并复制其内容。</p>\n<p>我们可以使用它来预填充数组的数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">alert(arr.length); <span class=\"comment\">// 4，创建了相同长度的二进制数组</span></span><br><span class=\"line\">alert(arr[<span class=\"number\">1</span>]); <span class=\"comment\">// 1，用给定值填充了 4 个字节（无符号 8 位整数）</span></span><br></pre></td></tr></table></figure></li>\n<li><p>如果给定的是另一个 <code>TypedArray</code>，也是如此：创建一个相同长度的类型化数组，并复制其内容。如果需要的话，数据在此过程中会被转换为新的类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr16 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>([<span class=\"number\">1</span>, <span class=\"number\">1000</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr8 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(arr16);</span><br><span class=\"line\">alert(arr8[<span class=\"number\">0</span>]); <span class=\"comment\">// 1</span></span><br><span class=\"line\">alert(arr8[<span class=\"number\">1</span>]); <span class=\"comment\">// 232，试图复制 1000，但无法将 1000 放进 8 位字节中（详述见下文）。</span></span><br></pre></td></tr></table></figure>\n\n<p>4.对于数字参数 <code>length</code> —— 创建类型化数组以包含这么多元素。它的字节长度将是 <code>length</code> 乘以单个 <code>TypedArray.BYTES_PER_ELEMENT</code> 中的字节数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(<span class=\"number\">4</span>); <span class=\"comment\">// 为 4 个整数创建类型化数组</span></span><br><span class=\"line\">alert(<span class=\"built_in\">Uint16Array</span>.BYTES_PER_ELEMENT); <span class=\"comment\">// 每个整数 2 个字节</span></span><br><span class=\"line\">alert(arr.byteLength); <span class=\"comment\">// 8（字节中的大小）</span></span><br></pre></td></tr></table></figure>\n\n<p>5.不带参数的情况下，创建长度为零的类型化数组。</p>\n</li>\n</ol>\n<hr/>\n\n<p>我们可以直接创建一个 <code>TypedArray</code>，而无需提及 <code>ArrayBuffer</code>。但是，视图离不开底层的 <code>ArrayBuffer</code>，因此，除第一种情况（已提供 <code>ArrayBuffer</code>）外，其他所有情况都会自动创建 <code>ArrayBuffer</code>。</p>\n<p>如要访问 <code>ArrayBuffer</code>，可以用以下属性：</p>\n<ul>\n<li><code>arr.buffer</code> —— 引用 <code>ArrayBuffer</code>。</li>\n<li><code>arr.byteLength</code> —— <code>ArrayBuffer</code> 的长度。</li>\n</ul>\n<p>因此，我们总是可以从一个视图转到另一个视图:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr8 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同一数据的另一个视图</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr16 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(arr8.buffer);</span><br></pre></td></tr></table></figure>\n\n<p>下面是类型化数组的列表：</p>\n<table>\n<thead>\n<tr>\n<th>TypeArray</th>\n<th></th>\n<th></th>\n<th>位数</th>\n<th>字节（BYTES_PER_ELEMENT）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Uint8Array</td>\n<td>无符号</td>\n<td>整数</td>\n<td>8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Uint16Array</td>\n<td>无符号</td>\n<td>整数</td>\n<td>16</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Uint32Array</td>\n<td>无符号</td>\n<td>整数</td>\n<td>32</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>TypeArray</th>\n<th></th>\n<th></th>\n<th>位数</th>\n<th>字节（BYTES_PER_ELEMENT）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Int8Array</td>\n<td>有符号</td>\n<td>整数</td>\n<td>8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Int16Array</td>\n<td>有符号</td>\n<td>整数</td>\n<td>16</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Int32Array</td>\n<td>有符号</td>\n<td>整数</td>\n<td>32</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>TypeArray</th>\n<th></th>\n<th></th>\n<th>位数</th>\n<th>字节（BYTES_PER_ELEMENT）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Float32Array</td>\n<td>有符号</td>\n<td>浮点数</td>\n<td>32</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Float64Array</td>\n<td>有符号</td>\n<td>浮点数</td>\n<td>64</td>\n<td>8</td>\n</tr>\n</tbody></table>\n<p>Uint8ClampedArray 用于 8 位整数，在赋值时便“固定“其值（见下文）。</p>\n<h6 id=\"越界行为\"><a href=\"#越界行为\" class=\"headerlink\" title=\"越界行为\"></a>越界行为</h6><p>如果我们尝试将越界值写入类型化数组会出现什么情况？<span style=\"color:red\">不会报错</span>。但是多余的位被切除。</p>\n<p>例如，我们尝试将 256 放入 <code>Uint8Array</code>。超出的部分没有存储，结果是 0。</p>\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/8bit-integer-256.svg\">\n\n<p>例如，我们尝试将 257 放入 <code>Uint8Array</code>。超出的部分没有存储，结果是 1。</p>\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/8bit-integer-257.svg\">\n\n<p>换句话说，该数字对 28 取模的结果被保存了下来。</p>\n<p>示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uint8array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"number\">256</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(num.toString(<span class=\"number\">2</span>)); <span class=\"comment\">// 100000000（二进制表示）</span></span><br><span class=\"line\"></span><br><span class=\"line\">uint8array[<span class=\"number\">0</span>] = <span class=\"number\">256</span>;</span><br><span class=\"line\">uint8array[<span class=\"number\">1</span>] = <span class=\"number\">257</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(uint8array[<span class=\"number\">0</span>]); <span class=\"comment\">// 0</span></span><br><span class=\"line\">alert(uint8array[<span class=\"number\">1</span>]); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Uint8ClampedArray</code> 在这方面比较特殊，它的表现不太一样。对于大于 255 的任何数字，它将保存为 255，对于任何负数，它将保存为 0。此行为对于图像处理很有用。</p>\n<h5 id=\"TypedArray-方法\"><a href=\"#TypedArray-方法\" class=\"headerlink\" title=\"TypedArray 方法\"></a><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays#typedarray-fang-fa\">TypedArray 方法</a></h5><p><code>TypedArray</code> 具有常规的 <code>Array</code> 方法，但有个明显的例外。</p>\n<p>我们可以遍历（iterate），<code>map</code>，<code>slice</code>，<code>find</code> 和 <code>reduce</code> 等。</p>\n<p>但有几件事我们做不了：</p>\n<ul>\n<li>没有 <code>splice</code> —— 我们无法“删除”一个值，因为类型化数组是缓冲区（buffer）上的视图，并且缓冲区（buffer）是固定的、连续的内存区域。我们所能做的就是分配一个零值。</li>\n<li>无 <code>concat</code> 方法。</li>\n</ul>\n<p>还有两种其他方法（替代）：</p>\n<ul>\n<li><code>arr.set(fromArr, [offset])</code> 从 <code>offset</code>（默认为 0）开始，将 <code>fromArr</code> 中的所有元素复制到 <code>arr</code>。</li>\n<li><code>arr.subarray([begin, end])</code> 创建一个从 <code>begin</code> 到 <code>end</code>（不包括）相同类型的新视图。这类似于 <code>slice</code> 方法（同样也支持），但不复制任何内容 —— 只是创建一个新视图，以对给定片段的数据进行操作。</li>\n</ul>\n<p>有了这些方法，我们可以复制、混合类型化数组，从现有数组创建新数组等。</p>\n<h5 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays#dataview\">DataView</a></h5><p><a href=\"https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/DataView\">DataView</a> 是在 <code>ArrayBuffer</code> 上的一种特殊的超灵活“未类型化”视图。它允许以任何格式访问任何偏移量（offset）的数据。</p>\n<ul>\n<li>对于类型化的数组(TypeArray)，构造器决定了其格式。整个数组应该是统一的。第 i 个数字是 <code>arr[i]</code>。</li>\n<li>通过 <code>DataView</code>，我们可以使用 <code>.getUint8(i)</code> 或 <code>.getUint16(i)</code> 之类的方法访问数据。我们在调用方法时选择格式，而不是在构造的时候。</li>\n</ul>\n<p>语法:</p>\n<p><code>new DataView(buffer, [byteOffset], [byteLength])</code></p>\n<ul>\n<li><strong><code>buffer</code></strong> —— 底层的 <code>ArrayBuffer</code>。与类型化数组不同，<code>DataView</code> 不会自行创建缓冲区（buffer）。我们需要事先准备好。</li>\n<li><strong><code>byteOffset</code></strong> —— 视图的起始字节位置（默认为 0）。</li>\n<li><strong><code>byteLength</code></strong> —— 视图的字节长度（默认至 <code>buffer</code> 的末尾）。</li>\n</ul>\n<p>例如，这里我们从同一个 buffer 中提取不同格式的数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4 个字节的二进制数组，每个都是最大值 255</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>]).buffer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dataView = <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在偏移量为 0 处获取 8 位数字</span></span><br><span class=\"line\">alert(dataView.getUint8(<span class=\"number\">0</span>)); <span class=\"comment\">// 255</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535</span></span><br><span class=\"line\">alert(dataView.getUint16(<span class=\"number\">0</span>)); <span class=\"comment\">// 65535（最大的 16 位无符号整数）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在偏移量为 0 处获取 32 位数字</span></span><br><span class=\"line\">alert(dataView.getUint32(<span class=\"number\">0</span>)); <span class=\"comment\">// 4294967295（最大的 32 位无符号整数）</span></span><br><span class=\"line\"></span><br><span class=\"line\">dataView.setUint32(<span class=\"number\">0</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 将 4 个字节的数字设为 0，即将所有字节都设为 0</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们将混合格式的数据存储在同一缓冲区（buffer）中时，<code>DataView</code> 非常有用。例如，当我们存储一个成对序列（16 位整数，32 位浮点数）时，用 <code>DataView</code> 可以轻松访问它们。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p><code>ArrayBuffer</code> 是核心对象，是对固定长度的连续内存区域的引用。</p>\n<p>几乎任何对 <code>ArrayBuffer</code> 的操作，都需要一个视图。</p>\n<ul>\n<li>它可以是 <code>TypedArray</code><ul>\n<li><code>Uint8Array</code>，<code>Uint16Array</code>，<code>Uint32Array</code> —— 用于 8 位、16 位和 32 位无符号整数。</li>\n<li><code>Uint8ClampedArray</code> —— 用于 8 位整数，在赋值时便“固定”其值。</li>\n<li><code>Int8Array</code>，<code>Int16Array</code>，<code>Int32Array</code> —— 用于有符号整数（可以为负数）。</li>\n<li><code>Float32Array</code>，<code>Float64Array</code> —— 用于 32 位和 64 位的有符号浮点数。</li>\n</ul>\n</li>\n<li>或 <code>DataView</code> —— 使用方法来指定格式的视图，例如，<code>getUint8(offset)</code>。</li>\n</ul>\n<p>在大多数情况下，我们直接对类型化数组进行创建和操作，而将 <code>ArrayBuffer</code> 作为“通用标识符（common discriminator）”隐藏起来。我们可以通过 <code>.buffer</code> 来访问它，并在需要时创建另一个视图。</p>\n<p>还有另外两个术语，用于对二进制数据进行操作的方法的描述：</p>\n<ul>\n<li><code>ArrayBufferView</code> 是所有这些视图的总称。</li>\n<li><code>BufferSource</code> 是 <code>ArrayBuffer</code> 或 <code>ArrayBufferView</code> 的总称。</li>\n</ul>\n<p>我们将在下一章中学习这些术语。<code>BufferSource</code> 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— <code>ArrayBuffer</code> 或其上的视图。</p>\n<p>参考文章</p>\n<ul>\n<li><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays\">现代前端 JavaScript</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\">MDN ArrayBuffer</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView\">MDN DataView</a></li>\n<li><a href=\"https://www.zhihu.com/question/30401979/answer/48421340\">怎么理解 JavaScript 中的 ArrayBuffer？ - Jim Liu 的回答 - 知乎</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/97768916\">binary family</a></li>\n</ul>\n","site":{"data":{}},"length":5607,"excerpt":"<h4 id=\"ArrayBuffer-二进制数组\"><a href=\"#ArrayBuffer-二进制数组\" class=\"headerlink\" title=\"ArrayBuffer,二进制数组\"></a><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays\">ArrayBuffer,二进制数组</a></h4><p>在 Web 开发中，当我们处理文件时（创建，上传，下载），经常会遇到二进制数据。另一个典型的应用场景是图像处理。</p>\n<p>这些都可以通过 JavaScript 进行处理，而且二进制操作性能更高。</p>\n<p>不过，在 JavaScript 中有很多种二进制数据格式，会有点容易混淆。仅举几个例子：</p>\n<ul>\n<li><code>ArrayBuffer</code>，<code>Uint8Array</code>，<code>DataView</code>，<code>Blob</code>，<code>File</code> 及其他。</li>\n</ul>\n<p>与其他语言相比，<strong>JavaScript 中的二进制数据是以非标准方式实现的</strong>。但是，当我们理清楚以后，一切就会变得相当简单了。</p>","more":"<h5 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\">ArrayBuffer</a></h5><p><strong>基本的二进制对象是 <code>ArrayBuffer</code> —— 对固定长度的连续内存空间的引用。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">16</span>); <span class=\"comment\">// 创建一个长度为 16 的 buffer</span></span><br><span class=\"line\">alert(buffer.byteLength); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<p>它会分配一个 16 字节的连续内存空间，并用 0 进行预填充。</p>\n<p><code>ArrayBuffer</code> <strong>不是某种东西的数组</strong></p>\n<p>让我们先澄清一个可能的误区。<code>ArrayBuffer</code> 与 <code>Array</code> 没有任何共同之处：</p>\n<ul>\n<li>它的长度是固定的，我们无法增加或减少它的长度。</li>\n<li>它正好占用了内存中的那么多空间。</li>\n<li>要访问单个字节，需要另一个“视图”对象，而不是 <code>buffer[index]</code>。</li>\n</ul>\n<p><code>ArrayBuffer</code> 是一个内存区域。它里面存储了什么？无从判断。只是一个原始的字节序列。</p>\n<p><a href=\"https://www.zhihu.com/question/30401979/answer/48421340\">怎么理解 JavaScript 中的 ArrayBuffer？ - Jim Liu 的回答 - 知乎</a></p>\n<p><strong>如要操作 <code>ArrayBuffer</code>，我们需要使用“视图”对象。</strong></p>\n<p>视图对象本身并不存储任何东西。它是一副“眼镜”，透过它来解释存储在 <code>ArrayBuffer</code> 中的字节。</p>\n<p>例如：</p>\n<ul>\n<li><strong><code>Uint8Array</code></strong> —— 将 <code>ArrayBuffer</code> 中的每个字节视为 0 到 255 之间的单个数字（每个字节是 8 位，因此只能容纳那么多）。这称为 “8 位无符号整数”。</li>\n<li><strong><code>Uint16Array</code></strong> —— 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。</li>\n<li><strong><code>Uint32Array</code></strong> —— 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。</li>\n<li><strong><code>Float64Array</code></strong> —— 将每 8 个字节视为一个 <code>5.0x10-324</code> 到 <code>1.8x10308</code> 之间的浮点数。</li>\n</ul>\n<p>因此，一个 16 字节 <code>ArrayBuffer</code> 中的二进制数据可以解释为 16 个“小数字”，或 8 个更大的数字（每个数字 2 个字节），或 4 个更大的数字（每个数字 4 个字节），或 2 个高精度的浮点数（每个数字 8 个字节）。</p>\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/arraybuffer-views.svg\">\n\n<p><code>ArrayBuffer</code> 是核心对象，是所有的基础，是原始的二进制数据。</p>\n<p>但是，如果我们要写入值或遍历它，基本上几乎所有操作 —— 我们必须使用视图（view），例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">16</span>); <span class=\"comment\">// 创建一个长度为 16 的 buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> view = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint32Array</span>(buffer); <span class=\"comment\">// 将 buffer 视为一个 32 位整数的序列</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"built_in\">Uint32Array</span>.BYTES_PER_ELEMENT); <span class=\"comment\">// 每个整数 4 个字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(view.length); <span class=\"comment\">// 4，它存储了 4 个整数</span></span><br><span class=\"line\">alert(view.byteLength); <span class=\"comment\">// 16，字节中的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 让我们写入一个值</span></span><br><span class=\"line\">view[<span class=\"number\">0</span>] = <span class=\"number\">123456</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> view) &#123;</span><br><span class=\"line\">  alert(num); <span class=\"comment\">// 123456，然后 0，0，0（一共 4 个值）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"TypedArray-视图\"><a href=\"#TypedArray-视图\" class=\"headerlink\" title=\"TypedArray 视图\"></a><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays#typedarray\">TypedArray 视图</a></h5><p>所有这些视图（<code>Uint8Array</code>，<code>Uint32Array</code> 等）的通用术语是 <a href=\"https://tc39.github.io/ecma262/#sec-typedarray-objects\">TypedArray</a>。它们都享有同一组方法和属性。</p>\n<p>请注意，没有名为 <code>TypedArray</code> 的构造器，它只是表示 <code>ArrayBuffer</code> 上的视图之一的通用总称术语：<code>Int8Array</code>，<code>Uint8Array</code> 及其他，很快就会有完整列表。</p>\n<p>当你看到 <code>new TypedArray</code> 之类的内容时，它表示 <code>new Int8Array</code>、<code>new Uint8Array</code> 及其他中之一。</p>\n<p>类型化数组的行为类似于常规数组：具有索引，并且是可迭代的。</p>\n<p>一个类型化数组的构造器（无论是 <code>Int8Array</code> 或 <code>Float64Array</code>，都无关紧要），其行为各不相同，并且取决于参数类型。</p>\n<p>参数有 5 种变体：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> TypedArray(buffer, [byteOffset], [length]);</span><br><span class=\"line\"><span class=\"keyword\">new</span> TypedArray(object);</span><br><span class=\"line\"><span class=\"keyword\">new</span> TypedArray(typedArray);</span><br><span class=\"line\"><span class=\"keyword\">new</span> TypedArray(length);</span><br><span class=\"line\"><span class=\"keyword\">new</span> TypedArray();</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>如果给定的是 <code>ArrayBuffer</code> 参数，则会在其上创建视图。我们已经用过该语法了。</p>\n<p>可选，我们可以给定起始位置 <code>byteOffset</code>（默认为 0）以及 <code>length</code>（默认至 buffer 的末尾），这样视图将仅涵盖 <code>buffer</code> 的一部分。</p>\n</li>\n<li><p>如果给定的是 <code>Array</code>，或任何类数组对象，则会创建一个相同长度的类型化数组，并复制其内容。</p>\n<p>我们可以使用它来预填充数组的数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">alert(arr.length); <span class=\"comment\">// 4，创建了相同长度的二进制数组</span></span><br><span class=\"line\">alert(arr[<span class=\"number\">1</span>]); <span class=\"comment\">// 1，用给定值填充了 4 个字节（无符号 8 位整数）</span></span><br></pre></td></tr></table></figure></li>\n<li><p>如果给定的是另一个 <code>TypedArray</code>，也是如此：创建一个相同长度的类型化数组，并复制其内容。如果需要的话，数据在此过程中会被转换为新的类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr16 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>([<span class=\"number\">1</span>, <span class=\"number\">1000</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr8 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(arr16);</span><br><span class=\"line\">alert(arr8[<span class=\"number\">0</span>]); <span class=\"comment\">// 1</span></span><br><span class=\"line\">alert(arr8[<span class=\"number\">1</span>]); <span class=\"comment\">// 232，试图复制 1000，但无法将 1000 放进 8 位字节中（详述见下文）。</span></span><br></pre></td></tr></table></figure>\n\n<p>4.对于数字参数 <code>length</code> —— 创建类型化数组以包含这么多元素。它的字节长度将是 <code>length</code> 乘以单个 <code>TypedArray.BYTES_PER_ELEMENT</code> 中的字节数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(<span class=\"number\">4</span>); <span class=\"comment\">// 为 4 个整数创建类型化数组</span></span><br><span class=\"line\">alert(<span class=\"built_in\">Uint16Array</span>.BYTES_PER_ELEMENT); <span class=\"comment\">// 每个整数 2 个字节</span></span><br><span class=\"line\">alert(arr.byteLength); <span class=\"comment\">// 8（字节中的大小）</span></span><br></pre></td></tr></table></figure>\n\n<p>5.不带参数的情况下，创建长度为零的类型化数组。</p>\n</li>\n</ol>\n<hr/>\n\n<p>我们可以直接创建一个 <code>TypedArray</code>，而无需提及 <code>ArrayBuffer</code>。但是，视图离不开底层的 <code>ArrayBuffer</code>，因此，除第一种情况（已提供 <code>ArrayBuffer</code>）外，其他所有情况都会自动创建 <code>ArrayBuffer</code>。</p>\n<p>如要访问 <code>ArrayBuffer</code>，可以用以下属性：</p>\n<ul>\n<li><code>arr.buffer</code> —— 引用 <code>ArrayBuffer</code>。</li>\n<li><code>arr.byteLength</code> —— <code>ArrayBuffer</code> 的长度。</li>\n</ul>\n<p>因此，我们总是可以从一个视图转到另一个视图:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr8 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同一数据的另一个视图</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr16 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(arr8.buffer);</span><br></pre></td></tr></table></figure>\n\n<p>下面是类型化数组的列表：</p>\n<table>\n<thead>\n<tr>\n<th>TypeArray</th>\n<th></th>\n<th></th>\n<th>位数</th>\n<th>字节（BYTES_PER_ELEMENT）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Uint8Array</td>\n<td>无符号</td>\n<td>整数</td>\n<td>8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Uint16Array</td>\n<td>无符号</td>\n<td>整数</td>\n<td>16</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Uint32Array</td>\n<td>无符号</td>\n<td>整数</td>\n<td>32</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>TypeArray</th>\n<th></th>\n<th></th>\n<th>位数</th>\n<th>字节（BYTES_PER_ELEMENT）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Int8Array</td>\n<td>有符号</td>\n<td>整数</td>\n<td>8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Int16Array</td>\n<td>有符号</td>\n<td>整数</td>\n<td>16</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Int32Array</td>\n<td>有符号</td>\n<td>整数</td>\n<td>32</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>TypeArray</th>\n<th></th>\n<th></th>\n<th>位数</th>\n<th>字节（BYTES_PER_ELEMENT）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Float32Array</td>\n<td>有符号</td>\n<td>浮点数</td>\n<td>32</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Float64Array</td>\n<td>有符号</td>\n<td>浮点数</td>\n<td>64</td>\n<td>8</td>\n</tr>\n</tbody></table>\n<p>Uint8ClampedArray 用于 8 位整数，在赋值时便“固定“其值（见下文）。</p>\n<h6 id=\"越界行为\"><a href=\"#越界行为\" class=\"headerlink\" title=\"越界行为\"></a>越界行为</h6><p>如果我们尝试将越界值写入类型化数组会出现什么情况？<span style=\"color:red\">不会报错</span>。但是多余的位被切除。</p>\n<p>例如，我们尝试将 256 放入 <code>Uint8Array</code>。超出的部分没有存储，结果是 0。</p>\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/8bit-integer-256.svg\">\n\n<p>例如，我们尝试将 257 放入 <code>Uint8Array</code>。超出的部分没有存储，结果是 1。</p>\n<img src=\"https://zh.javascript.info/article/arraybuffer-binary-arrays/8bit-integer-257.svg\">\n\n<p>换句话说，该数字对 28 取模的结果被保存了下来。</p>\n<p>示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uint8array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"number\">256</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(num.toString(<span class=\"number\">2</span>)); <span class=\"comment\">// 100000000（二进制表示）</span></span><br><span class=\"line\"></span><br><span class=\"line\">uint8array[<span class=\"number\">0</span>] = <span class=\"number\">256</span>;</span><br><span class=\"line\">uint8array[<span class=\"number\">1</span>] = <span class=\"number\">257</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(uint8array[<span class=\"number\">0</span>]); <span class=\"comment\">// 0</span></span><br><span class=\"line\">alert(uint8array[<span class=\"number\">1</span>]); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Uint8ClampedArray</code> 在这方面比较特殊，它的表现不太一样。对于大于 255 的任何数字，它将保存为 255，对于任何负数，它将保存为 0。此行为对于图像处理很有用。</p>\n<h5 id=\"TypedArray-方法\"><a href=\"#TypedArray-方法\" class=\"headerlink\" title=\"TypedArray 方法\"></a><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays#typedarray-fang-fa\">TypedArray 方法</a></h5><p><code>TypedArray</code> 具有常规的 <code>Array</code> 方法，但有个明显的例外。</p>\n<p>我们可以遍历（iterate），<code>map</code>，<code>slice</code>，<code>find</code> 和 <code>reduce</code> 等。</p>\n<p>但有几件事我们做不了：</p>\n<ul>\n<li>没有 <code>splice</code> —— 我们无法“删除”一个值，因为类型化数组是缓冲区（buffer）上的视图，并且缓冲区（buffer）是固定的、连续的内存区域。我们所能做的就是分配一个零值。</li>\n<li>无 <code>concat</code> 方法。</li>\n</ul>\n<p>还有两种其他方法（替代）：</p>\n<ul>\n<li><code>arr.set(fromArr, [offset])</code> 从 <code>offset</code>（默认为 0）开始，将 <code>fromArr</code> 中的所有元素复制到 <code>arr</code>。</li>\n<li><code>arr.subarray([begin, end])</code> 创建一个从 <code>begin</code> 到 <code>end</code>（不包括）相同类型的新视图。这类似于 <code>slice</code> 方法（同样也支持），但不复制任何内容 —— 只是创建一个新视图，以对给定片段的数据进行操作。</li>\n</ul>\n<p>有了这些方法，我们可以复制、混合类型化数组，从现有数组创建新数组等。</p>\n<h5 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays#dataview\">DataView</a></h5><p><a href=\"https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/DataView\">DataView</a> 是在 <code>ArrayBuffer</code> 上的一种特殊的超灵活“未类型化”视图。它允许以任何格式访问任何偏移量（offset）的数据。</p>\n<ul>\n<li>对于类型化的数组(TypeArray)，构造器决定了其格式。整个数组应该是统一的。第 i 个数字是 <code>arr[i]</code>。</li>\n<li>通过 <code>DataView</code>，我们可以使用 <code>.getUint8(i)</code> 或 <code>.getUint16(i)</code> 之类的方法访问数据。我们在调用方法时选择格式，而不是在构造的时候。</li>\n</ul>\n<p>语法:</p>\n<p><code>new DataView(buffer, [byteOffset], [byteLength])</code></p>\n<ul>\n<li><strong><code>buffer</code></strong> —— 底层的 <code>ArrayBuffer</code>。与类型化数组不同，<code>DataView</code> 不会自行创建缓冲区（buffer）。我们需要事先准备好。</li>\n<li><strong><code>byteOffset</code></strong> —— 视图的起始字节位置（默认为 0）。</li>\n<li><strong><code>byteLength</code></strong> —— 视图的字节长度（默认至 <code>buffer</code> 的末尾）。</li>\n</ul>\n<p>例如，这里我们从同一个 buffer 中提取不同格式的数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4 个字节的二进制数组，每个都是最大值 255</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>]).buffer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dataView = <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在偏移量为 0 处获取 8 位数字</span></span><br><span class=\"line\">alert(dataView.getUint8(<span class=\"number\">0</span>)); <span class=\"comment\">// 255</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535</span></span><br><span class=\"line\">alert(dataView.getUint16(<span class=\"number\">0</span>)); <span class=\"comment\">// 65535（最大的 16 位无符号整数）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在偏移量为 0 处获取 32 位数字</span></span><br><span class=\"line\">alert(dataView.getUint32(<span class=\"number\">0</span>)); <span class=\"comment\">// 4294967295（最大的 32 位无符号整数）</span></span><br><span class=\"line\"></span><br><span class=\"line\">dataView.setUint32(<span class=\"number\">0</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 将 4 个字节的数字设为 0，即将所有字节都设为 0</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们将混合格式的数据存储在同一缓冲区（buffer）中时，<code>DataView</code> 非常有用。例如，当我们存储一个成对序列（16 位整数，32 位浮点数）时，用 <code>DataView</code> 可以轻松访问它们。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p><code>ArrayBuffer</code> 是核心对象，是对固定长度的连续内存区域的引用。</p>\n<p>几乎任何对 <code>ArrayBuffer</code> 的操作，都需要一个视图。</p>\n<ul>\n<li>它可以是 <code>TypedArray</code><ul>\n<li><code>Uint8Array</code>，<code>Uint16Array</code>，<code>Uint32Array</code> —— 用于 8 位、16 位和 32 位无符号整数。</li>\n<li><code>Uint8ClampedArray</code> —— 用于 8 位整数，在赋值时便“固定”其值。</li>\n<li><code>Int8Array</code>，<code>Int16Array</code>，<code>Int32Array</code> —— 用于有符号整数（可以为负数）。</li>\n<li><code>Float32Array</code>，<code>Float64Array</code> —— 用于 32 位和 64 位的有符号浮点数。</li>\n</ul>\n</li>\n<li>或 <code>DataView</code> —— 使用方法来指定格式的视图，例如，<code>getUint8(offset)</code>。</li>\n</ul>\n<p>在大多数情况下，我们直接对类型化数组进行创建和操作，而将 <code>ArrayBuffer</code> 作为“通用标识符（common discriminator）”隐藏起来。我们可以通过 <code>.buffer</code> 来访问它，并在需要时创建另一个视图。</p>\n<p>还有另外两个术语，用于对二进制数据进行操作的方法的描述：</p>\n<ul>\n<li><code>ArrayBufferView</code> 是所有这些视图的总称。</li>\n<li><code>BufferSource</code> 是 <code>ArrayBuffer</code> 或 <code>ArrayBufferView</code> 的总称。</li>\n</ul>\n<p>我们将在下一章中学习这些术语。<code>BufferSource</code> 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— <code>ArrayBuffer</code> 或其上的视图。</p>\n<p>参考文章</p>\n<ul>\n<li><a href=\"https://zh.javascript.info/arraybuffer-binary-arrays\">现代前端 JavaScript</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\">MDN ArrayBuffer</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView\">MDN DataView</a></li>\n<li><a href=\"https://www.zhihu.com/question/30401979/answer/48421340\">怎么理解 JavaScript 中的 ArrayBuffer？ - Jim Liu 的回答 - 知乎</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/97768916\">binary family</a></li>\n</ul>"},{"title":"【浏览器怎么操作二进制】【二】文本的二进制数据编解码","type":"tags","_content":"\n#### TextDecoder 和 TextEncoder\n\n背景知识\n\n- `ArrayBufferView` 是所有视图的总称。\n- `BufferSource` 是 `ArrayBuffer` 或 `ArrayBufferView` 的总称。\n\n本章中学习这些术语。`BufferSource` 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— `ArrayBuffer` 或其上的视图。\n\n<!--more-->\n\n如果二进制数据实际上是一个字符串怎么办？例如，我们收到了一个包含文本数据的文件。\n\n内建的 [TextDecoder](https://encoding.spec.whatwg.org/#interface-textdecoder) 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，能够将值读取到实际的 JavaScript 字符串中。\n\n首先我们需要创建：\n\n```javascript\nlet decoder = new TextDecoder([label], [options]);\n```\n\n- **`label`** —— 编码格式，默认为 `utf-8`，但同时也支持 `big5`，`windows-1251` 等许多其他编码格式。\n- **`options`** —— 可选对象：\n  - **`fatal`** —— 布尔值，如果为 `true` 则为无效（不可解码）字符抛出异常，否则（默认）用字符 `\\uFFFD` 替换无效字符。\n  - **`ignoreBOM`** —— 布尔值，如果为 `true` 则 BOM（可选的字节顺序 unicode 标记），很少需要使用。(这是啥)（MDN 布尔值，是否忽略 BOM（byte order marker）标记。）\n\n……然后解码：\n\n```javascript\nlet str = decoder.decode([input], [options]);\n```\n\n- **`input`** —— 要被解码的 `BufferSource`。\n\n- `options`\n\n  —— 可选对象：\n\n  - **`stream`** —— 对于解码流，为 true，则将传入的数据块（chunk）作为参数重复调用 `decoder`。在这种情况下，多字节的字符可能偶尔会在块与块之间被分割。这个选项告诉 `TextDecoder` 记住“未完成”的字符，并在下一个数据块来的时候进行解码。\n\n  (意思是传入的 BufferSource 是一块一块的)\n\n```javascript\nlet uint8Array = new Uint8Array([72, 101, 108, 108, 111]);\n\nalert(new TextDecoder().decode(uint8Array)); // Hello\n```\n\n```javascript\nlet uint8Array = new Uint8Array([228, 189, 160, 229, 165, 189]);\n\nalert(new TextDecoder().decode(uint8Array)); // 你好\n```\n\n我们可以通过为其创建子数组视图来解码部分缓冲区：\n\n```javascript\nlet uint8Array = new Uint8Array([0, 72, 101, 108, 108, 111, 0]);\n\n// 该字符串位于中间\n// 在不复制任何内容的前提下，创建一个新的视图\nlet binaryString = uint8Array.subarray(1, -1);\n\nalert(new TextDecoder().decode(binaryString)); // Hello\n```\n\n#### [TextEncoder](https://zh.javascript.info/text-decoder#textencoder)\n\n[TextEncoder](https://encoding.spec.whatwg.org/#interface-textencoder) 做相反的事情 —— 将字符串转换为字节。\n\n语法为:\n\n```javascript\nlet encoder = new TextEncoder();\n```\n\n只支持 `utf-8` 编码。\n\n它有两种方法：\n\n- **`encode(str)`** —— 从字符串返回 `Uint8Array`。\n- **`encodeInto(str, destination)`** —— 将 `str` 编码到 `destination` 中，该目标必须为 `Uint8Array`。\n\n```javascript\nlet encoder = new TextEncoder();\n\nlet uint8Array = encoder.encode(\"Hello\");\nalert(uint8Array); // 72,101,108,108,111\n```\n\n#### MDN 例子\n\n```javascript\nconst encoder = new TextEncoder();\nconst array = encoder.encode(\"€\"); // Uint8Array(3) [226, 130, 172]\n\nconst decoder = new TextDecoder();\nconst str = decoder.decode(array); // String \"€\"\n```\n","source":"_posts/流处理2.md","raw":"---\ntitle: 【浏览器怎么操作二进制】【二】文本的二进制数据编解码\ntype: \"tags\"\ntags:\n  - TextDecoder\n  - TextEncoder\n  - decode\n  - encode\n  - 二进制\ncategories: 二进制数据,文件\n---\n\n#### TextDecoder 和 TextEncoder\n\n背景知识\n\n- `ArrayBufferView` 是所有视图的总称。\n- `BufferSource` 是 `ArrayBuffer` 或 `ArrayBufferView` 的总称。\n\n本章中学习这些术语。`BufferSource` 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— `ArrayBuffer` 或其上的视图。\n\n<!--more-->\n\n如果二进制数据实际上是一个字符串怎么办？例如，我们收到了一个包含文本数据的文件。\n\n内建的 [TextDecoder](https://encoding.spec.whatwg.org/#interface-textdecoder) 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，能够将值读取到实际的 JavaScript 字符串中。\n\n首先我们需要创建：\n\n```javascript\nlet decoder = new TextDecoder([label], [options]);\n```\n\n- **`label`** —— 编码格式，默认为 `utf-8`，但同时也支持 `big5`，`windows-1251` 等许多其他编码格式。\n- **`options`** —— 可选对象：\n  - **`fatal`** —— 布尔值，如果为 `true` 则为无效（不可解码）字符抛出异常，否则（默认）用字符 `\\uFFFD` 替换无效字符。\n  - **`ignoreBOM`** —— 布尔值，如果为 `true` 则 BOM（可选的字节顺序 unicode 标记），很少需要使用。(这是啥)（MDN 布尔值，是否忽略 BOM（byte order marker）标记。）\n\n……然后解码：\n\n```javascript\nlet str = decoder.decode([input], [options]);\n```\n\n- **`input`** —— 要被解码的 `BufferSource`。\n\n- `options`\n\n  —— 可选对象：\n\n  - **`stream`** —— 对于解码流，为 true，则将传入的数据块（chunk）作为参数重复调用 `decoder`。在这种情况下，多字节的字符可能偶尔会在块与块之间被分割。这个选项告诉 `TextDecoder` 记住“未完成”的字符，并在下一个数据块来的时候进行解码。\n\n  (意思是传入的 BufferSource 是一块一块的)\n\n```javascript\nlet uint8Array = new Uint8Array([72, 101, 108, 108, 111]);\n\nalert(new TextDecoder().decode(uint8Array)); // Hello\n```\n\n```javascript\nlet uint8Array = new Uint8Array([228, 189, 160, 229, 165, 189]);\n\nalert(new TextDecoder().decode(uint8Array)); // 你好\n```\n\n我们可以通过为其创建子数组视图来解码部分缓冲区：\n\n```javascript\nlet uint8Array = new Uint8Array([0, 72, 101, 108, 108, 111, 0]);\n\n// 该字符串位于中间\n// 在不复制任何内容的前提下，创建一个新的视图\nlet binaryString = uint8Array.subarray(1, -1);\n\nalert(new TextDecoder().decode(binaryString)); // Hello\n```\n\n#### [TextEncoder](https://zh.javascript.info/text-decoder#textencoder)\n\n[TextEncoder](https://encoding.spec.whatwg.org/#interface-textencoder) 做相反的事情 —— 将字符串转换为字节。\n\n语法为:\n\n```javascript\nlet encoder = new TextEncoder();\n```\n\n只支持 `utf-8` 编码。\n\n它有两种方法：\n\n- **`encode(str)`** —— 从字符串返回 `Uint8Array`。\n- **`encodeInto(str, destination)`** —— 将 `str` 编码到 `destination` 中，该目标必须为 `Uint8Array`。\n\n```javascript\nlet encoder = new TextEncoder();\n\nlet uint8Array = encoder.encode(\"Hello\");\nalert(uint8Array); // 72,101,108,108,111\n```\n\n#### MDN 例子\n\n```javascript\nconst encoder = new TextEncoder();\nconst array = encoder.encode(\"€\"); // Uint8Array(3) [226, 130, 172]\n\nconst decoder = new TextDecoder();\nconst str = decoder.decode(array); // String \"€\"\n```\n","slug":"流处理2","published":1,"date":"2021-07-03T12:13:41.442Z","updated":"2021-07-04T07:34:32.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqoye6hd00069su03yf8csmn","content":"<h4 id=\"TextDecoder-和-TextEncoder\"><a href=\"#TextDecoder-和-TextEncoder\" class=\"headerlink\" title=\"TextDecoder 和 TextEncoder\"></a>TextDecoder 和 TextEncoder</h4><p>背景知识</p>\n<ul>\n<li><code>ArrayBufferView</code> 是所有视图的总称。</li>\n<li><code>BufferSource</code> 是 <code>ArrayBuffer</code> 或 <code>ArrayBufferView</code> 的总称。</li>\n</ul>\n<p>本章中学习这些术语。<code>BufferSource</code> 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— <code>ArrayBuffer</code> 或其上的视图。</p>\n<span id=\"more\"></span>\n\n<p>如果二进制数据实际上是一个字符串怎么办？例如，我们收到了一个包含文本数据的文件。</p>\n<p>内建的 <a href=\"https://encoding.spec.whatwg.org/#interface-textdecoder\">TextDecoder</a> 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，能够将值读取到实际的 JavaScript 字符串中。</p>\n<p>首先我们需要创建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decoder = <span class=\"keyword\">new</span> TextDecoder([label], [options]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong><code>label</code></strong> —— 编码格式，默认为 <code>utf-8</code>，但同时也支持 <code>big5</code>，<code>windows-1251</code> 等许多其他编码格式。</li>\n<li><strong><code>options</code></strong> —— 可选对象：<ul>\n<li><strong><code>fatal</code></strong> —— 布尔值，如果为 <code>true</code> 则为无效（不可解码）字符抛出异常，否则（默认）用字符 <code>\\uFFFD</code> 替换无效字符。</li>\n<li><strong><code>ignoreBOM</code></strong> —— 布尔值，如果为 <code>true</code> 则 BOM（可选的字节顺序 unicode 标记），很少需要使用。(这是啥)（MDN 布尔值，是否忽略 BOM（byte order marker）标记。）</li>\n</ul>\n</li>\n</ul>\n<p>……然后解码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = decoder.decode([input], [options]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong><code>input</code></strong> —— 要被解码的 <code>BufferSource</code>。</p>\n</li>\n<li><p><code>options</code></p>\n<p>—— 可选对象：</p>\n<ul>\n<li><strong><code>stream</code></strong> —— 对于解码流，为 true，则将传入的数据块（chunk）作为参数重复调用 <code>decoder</code>。在这种情况下，多字节的字符可能偶尔会在块与块之间被分割。这个选项告诉 <code>TextDecoder</code> 记住“未完成”的字符，并在下一个数据块来的时候进行解码。</li>\n</ul>\n<p>(意思是传入的 BufferSource 是一块一块的)</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"keyword\">new</span> TextDecoder().decode(uint8Array)); <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">228</span>, <span class=\"number\">189</span>, <span class=\"number\">160</span>, <span class=\"number\">229</span>, <span class=\"number\">165</span>, <span class=\"number\">189</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"keyword\">new</span> TextDecoder().decode(uint8Array)); <span class=\"comment\">// 你好</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过为其创建子数组视图来解码部分缓冲区：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">0</span>, <span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>, <span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该字符串位于中间</span></span><br><span class=\"line\"><span class=\"comment\">// 在不复制任何内容的前提下，创建一个新的视图</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryString = uint8Array.subarray(<span class=\"number\">1</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"keyword\">new</span> TextDecoder().decode(binaryString)); <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"TextEncoder\"><a href=\"#TextEncoder\" class=\"headerlink\" title=\"TextEncoder\"></a><a href=\"https://zh.javascript.info/text-decoder#textencoder\">TextEncoder</a></h4><p><a href=\"https://encoding.spec.whatwg.org/#interface-textencoder\">TextEncoder</a> 做相反的事情 —— 将字符串转换为字节。</p>\n<p>语法为:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> encoder = <span class=\"keyword\">new</span> TextEncoder();</span><br></pre></td></tr></table></figure>\n\n<p>只支持 <code>utf-8</code> 编码。</p>\n<p>它有两种方法：</p>\n<ul>\n<li><strong><code>encode(str)</code></strong> —— 从字符串返回 <code>Uint8Array</code>。</li>\n<li><strong><code>encodeInto(str, destination)</code></strong> —— 将 <code>str</code> 编码到 <code>destination</code> 中，该目标必须为 <code>Uint8Array</code>。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> encoder = <span class=\"keyword\">new</span> TextEncoder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uint8Array = encoder.encode(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">alert(uint8Array); <span class=\"comment\">// 72,101,108,108,111</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"MDN-例子\"><a href=\"#MDN-例子\" class=\"headerlink\" title=\"MDN 例子\"></a>MDN 例子</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> encoder = <span class=\"keyword\">new</span> TextEncoder();</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = encoder.encode(<span class=\"string\">&quot;€&quot;</span>); <span class=\"comment\">// Uint8Array(3) [226, 130, 172]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decoder = <span class=\"keyword\">new</span> TextDecoder();</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = decoder.decode(array); <span class=\"comment\">// String &quot;€&quot;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":1708,"excerpt":"<h4 id=\"TextDecoder-和-TextEncoder\"><a href=\"#TextDecoder-和-TextEncoder\" class=\"headerlink\" title=\"TextDecoder 和 TextEncoder\"></a>TextDecoder 和 TextEncoder</h4><p>背景知识</p>\n<ul>\n<li><code>ArrayBufferView</code> 是所有视图的总称。</li>\n<li><code>BufferSource</code> 是 <code>ArrayBuffer</code> 或 <code>ArrayBufferView</code> 的总称。</li>\n</ul>\n<p>本章中学习这些术语。<code>BufferSource</code> 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— <code>ArrayBuffer</code> 或其上的视图。</p>","more":"<p>如果二进制数据实际上是一个字符串怎么办？例如，我们收到了一个包含文本数据的文件。</p>\n<p>内建的 <a href=\"https://encoding.spec.whatwg.org/#interface-textdecoder\">TextDecoder</a> 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，能够将值读取到实际的 JavaScript 字符串中。</p>\n<p>首先我们需要创建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decoder = <span class=\"keyword\">new</span> TextDecoder([label], [options]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong><code>label</code></strong> —— 编码格式，默认为 <code>utf-8</code>，但同时也支持 <code>big5</code>，<code>windows-1251</code> 等许多其他编码格式。</li>\n<li><strong><code>options</code></strong> —— 可选对象：<ul>\n<li><strong><code>fatal</code></strong> —— 布尔值，如果为 <code>true</code> 则为无效（不可解码）字符抛出异常，否则（默认）用字符 <code>\\uFFFD</code> 替换无效字符。</li>\n<li><strong><code>ignoreBOM</code></strong> —— 布尔值，如果为 <code>true</code> 则 BOM（可选的字节顺序 unicode 标记），很少需要使用。(这是啥)（MDN 布尔值，是否忽略 BOM（byte order marker）标记。）</li>\n</ul>\n</li>\n</ul>\n<p>……然后解码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = decoder.decode([input], [options]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong><code>input</code></strong> —— 要被解码的 <code>BufferSource</code>。</p>\n</li>\n<li><p><code>options</code></p>\n<p>—— 可选对象：</p>\n<ul>\n<li><strong><code>stream</code></strong> —— 对于解码流，为 true，则将传入的数据块（chunk）作为参数重复调用 <code>decoder</code>。在这种情况下，多字节的字符可能偶尔会在块与块之间被分割。这个选项告诉 <code>TextDecoder</code> 记住“未完成”的字符，并在下一个数据块来的时候进行解码。</li>\n</ul>\n<p>(意思是传入的 BufferSource 是一块一块的)</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"keyword\">new</span> TextDecoder().decode(uint8Array)); <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">228</span>, <span class=\"number\">189</span>, <span class=\"number\">160</span>, <span class=\"number\">229</span>, <span class=\"number\">165</span>, <span class=\"number\">189</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"keyword\">new</span> TextDecoder().decode(uint8Array)); <span class=\"comment\">// 你好</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过为其创建子数组视图来解码部分缓冲区：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uint8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">0</span>, <span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>, <span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该字符串位于中间</span></span><br><span class=\"line\"><span class=\"comment\">// 在不复制任何内容的前提下，创建一个新的视图</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryString = uint8Array.subarray(<span class=\"number\">1</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(<span class=\"keyword\">new</span> TextDecoder().decode(binaryString)); <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"TextEncoder\"><a href=\"#TextEncoder\" class=\"headerlink\" title=\"TextEncoder\"></a><a href=\"https://zh.javascript.info/text-decoder#textencoder\">TextEncoder</a></h4><p><a href=\"https://encoding.spec.whatwg.org/#interface-textencoder\">TextEncoder</a> 做相反的事情 —— 将字符串转换为字节。</p>\n<p>语法为:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> encoder = <span class=\"keyword\">new</span> TextEncoder();</span><br></pre></td></tr></table></figure>\n\n<p>只支持 <code>utf-8</code> 编码。</p>\n<p>它有两种方法：</p>\n<ul>\n<li><strong><code>encode(str)</code></strong> —— 从字符串返回 <code>Uint8Array</code>。</li>\n<li><strong><code>encodeInto(str, destination)</code></strong> —— 将 <code>str</code> 编码到 <code>destination</code> 中，该目标必须为 <code>Uint8Array</code>。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> encoder = <span class=\"keyword\">new</span> TextEncoder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uint8Array = encoder.encode(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">alert(uint8Array); <span class=\"comment\">// 72,101,108,108,111</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"MDN-例子\"><a href=\"#MDN-例子\" class=\"headerlink\" title=\"MDN 例子\"></a>MDN 例子</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> encoder = <span class=\"keyword\">new</span> TextEncoder();</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = encoder.encode(<span class=\"string\">&quot;€&quot;</span>); <span class=\"comment\">// Uint8Array(3) [226, 130, 172]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decoder = <span class=\"keyword\">new</span> TextDecoder();</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = decoder.decode(array); <span class=\"comment\">// String &quot;€&quot;</span></span><br></pre></td></tr></table></figure>"},{"title":"【浏览器怎么操作二进制】【三】Blob 消费者","type":"tags","_content":"\n### Blob\n\n`ArrayBuffer` 和视图（view）都是 ECMA 标准的一部分，是 JavaScript 的一部分。\n\n在浏览器中，还有其他更<span style=\"color:red\">高级的对象</span>，特别是 `Blob`，在 [File API](https://www.w3.org/TR/FileAPI/) 中有相关描述。\n\n`Blob` 由一个可选的字符串 `type`（通常是 MIME 类型）和 `blobParts` 组成 —— 一系列其他 `Blob` 对象，字符串和 `BufferSource`。\n\n<img src=\"https://zh.javascript.info/article/blob/blob.svg\">\n\n<!--more-->\n\n构造函数的语法为：\n\n```javascript\nnew Blob(blobParts, options);\n```\n\n- **`blobParts`** 是 `Blob`/`BufferSource`/`String` 类型的值的数组。\n\n- `options`\n\n  可选对象：\n\n  - **`type`** —— `Blob` 类型，通常是 MIME 类型，例如 `image/png`，\n  - **`endings`** —— 是否转换换行符，使 `Blob` 对应于当前操作系统的换行符（`\\r\\n` 或 `\\n`）。默认为 `\"transparent\"`（啥也不做），不过也可以是 `\"native\"`（转换）。\n\n```javascript\n// 从字符串创建 Blob\nlet blob = new Blob([\"<html>…</html>\"], { type: \"text/html\" });\n// 请注意：第一个参数必须是一个数组 [...]\n```\n\n```javascript\n// 从类型化数组（typed array）和字符串创建 Blob\nlet hello = new Uint8Array([72, 101, 108, 108, 111]); // 二进制格式的 \"hello\"\n\nlet blob = new Blob([hello, \" \", \"world\"], { type: \"text/plain\" });\n```\n\n我们可以用 `slice` 方法来提取 `Blob` 片段：\n\n```javascript\nblob.slice([byteStart], [byteEnd], [contentType]);\n```\n\n- **`byteStart`** —— 起始字节，默认为 0。\n- **`byteEnd`** —— 最后一个字节（专有，默认为最后）。\n- **`contentType`** —— 新 blob 的 `type`，默认与源 blob 相同。\n\n参数值类似于 `array.slice`，也允许是负数。\n\n**`Blob` 对象是不可改变的**\n\n我们无法直接在 `Blob` 中更改数据，但我们可以通过 `slice` 获得 `Blob` 的多个部分，从这些部分创建新的 `Blob` 对象，将它们组成新的 `Blob`，等。\n\n这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以生成一个新的改动过的字符串。\n\n#### [Blob 接口参考](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n\n| 属性 |                                                                                        | 读写性   |\n| ---- | -------------------------------------------------------------------------------------- | -------- |\n| size | `Blob` 对象中所包含数据的大小（字节）。                                                | readonly |\n| type | 一个字符串，表明该 `Blob` 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。 | readonly |\n\n| 方法                                                                                                        | return                                                                                                                                                            | 返回类型 |\n| ----------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |\n| [`Blob.slice([start[, end[, contentType\\]]])`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice) | 返回一个新的 `Blob` 对象，包含了源 `Blob` 对象中指定范围内的数据。                                                                                                | blob     |\n| [`Blob.stream()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream)                             | 返回一个能读取 blob 内容的 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)。[知乎详解](https://zhuanlan.zhihu.com/p/98848420) |          |\n| [`Blob.text()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text)                                 | 返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString)。                                  | Promise  |\n| [`Blob.arrayBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer)                   | 返回一个 promise 且包含 blob 所有内容的二进制格式的 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | Promise  |\n|                                                                                                             |                                                                                                                                                                   |          |\n\n#### [Blob 用作 URL](https://zh.javascript.info/blob#blob-yong-zuo-url)\n\n<span style=\"color:red\">Blob 可以很容易用作 `<a>`、`<img>` 或其他标签的 URL，来显示它们的内容。</span>\n\n多亏了 `type`，让我们也可以下载/上传 `Blob` 对象，而在网络请求中，`type` 自然地变成了 `Content-Type`。\n\n让我们从一个简单的例子开始。通过点击链接，你可以下载一个具有动态生成的内容为 `hello world` 的 `Blob` 的文件：\n\n```javascript\n<!-- download 特性（attribute）强制浏览器下载而不是导航 -->\n<a download=\"hello.txt\" href='#' id=\"link\">Download</a>\n\n<script>\nlet blob = new Blob([\"Hello, world!\"], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n</script>\n```\n\n`URL.createObjectURL` 取一个 `Blob`，并为其创建一个唯一的 URL，形式为 `blob:<origin>/<uuid>`。\n\n也就是 `link.href` 的值的样子：\n\n```\nblob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273\n```\n\n浏览器内部为每个通过 `URL.createObjectURL` 生成的 URL 存储了一个 URL → `Blob` 映射。因此，此类 URL 很短，但可以访问 `Blob`。\n\n生成的 URL（即其链接）仅在当前文档打开的状态下才有效。它允许引用 `<img>`、`<a>` 中的 `Blob`，以及基本上任何其他期望 URL 的对象。\n\n不过它有个副作用。虽然这里有 `Blob` 的映射，但 `Blob` 本身只保存在内存中的。浏览器无法释放它。\n\n在文档退出时（unload），该映射会被自动清除，因此 `Blob` 也相应被释放了。但是，如果应用程序寿命很长，那这个释放就不会很快发生。\n\n**因此，如果我们创建一个 URL，那么即使我们不再需要该 `Blob` 了，它也会被挂在内存中。**\n\n`URL.revokeObjectURL(url)` 从内部映射中移除引用，因此允许 `Blob` 被删除（如果没有其他引用的话），并释放内存。\n\n在上面最后一个示例中，我们打算仅使用一次 `Blob`，来进行即时下载，因此我们立即调用 `URL.revokeObjectURL(link.href)`。\n\n而在前一个带有可点击的 HTML 链接的示例中，我们不调用 `URL.revokeObjectURL(link.href)`，因为那样会使 `Blob` URL 无效。在调用该方法后，由于映射被删除了，因此该 URL 也就不再起作用了。\n\n#### [Blob 转换为 base64](https://zh.javascript.info/blob#blob-zhuan-huan-wei-base64)\n\n`URL.createObjectURL` 的一个替代方法是，将 `Blob` 转换为 base64-编码的字符串。\n\n这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读“。更重要的是 —— 我们可以在 “data-url” 中使用此编码。\n\n[“data-url”](https://developer.mozilla.org/zh/docs/Web/http/Data_URIs) 的形式为 `data:[<mediatype>][;base64],<data>`。我们可以在任何地方使用这种 url，和使用“常规” url 一样。\n\n例如，这是一个笑脸：\n\n```javascript\n<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n```\n\n浏览器将解码该字符串，并显示图像：<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n\n我们使用内建的 `FileReader` 对象来将 `Blob` 转换为 base64。它可以将 `Blob` 中的数据读取为多种格式。在[下一章](https://zh.javascript.info/file) 我们将更深入地介绍它。\n\n下面是下载 `Blob` 的示例，这次是通过 base-64：\n\n```javascript\nlet link = document.createElement(\"a\");\nlink.download = \"hello.txt\";\n\nlet blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n\nlet reader = new FileReader();\nreader.readAsDataURL(blob); // 将 Blob 转换为 base64 并调用 onload\n\nreader.onload = function () {\n  link.href = reader.result; // data url\n  link.click();\n};\n```\n\n这两种从 `Blob` 创建 URL 的方法都可以用。但通常 `URL.createObjectURL(blob)` 更简单快捷。\n\n| URL.createObjectURL(blob)                | **Blob 转换为 data url**                       |\n| ---------------------------------------- | ---------------------------------------------- |\n| 如果介意内存，我们需要撤销（revoke）它们 | 无需撤销（revoke）任何操作。                   |\n| 直接访问 `Blob`，无需“编码/解码”         | 对大的 `Blob` 进行编码时，性能和内存会有损耗。 |\n\n#### [Image 转换为 blob](https://zh.javascript.info/blob#image-zhuan-huan-wei-blob)\n\n我们可以创建一个图像（image）的、图像的一部分、或者甚至创建一个页面截图的 `Blob`。这样方便将其上传至其他地方\n\n图像操作是通过 `<canvas>` 元素来实现的：\n\n1. 使用 [canvas.drawImage](https://developer.mozilla.org/zh/docs/Web/api/CanvasRenderingContext2D/drawImage) 在 canvas 上绘制图像（或图像的一部分）。\n2. 调用 canvas 方法 [.toBlob(callback, format, quality)](https://developer.mozilla.org/zh/docs/Web/api/HTMLCanvasElement/toBlob) 创建一个 `Blob`，并在创建完成后使用其运行 `callback`。\n\n在下面这个示例中，图像只是被复制了，不过我们可以在创建 blob 之前，从中裁剪图像，或者在 canvas 上对其进行转换：\n\n```javascript\n// 获取任何图像\nlet img = document.querySelector(\"img\");\n\n// 生成同尺寸的 <canvas>\nlet canvas = document.createElement(\"canvas\");\ncanvas.width = img.clientWidth;\ncanvas.height = img.clientHeight;\n\nlet context = canvas.getContext(\"2d\");\n\n// 向其中复制图像（此方法允许剪裁图像）\ncontext.drawImage(img, 0, 0);\n// 我们 context.rotate()，并在 canvas 上做很多其他事情\n\n// toBlob 是异步操作，结束后会调用 callback\ncanvas.toBlob(function (blob) {\n  // blob 创建完成，下载它\n  let link = document.createElement(\"a\");\n  link.download = \"example.png\";\n\n  link.href = URL.createObjectURL(blob);\n  link.click();\n\n  // 删除内部 blob 引用，这样浏览器可以从内存中将其清除\n  URL.revokeObjectURL(link.href);\n}, \"image/png\");\n```\n\n如果我们更喜欢 `async/await` 而不是 callback：\n\n```javascript\nlet blob = await new Promise((resolve) =>\n  canvasElem.toBlob(resolve, \"image/png\"),\n);\n```\n\n对于页面截屏，我们可以使用诸如 https://github.com/niklasvh/html2canvas 之类的库。它所做的只是扫一遍浏览器页面，并将其绘制在 `<canvas>` 上。然后，我们就可以像上面一样获取一个它的 `Blob`。\n\n#### [Blob 转换为 ArrayBuffer](https://zh.javascript.info/blob#blob-zhuan-huan-wei-arraybuffer)\n\n`Blob` 构造器允许从几乎所有东西创建 blob，包括任何 `BufferSource`。\n\n但是，如果我们需要执行低级别的操作的话，则可以使用 `FileReader` 从 blob 中获取最低级别的 `ArrayBuffer`：\n\n```javascript\n// 从 blob 获取 arrayBuffer\nlet fileReader = new FileReader();\n\nfileReader.readAsArrayBuffer(blob);\n\nfileReader.onload = function (event) {\n  let arrayBuffer = fileReader.result;\n};\n```\n\n#### 总结\n\n`ArrayBuffer`，`Uint8Array` 及其他 `BufferSource` 是“二进制数据”，而 [Blob](https://www.w3.org/TR/FileAPI/#dfn-Blob) 则表示“具有类型的二进制数据”（ `Blob` 类型，通常是 MIME 类型，例如 `image/png`，）。\n\n这样可以方便 `Blob` 用于在浏览器中非常常见的上传/下载操作。\n\n[XMLHttpRequest](https://zh.javascript.info/xmlhttprequest)，[fetch](https://zh.javascript.info/fetch) 等进行 Web 请求的方法可以自然地使用 `Blob`，也可以使用其他类型的二进制数据。\n\n我们可以轻松地在 `Blob` 和低级别的二进制数据类型之间进行转换：\n\n- 我们可以使用 `new Blob(...)` 构造函数从一个类型化数组（typed array）创建 `Blob`。\n- 我们可以使用 `FileReader` 从 `Blob` 中取回 `ArrayBuffer`，然后在其上创建一个视图（view），用于低级别的二进制处理。\n\n参考\n\n[【服务器】二进制处理功能源码](https://github.com/XiaoWinter/browser_binary_usage.git)\n\n[从 Fetch 到 Streams —— 以流的角度处理网络请求](https://zhuanlan.zhihu.com/p/98848420)\n\n[MDN Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n","source":"_posts/流处理3.md","raw":"---\ntitle: 【浏览器怎么操作二进制】【三】Blob 消费者\ntype: \"tags\"\ntags:\n  - Blob\n  - 二进制\ncategories: 二进制数据,文件\n---\n\n### Blob\n\n`ArrayBuffer` 和视图（view）都是 ECMA 标准的一部分，是 JavaScript 的一部分。\n\n在浏览器中，还有其他更<span style=\"color:red\">高级的对象</span>，特别是 `Blob`，在 [File API](https://www.w3.org/TR/FileAPI/) 中有相关描述。\n\n`Blob` 由一个可选的字符串 `type`（通常是 MIME 类型）和 `blobParts` 组成 —— 一系列其他 `Blob` 对象，字符串和 `BufferSource`。\n\n<img src=\"https://zh.javascript.info/article/blob/blob.svg\">\n\n<!--more-->\n\n构造函数的语法为：\n\n```javascript\nnew Blob(blobParts, options);\n```\n\n- **`blobParts`** 是 `Blob`/`BufferSource`/`String` 类型的值的数组。\n\n- `options`\n\n  可选对象：\n\n  - **`type`** —— `Blob` 类型，通常是 MIME 类型，例如 `image/png`，\n  - **`endings`** —— 是否转换换行符，使 `Blob` 对应于当前操作系统的换行符（`\\r\\n` 或 `\\n`）。默认为 `\"transparent\"`（啥也不做），不过也可以是 `\"native\"`（转换）。\n\n```javascript\n// 从字符串创建 Blob\nlet blob = new Blob([\"<html>…</html>\"], { type: \"text/html\" });\n// 请注意：第一个参数必须是一个数组 [...]\n```\n\n```javascript\n// 从类型化数组（typed array）和字符串创建 Blob\nlet hello = new Uint8Array([72, 101, 108, 108, 111]); // 二进制格式的 \"hello\"\n\nlet blob = new Blob([hello, \" \", \"world\"], { type: \"text/plain\" });\n```\n\n我们可以用 `slice` 方法来提取 `Blob` 片段：\n\n```javascript\nblob.slice([byteStart], [byteEnd], [contentType]);\n```\n\n- **`byteStart`** —— 起始字节，默认为 0。\n- **`byteEnd`** —— 最后一个字节（专有，默认为最后）。\n- **`contentType`** —— 新 blob 的 `type`，默认与源 blob 相同。\n\n参数值类似于 `array.slice`，也允许是负数。\n\n**`Blob` 对象是不可改变的**\n\n我们无法直接在 `Blob` 中更改数据，但我们可以通过 `slice` 获得 `Blob` 的多个部分，从这些部分创建新的 `Blob` 对象，将它们组成新的 `Blob`，等。\n\n这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以生成一个新的改动过的字符串。\n\n#### [Blob 接口参考](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n\n| 属性 |                                                                                        | 读写性   |\n| ---- | -------------------------------------------------------------------------------------- | -------- |\n| size | `Blob` 对象中所包含数据的大小（字节）。                                                | readonly |\n| type | 一个字符串，表明该 `Blob` 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。 | readonly |\n\n| 方法                                                                                                        | return                                                                                                                                                            | 返回类型 |\n| ----------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |\n| [`Blob.slice([start[, end[, contentType\\]]])`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice) | 返回一个新的 `Blob` 对象，包含了源 `Blob` 对象中指定范围内的数据。                                                                                                | blob     |\n| [`Blob.stream()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream)                             | 返回一个能读取 blob 内容的 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)。[知乎详解](https://zhuanlan.zhihu.com/p/98848420) |          |\n| [`Blob.text()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text)                                 | 返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString)。                                  | Promise  |\n| [`Blob.arrayBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer)                   | 返回一个 promise 且包含 blob 所有内容的二进制格式的 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | Promise  |\n|                                                                                                             |                                                                                                                                                                   |          |\n\n#### [Blob 用作 URL](https://zh.javascript.info/blob#blob-yong-zuo-url)\n\n<span style=\"color:red\">Blob 可以很容易用作 `<a>`、`<img>` 或其他标签的 URL，来显示它们的内容。</span>\n\n多亏了 `type`，让我们也可以下载/上传 `Blob` 对象，而在网络请求中，`type` 自然地变成了 `Content-Type`。\n\n让我们从一个简单的例子开始。通过点击链接，你可以下载一个具有动态生成的内容为 `hello world` 的 `Blob` 的文件：\n\n```javascript\n<!-- download 特性（attribute）强制浏览器下载而不是导航 -->\n<a download=\"hello.txt\" href='#' id=\"link\">Download</a>\n\n<script>\nlet blob = new Blob([\"Hello, world!\"], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n</script>\n```\n\n`URL.createObjectURL` 取一个 `Blob`，并为其创建一个唯一的 URL，形式为 `blob:<origin>/<uuid>`。\n\n也就是 `link.href` 的值的样子：\n\n```\nblob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273\n```\n\n浏览器内部为每个通过 `URL.createObjectURL` 生成的 URL 存储了一个 URL → `Blob` 映射。因此，此类 URL 很短，但可以访问 `Blob`。\n\n生成的 URL（即其链接）仅在当前文档打开的状态下才有效。它允许引用 `<img>`、`<a>` 中的 `Blob`，以及基本上任何其他期望 URL 的对象。\n\n不过它有个副作用。虽然这里有 `Blob` 的映射，但 `Blob` 本身只保存在内存中的。浏览器无法释放它。\n\n在文档退出时（unload），该映射会被自动清除，因此 `Blob` 也相应被释放了。但是，如果应用程序寿命很长，那这个释放就不会很快发生。\n\n**因此，如果我们创建一个 URL，那么即使我们不再需要该 `Blob` 了，它也会被挂在内存中。**\n\n`URL.revokeObjectURL(url)` 从内部映射中移除引用，因此允许 `Blob` 被删除（如果没有其他引用的话），并释放内存。\n\n在上面最后一个示例中，我们打算仅使用一次 `Blob`，来进行即时下载，因此我们立即调用 `URL.revokeObjectURL(link.href)`。\n\n而在前一个带有可点击的 HTML 链接的示例中，我们不调用 `URL.revokeObjectURL(link.href)`，因为那样会使 `Blob` URL 无效。在调用该方法后，由于映射被删除了，因此该 URL 也就不再起作用了。\n\n#### [Blob 转换为 base64](https://zh.javascript.info/blob#blob-zhuan-huan-wei-base64)\n\n`URL.createObjectURL` 的一个替代方法是，将 `Blob` 转换为 base64-编码的字符串。\n\n这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读“。更重要的是 —— 我们可以在 “data-url” 中使用此编码。\n\n[“data-url”](https://developer.mozilla.org/zh/docs/Web/http/Data_URIs) 的形式为 `data:[<mediatype>][;base64],<data>`。我们可以在任何地方使用这种 url，和使用“常规” url 一样。\n\n例如，这是一个笑脸：\n\n```javascript\n<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n```\n\n浏览器将解码该字符串，并显示图像：<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n\n我们使用内建的 `FileReader` 对象来将 `Blob` 转换为 base64。它可以将 `Blob` 中的数据读取为多种格式。在[下一章](https://zh.javascript.info/file) 我们将更深入地介绍它。\n\n下面是下载 `Blob` 的示例，这次是通过 base-64：\n\n```javascript\nlet link = document.createElement(\"a\");\nlink.download = \"hello.txt\";\n\nlet blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n\nlet reader = new FileReader();\nreader.readAsDataURL(blob); // 将 Blob 转换为 base64 并调用 onload\n\nreader.onload = function () {\n  link.href = reader.result; // data url\n  link.click();\n};\n```\n\n这两种从 `Blob` 创建 URL 的方法都可以用。但通常 `URL.createObjectURL(blob)` 更简单快捷。\n\n| URL.createObjectURL(blob)                | **Blob 转换为 data url**                       |\n| ---------------------------------------- | ---------------------------------------------- |\n| 如果介意内存，我们需要撤销（revoke）它们 | 无需撤销（revoke）任何操作。                   |\n| 直接访问 `Blob`，无需“编码/解码”         | 对大的 `Blob` 进行编码时，性能和内存会有损耗。 |\n\n#### [Image 转换为 blob](https://zh.javascript.info/blob#image-zhuan-huan-wei-blob)\n\n我们可以创建一个图像（image）的、图像的一部分、或者甚至创建一个页面截图的 `Blob`。这样方便将其上传至其他地方\n\n图像操作是通过 `<canvas>` 元素来实现的：\n\n1. 使用 [canvas.drawImage](https://developer.mozilla.org/zh/docs/Web/api/CanvasRenderingContext2D/drawImage) 在 canvas 上绘制图像（或图像的一部分）。\n2. 调用 canvas 方法 [.toBlob(callback, format, quality)](https://developer.mozilla.org/zh/docs/Web/api/HTMLCanvasElement/toBlob) 创建一个 `Blob`，并在创建完成后使用其运行 `callback`。\n\n在下面这个示例中，图像只是被复制了，不过我们可以在创建 blob 之前，从中裁剪图像，或者在 canvas 上对其进行转换：\n\n```javascript\n// 获取任何图像\nlet img = document.querySelector(\"img\");\n\n// 生成同尺寸的 <canvas>\nlet canvas = document.createElement(\"canvas\");\ncanvas.width = img.clientWidth;\ncanvas.height = img.clientHeight;\n\nlet context = canvas.getContext(\"2d\");\n\n// 向其中复制图像（此方法允许剪裁图像）\ncontext.drawImage(img, 0, 0);\n// 我们 context.rotate()，并在 canvas 上做很多其他事情\n\n// toBlob 是异步操作，结束后会调用 callback\ncanvas.toBlob(function (blob) {\n  // blob 创建完成，下载它\n  let link = document.createElement(\"a\");\n  link.download = \"example.png\";\n\n  link.href = URL.createObjectURL(blob);\n  link.click();\n\n  // 删除内部 blob 引用，这样浏览器可以从内存中将其清除\n  URL.revokeObjectURL(link.href);\n}, \"image/png\");\n```\n\n如果我们更喜欢 `async/await` 而不是 callback：\n\n```javascript\nlet blob = await new Promise((resolve) =>\n  canvasElem.toBlob(resolve, \"image/png\"),\n);\n```\n\n对于页面截屏，我们可以使用诸如 https://github.com/niklasvh/html2canvas 之类的库。它所做的只是扫一遍浏览器页面，并将其绘制在 `<canvas>` 上。然后，我们就可以像上面一样获取一个它的 `Blob`。\n\n#### [Blob 转换为 ArrayBuffer](https://zh.javascript.info/blob#blob-zhuan-huan-wei-arraybuffer)\n\n`Blob` 构造器允许从几乎所有东西创建 blob，包括任何 `BufferSource`。\n\n但是，如果我们需要执行低级别的操作的话，则可以使用 `FileReader` 从 blob 中获取最低级别的 `ArrayBuffer`：\n\n```javascript\n// 从 blob 获取 arrayBuffer\nlet fileReader = new FileReader();\n\nfileReader.readAsArrayBuffer(blob);\n\nfileReader.onload = function (event) {\n  let arrayBuffer = fileReader.result;\n};\n```\n\n#### 总结\n\n`ArrayBuffer`，`Uint8Array` 及其他 `BufferSource` 是“二进制数据”，而 [Blob](https://www.w3.org/TR/FileAPI/#dfn-Blob) 则表示“具有类型的二进制数据”（ `Blob` 类型，通常是 MIME 类型，例如 `image/png`，）。\n\n这样可以方便 `Blob` 用于在浏览器中非常常见的上传/下载操作。\n\n[XMLHttpRequest](https://zh.javascript.info/xmlhttprequest)，[fetch](https://zh.javascript.info/fetch) 等进行 Web 请求的方法可以自然地使用 `Blob`，也可以使用其他类型的二进制数据。\n\n我们可以轻松地在 `Blob` 和低级别的二进制数据类型之间进行转换：\n\n- 我们可以使用 `new Blob(...)` 构造函数从一个类型化数组（typed array）创建 `Blob`。\n- 我们可以使用 `FileReader` 从 `Blob` 中取回 `ArrayBuffer`，然后在其上创建一个视图（view），用于低级别的二进制处理。\n\n参考\n\n[【服务器】二进制处理功能源码](https://github.com/XiaoWinter/browser_binary_usage.git)\n\n[从 Fetch 到 Streams —— 以流的角度处理网络请求](https://zhuanlan.zhihu.com/p/98848420)\n\n[MDN Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n","slug":"流处理3","published":1,"date":"2021-07-03T16:03:28.981Z","updated":"2021-07-04T08:03:54.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqoye6he00079su04qcb6wjr","content":"<h3 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h3><p><code>ArrayBuffer</code> 和视图（view）都是 ECMA 标准的一部分，是 JavaScript 的一部分。</p>\n<p>在浏览器中，还有其他更<span style=\"color:red\">高级的对象</span>，特别是 <code>Blob</code>，在 <a href=\"https://www.w3.org/TR/FileAPI/\">File API</a> 中有相关描述。</p>\n<p><code>Blob</code> 由一个可选的字符串 <code>type</code>（通常是 MIME 类型）和 <code>blobParts</code> 组成 —— 一系列其他 <code>Blob</code> 对象，字符串和 <code>BufferSource</code>。</p>\n<img src=\"https://zh.javascript.info/article/blob/blob.svg\">\n\n<span id=\"more\"></span>\n\n<p>构造函数的语法为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Blob(blobParts, options);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong><code>blobParts</code></strong> 是 <code>Blob</code>/<code>BufferSource</code>/<code>String</code> 类型的值的数组。</p>\n</li>\n<li><p><code>options</code></p>\n<p>可选对象：</p>\n<ul>\n<li><strong><code>type</code></strong> —— <code>Blob</code> 类型，通常是 MIME 类型，例如 <code>image/png</code>，</li>\n<li><strong><code>endings</code></strong> —— 是否转换换行符，使 <code>Blob</code> 对应于当前操作系统的换行符（<code>\\r\\n</code> 或 <code>\\n</code>）。默认为 <code>&quot;transparent&quot;</code>（啥也不做），不过也可以是 <code>&quot;native&quot;</code>（转换）。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从字符串创建 Blob</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&quot;&lt;html&gt;…&lt;/html&gt;&quot;</span>], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;text/html&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// 请注意：第一个参数必须是一个数组 [...]</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从类型化数组（typed array）和字符串创建 Blob</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>]); <span class=\"comment\">// 二进制格式的 &quot;hello&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([hello, <span class=\"string\">&quot; &quot;</span>, <span class=\"string\">&quot;world&quot;</span>], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;text/plain&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用 <code>slice</code> 方法来提取 <code>Blob</code> 片段：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blob.slice([byteStart], [byteEnd], [contentType]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong><code>byteStart</code></strong> —— 起始字节，默认为 0。</li>\n<li><strong><code>byteEnd</code></strong> —— 最后一个字节（专有，默认为最后）。</li>\n<li><strong><code>contentType</code></strong> —— 新 blob 的 <code>type</code>，默认与源 blob 相同。</li>\n</ul>\n<p>参数值类似于 <code>array.slice</code>，也允许是负数。</p>\n<p><strong><code>Blob</code> 对象是不可改变的</strong></p>\n<p>我们无法直接在 <code>Blob</code> 中更改数据，但我们可以通过 <code>slice</code> 获得 <code>Blob</code> 的多个部分，从这些部分创建新的 <code>Blob</code> 对象，将它们组成新的 <code>Blob</code>，等。</p>\n<p>这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以生成一个新的改动过的字符串。</p>\n<h4 id=\"Blob-接口参考\"><a href=\"#Blob-接口参考\" class=\"headerlink\" title=\"Blob 接口参考\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\">Blob 接口参考</a></h4><table>\n<thead>\n<tr>\n<th>属性</th>\n<th></th>\n<th>读写性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>size</td>\n<td><code>Blob</code> 对象中所包含数据的大小（字节）。</td>\n<td>readonly</td>\n</tr>\n<tr>\n<td>type</td>\n<td>一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</td>\n<td>readonly</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>return</th>\n<th>返回类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice\"><code>Blob.slice([start[, end[, contentType]]])</code></a></td>\n<td>返回一个新的 <code>Blob</code> 对象，包含了源 <code>Blob</code> 对象中指定范围内的数据。</td>\n<td>blob</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream\"><code>Blob.stream()</code></a></td>\n<td>返回一个能读取 blob 内容的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a>。<a href=\"https://zhuanlan.zhihu.com/p/98848420\">知乎详解</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text\"><code>Blob.text()</code></a></td>\n<td>返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/USVString\"><code>USVString</code></a>。</td>\n<td>Promise</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer\"><code>Blob.arrayBuffer()</code></a></td>\n<td>返回一个 promise 且包含 blob 所有内容的二进制格式的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a></td>\n<td>Promise</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"Blob-用作-URL\"><a href=\"#Blob-用作-URL\" class=\"headerlink\" title=\"Blob 用作 URL\"></a><a href=\"https://zh.javascript.info/blob#blob-yong-zuo-url\">Blob 用作 URL</a></h4><p><span style=\"color:red\">Blob 可以很容易用作 <code>&lt;a&gt;</code>、<code>&lt;img&gt;</code> 或其他标签的 URL，来显示它们的内容。</span></p>\n<p>多亏了 <code>type</code>，让我们也可以下载/上传 <code>Blob</code> 对象，而在网络请求中，<code>type</code> 自然地变成了 <code>Content-Type</code>。</p>\n<p>让我们从一个简单的例子开始。通过点击链接，你可以下载一个具有动态生成的内容为 <code>hello world</code> 的 <code>Blob</code> 的文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- download 特性（attribute）强制浏览器下载而不是导航 --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">download</span>=<span class=\"string\">&quot;hello.txt&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&#x27;#&#x27;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;link&quot;</span>&gt;</span>Download<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&quot;Hello, world!&quot;</span>], &#123;<span class=\"attr\">type</span>: <span class=\"string\">&#x27;text/plain&#x27;</span>&#125;);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">link.href = URL.createObjectURL(blob);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>URL.createObjectURL</code> 取一个 <code>Blob</code>，并为其创建一个唯一的 URL，形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code>。</p>\n<p>也就是 <code>link.href</code> 的值的样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273</span><br></pre></td></tr></table></figure>\n\n<p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL → <code>Blob</code> 映射。因此，此类 URL 很短，但可以访问 <code>Blob</code>。</p>\n<p>生成的 URL（即其链接）仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code>、<code>&lt;a&gt;</code> 中的 <code>Blob</code>，以及基本上任何其他期望 URL 的对象。</p>\n<p>不过它有个副作用。虽然这里有 <code>Blob</code> 的映射，但 <code>Blob</code> 本身只保存在内存中的。浏览器无法释放它。</p>\n<p>在文档退出时（unload），该映射会被自动清除，因此 <code>Blob</code> 也相应被释放了。但是，如果应用程序寿命很长，那这个释放就不会很快发生。</p>\n<p><strong>因此，如果我们创建一个 URL，那么即使我们不再需要该 <code>Blob</code> 了，它也会被挂在内存中。</strong></p>\n<p><code>URL.revokeObjectURL(url)</code> 从内部映射中移除引用，因此允许 <code>Blob</code> 被删除（如果没有其他引用的话），并释放内存。</p>\n<p>在上面最后一个示例中，我们打算仅使用一次 <code>Blob</code>，来进行即时下载，因此我们立即调用 <code>URL.revokeObjectURL(link.href)</code>。</p>\n<p>而在前一个带有可点击的 HTML 链接的示例中，我们不调用 <code>URL.revokeObjectURL(link.href)</code>，因为那样会使 <code>Blob</code> URL 无效。在调用该方法后，由于映射被删除了，因此该 URL 也就不再起作用了。</p>\n<h4 id=\"Blob-转换为-base64\"><a href=\"#Blob-转换为-base64\" class=\"headerlink\" title=\"Blob 转换为 base64\"></a><a href=\"https://zh.javascript.info/blob#blob-zhuan-huan-wei-base64\">Blob 转换为 base64</a></h4><p><code>URL.createObjectURL</code> 的一个替代方法是，将 <code>Blob</code> 转换为 base64-编码的字符串。</p>\n<p>这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读“。更重要的是 —— 我们可以在 “data-url” 中使用此编码。</p>\n<p><a href=\"https://developer.mozilla.org/zh/docs/Web/http/Data_URIs\">“data-url”</a> 的形式为 <code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code>。我们可以在任何地方使用这种 url，和使用“常规” url 一样。</p>\n<p>例如，这是一个笑脸：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">&quot;data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>浏览器将解码该字符串，并显示图像：<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\"></p>\n<p>我们使用内建的 <code>FileReader</code> 对象来将 <code>Blob</code> 转换为 base64。它可以将 <code>Blob</code> 中的数据读取为多种格式。在<a href=\"https://zh.javascript.info/file\">下一章</a> 我们将更深入地介绍它。</p>\n<p>下面是下载 <code>Blob</code> 的示例，这次是通过 base-64：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> link = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">link.download = <span class=\"string\">&quot;hello.txt&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&quot;Hello, world!&quot;</span>], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;text/plain&quot;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsDataURL(blob); <span class=\"comment\">// 将 Blob 转换为 base64 并调用 onload</span></span><br><span class=\"line\"></span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  link.href = reader.result; <span class=\"comment\">// data url</span></span><br><span class=\"line\">  link.click();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这两种从 <code>Blob</code> 创建 URL 的方法都可以用。但通常 <code>URL.createObjectURL(blob)</code> 更简单快捷。</p>\n<table>\n<thead>\n<tr>\n<th>URL.createObjectURL(blob)</th>\n<th><strong>Blob 转换为 data url</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>如果介意内存，我们需要撤销（revoke）它们</td>\n<td>无需撤销（revoke）任何操作。</td>\n</tr>\n<tr>\n<td>直接访问 <code>Blob</code>，无需“编码/解码”</td>\n<td>对大的 <code>Blob</code> 进行编码时，性能和内存会有损耗。</td>\n</tr>\n</tbody></table>\n<h4 id=\"Image-转换为-blob\"><a href=\"#Image-转换为-blob\" class=\"headerlink\" title=\"Image 转换为 blob\"></a><a href=\"https://zh.javascript.info/blob#image-zhuan-huan-wei-blob\">Image 转换为 blob</a></h4><p>我们可以创建一个图像（image）的、图像的一部分、或者甚至创建一个页面截图的 <code>Blob</code>。这样方便将其上传至其他地方</p>\n<p>图像操作是通过 <code>&lt;canvas&gt;</code> 元素来实现的：</p>\n<ol>\n<li>使用 <a href=\"https://developer.mozilla.org/zh/docs/Web/api/CanvasRenderingContext2D/drawImage\">canvas.drawImage</a> 在 canvas 上绘制图像（或图像的一部分）。</li>\n<li>调用 canvas 方法 <a href=\"https://developer.mozilla.org/zh/docs/Web/api/HTMLCanvasElement/toBlob\">.toBlob(callback, format, quality)</a> 创建一个 <code>Blob</code>，并在创建完成后使用其运行 <code>callback</code>。</li>\n</ol>\n<p>在下面这个示例中，图像只是被复制了，不过我们可以在创建 blob 之前，从中裁剪图像，或者在 canvas 上对其进行转换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取任何图像</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> img = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;img&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成同尺寸的 &lt;canvas&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;canvas&quot;</span>);</span><br><span class=\"line\">canvas.width = img.clientWidth;</span><br><span class=\"line\">canvas.height = img.clientHeight;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> context = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向其中复制图像（此方法允许剪裁图像）</span></span><br><span class=\"line\">context.drawImage(img, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 我们 context.rotate()，并在 canvas 上做很多其他事情</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// toBlob 是异步操作，结束后会调用 callback</span></span><br><span class=\"line\">canvas.toBlob(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">blob</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// blob 创建完成，下载它</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> link = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">  link.download = <span class=\"string\">&quot;example.png&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  link.href = URL.createObjectURL(blob);</span><br><span class=\"line\">  link.click();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 删除内部 blob 引用，这样浏览器可以从内存中将其清除</span></span><br><span class=\"line\">  URL.revokeObjectURL(link.href);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;image/png&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果我们更喜欢 <code>async/await</code> 而不是 callback：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span></span><br><span class=\"line\">  canvasElem.toBlob(resolve, <span class=\"string\">&quot;image/png&quot;</span>),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>对于页面截屏，我们可以使用诸如 <a href=\"https://github.com/niklasvh/html2canvas\">https://github.com/niklasvh/html2canvas</a> 之类的库。它所做的只是扫一遍浏览器页面，并将其绘制在 <code>&lt;canvas&gt;</code> 上。然后，我们就可以像上面一样获取一个它的 <code>Blob</code>。</p>\n<h4 id=\"Blob-转换为-ArrayBuffer\"><a href=\"#Blob-转换为-ArrayBuffer\" class=\"headerlink\" title=\"Blob 转换为 ArrayBuffer\"></a><a href=\"https://zh.javascript.info/blob#blob-zhuan-huan-wei-arraybuffer\">Blob 转换为 ArrayBuffer</a></h4><p><code>Blob</code> 构造器允许从几乎所有东西创建 blob，包括任何 <code>BufferSource</code>。</p>\n<p>但是，如果我们需要执行低级别的操作的话，则可以使用 <code>FileReader</code> 从 blob 中获取最低级别的 <code>ArrayBuffer</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从 blob 获取 arrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\"></span><br><span class=\"line\">fileReader.readAsArrayBuffer(blob);</span><br><span class=\"line\"></span><br><span class=\"line\">fileReader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arrayBuffer = fileReader.result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><code>ArrayBuffer</code>，<code>Uint8Array</code> 及其他 <code>BufferSource</code> 是“二进制数据”，而 <a href=\"https://www.w3.org/TR/FileAPI/#dfn-Blob\">Blob</a> 则表示“具有类型的二进制数据”（ <code>Blob</code> 类型，通常是 MIME 类型，例如 <code>image/png</code>，）。</p>\n<p>这样可以方便 <code>Blob</code> 用于在浏览器中非常常见的上传/下载操作。</p>\n<p><a href=\"https://zh.javascript.info/xmlhttprequest\">XMLHttpRequest</a>，<a href=\"https://zh.javascript.info/fetch\">fetch</a> 等进行 Web 请求的方法可以自然地使用 <code>Blob</code>，也可以使用其他类型的二进制数据。</p>\n<p>我们可以轻松地在 <code>Blob</code> 和低级别的二进制数据类型之间进行转换：</p>\n<ul>\n<li>我们可以使用 <code>new Blob(...)</code> 构造函数从一个类型化数组（typed array）创建 <code>Blob</code>。</li>\n<li>我们可以使用 <code>FileReader</code> 从 <code>Blob</code> 中取回 <code>ArrayBuffer</code>，然后在其上创建一个视图（view），用于低级别的二进制处理。</li>\n</ul>\n<p>参考</p>\n<p><a href=\"https://github.com/XiaoWinter/browser_binary_usage.git\">【服务器】二进制处理功能源码</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/98848420\">从 Fetch 到 Streams —— 以流的角度处理网络请求</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\">MDN Blob</a></p>\n","site":{"data":{}},"length":5474,"excerpt":"<h3 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h3><p><code>ArrayBuffer</code> 和视图（view）都是 ECMA 标准的一部分，是 JavaScript 的一部分。</p>\n<p>在浏览器中，还有其他更<span style=\"color:red\">高级的对象</span>，特别是 <code>Blob</code>，在 <a href=\"https://www.w3.org/TR/FileAPI/\">File API</a> 中有相关描述。</p>\n<p><code>Blob</code> 由一个可选的字符串 <code>type</code>（通常是 MIME 类型）和 <code>blobParts</code> 组成 —— 一系列其他 <code>Blob</code> 对象，字符串和 <code>BufferSource</code>。</p>\n<img src=\"https://zh.javascript.info/article/blob/blob.svg\">","more":"<p>构造函数的语法为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Blob(blobParts, options);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong><code>blobParts</code></strong> 是 <code>Blob</code>/<code>BufferSource</code>/<code>String</code> 类型的值的数组。</p>\n</li>\n<li><p><code>options</code></p>\n<p>可选对象：</p>\n<ul>\n<li><strong><code>type</code></strong> —— <code>Blob</code> 类型，通常是 MIME 类型，例如 <code>image/png</code>，</li>\n<li><strong><code>endings</code></strong> —— 是否转换换行符，使 <code>Blob</code> 对应于当前操作系统的换行符（<code>\\r\\n</code> 或 <code>\\n</code>）。默认为 <code>&quot;transparent&quot;</code>（啥也不做），不过也可以是 <code>&quot;native&quot;</code>（转换）。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从字符串创建 Blob</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&quot;&lt;html&gt;…&lt;/html&gt;&quot;</span>], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;text/html&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// 请注意：第一个参数必须是一个数组 [...]</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从类型化数组（typed array）和字符串创建 Blob</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>([<span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>]); <span class=\"comment\">// 二进制格式的 &quot;hello&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([hello, <span class=\"string\">&quot; &quot;</span>, <span class=\"string\">&quot;world&quot;</span>], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;text/plain&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用 <code>slice</code> 方法来提取 <code>Blob</code> 片段：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blob.slice([byteStart], [byteEnd], [contentType]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong><code>byteStart</code></strong> —— 起始字节，默认为 0。</li>\n<li><strong><code>byteEnd</code></strong> —— 最后一个字节（专有，默认为最后）。</li>\n<li><strong><code>contentType</code></strong> —— 新 blob 的 <code>type</code>，默认与源 blob 相同。</li>\n</ul>\n<p>参数值类似于 <code>array.slice</code>，也允许是负数。</p>\n<p><strong><code>Blob</code> 对象是不可改变的</strong></p>\n<p>我们无法直接在 <code>Blob</code> 中更改数据，但我们可以通过 <code>slice</code> 获得 <code>Blob</code> 的多个部分，从这些部分创建新的 <code>Blob</code> 对象，将它们组成新的 <code>Blob</code>，等。</p>\n<p>这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以生成一个新的改动过的字符串。</p>\n<h4 id=\"Blob-接口参考\"><a href=\"#Blob-接口参考\" class=\"headerlink\" title=\"Blob 接口参考\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\">Blob 接口参考</a></h4><table>\n<thead>\n<tr>\n<th>属性</th>\n<th></th>\n<th>读写性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>size</td>\n<td><code>Blob</code> 对象中所包含数据的大小（字节）。</td>\n<td>readonly</td>\n</tr>\n<tr>\n<td>type</td>\n<td>一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</td>\n<td>readonly</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>return</th>\n<th>返回类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice\"><code>Blob.slice([start[, end[, contentType]]])</code></a></td>\n<td>返回一个新的 <code>Blob</code> 对象，包含了源 <code>Blob</code> 对象中指定范围内的数据。</td>\n<td>blob</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream\"><code>Blob.stream()</code></a></td>\n<td>返回一个能读取 blob 内容的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream\"><code>ReadableStream</code></a>。<a href=\"https://zhuanlan.zhihu.com/p/98848420\">知乎详解</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text\"><code>Blob.text()</code></a></td>\n<td>返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/USVString\"><code>USVString</code></a>。</td>\n<td>Promise</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer\"><code>Blob.arrayBuffer()</code></a></td>\n<td>返回一个 promise 且包含 blob 所有内容的二进制格式的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a></td>\n<td>Promise</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"Blob-用作-URL\"><a href=\"#Blob-用作-URL\" class=\"headerlink\" title=\"Blob 用作 URL\"></a><a href=\"https://zh.javascript.info/blob#blob-yong-zuo-url\">Blob 用作 URL</a></h4><p><span style=\"color:red\">Blob 可以很容易用作 <code>&lt;a&gt;</code>、<code>&lt;img&gt;</code> 或其他标签的 URL，来显示它们的内容。</span></p>\n<p>多亏了 <code>type</code>，让我们也可以下载/上传 <code>Blob</code> 对象，而在网络请求中，<code>type</code> 自然地变成了 <code>Content-Type</code>。</p>\n<p>让我们从一个简单的例子开始。通过点击链接，你可以下载一个具有动态生成的内容为 <code>hello world</code> 的 <code>Blob</code> 的文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- download 特性（attribute）强制浏览器下载而不是导航 --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">download</span>=<span class=\"string\">&quot;hello.txt&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&#x27;#&#x27;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;link&quot;</span>&gt;</span>Download<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&quot;Hello, world!&quot;</span>], &#123;<span class=\"attr\">type</span>: <span class=\"string\">&#x27;text/plain&#x27;</span>&#125;);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">link.href = URL.createObjectURL(blob);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>URL.createObjectURL</code> 取一个 <code>Blob</code>，并为其创建一个唯一的 URL，形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code>。</p>\n<p>也就是 <code>link.href</code> 的值的样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273</span><br></pre></td></tr></table></figure>\n\n<p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL → <code>Blob</code> 映射。因此，此类 URL 很短，但可以访问 <code>Blob</code>。</p>\n<p>生成的 URL（即其链接）仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code>、<code>&lt;a&gt;</code> 中的 <code>Blob</code>，以及基本上任何其他期望 URL 的对象。</p>\n<p>不过它有个副作用。虽然这里有 <code>Blob</code> 的映射，但 <code>Blob</code> 本身只保存在内存中的。浏览器无法释放它。</p>\n<p>在文档退出时（unload），该映射会被自动清除，因此 <code>Blob</code> 也相应被释放了。但是，如果应用程序寿命很长，那这个释放就不会很快发生。</p>\n<p><strong>因此，如果我们创建一个 URL，那么即使我们不再需要该 <code>Blob</code> 了，它也会被挂在内存中。</strong></p>\n<p><code>URL.revokeObjectURL(url)</code> 从内部映射中移除引用，因此允许 <code>Blob</code> 被删除（如果没有其他引用的话），并释放内存。</p>\n<p>在上面最后一个示例中，我们打算仅使用一次 <code>Blob</code>，来进行即时下载，因此我们立即调用 <code>URL.revokeObjectURL(link.href)</code>。</p>\n<p>而在前一个带有可点击的 HTML 链接的示例中，我们不调用 <code>URL.revokeObjectURL(link.href)</code>，因为那样会使 <code>Blob</code> URL 无效。在调用该方法后，由于映射被删除了，因此该 URL 也就不再起作用了。</p>\n<h4 id=\"Blob-转换为-base64\"><a href=\"#Blob-转换为-base64\" class=\"headerlink\" title=\"Blob 转换为 base64\"></a><a href=\"https://zh.javascript.info/blob#blob-zhuan-huan-wei-base64\">Blob 转换为 base64</a></h4><p><code>URL.createObjectURL</code> 的一个替代方法是，将 <code>Blob</code> 转换为 base64-编码的字符串。</p>\n<p>这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读“。更重要的是 —— 我们可以在 “data-url” 中使用此编码。</p>\n<p><a href=\"https://developer.mozilla.org/zh/docs/Web/http/Data_URIs\">“data-url”</a> 的形式为 <code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code>。我们可以在任何地方使用这种 url，和使用“常规” url 一样。</p>\n<p>例如，这是一个笑脸：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">&quot;data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>浏览器将解码该字符串，并显示图像：<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\"></p>\n<p>我们使用内建的 <code>FileReader</code> 对象来将 <code>Blob</code> 转换为 base64。它可以将 <code>Blob</code> 中的数据读取为多种格式。在<a href=\"https://zh.javascript.info/file\">下一章</a> 我们将更深入地介绍它。</p>\n<p>下面是下载 <code>Blob</code> 的示例，这次是通过 base-64：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> link = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">link.download = <span class=\"string\">&quot;hello.txt&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">&quot;Hello, world!&quot;</span>], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;text/plain&quot;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsDataURL(blob); <span class=\"comment\">// 将 Blob 转换为 base64 并调用 onload</span></span><br><span class=\"line\"></span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  link.href = reader.result; <span class=\"comment\">// data url</span></span><br><span class=\"line\">  link.click();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这两种从 <code>Blob</code> 创建 URL 的方法都可以用。但通常 <code>URL.createObjectURL(blob)</code> 更简单快捷。</p>\n<table>\n<thead>\n<tr>\n<th>URL.createObjectURL(blob)</th>\n<th><strong>Blob 转换为 data url</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>如果介意内存，我们需要撤销（revoke）它们</td>\n<td>无需撤销（revoke）任何操作。</td>\n</tr>\n<tr>\n<td>直接访问 <code>Blob</code>，无需“编码/解码”</td>\n<td>对大的 <code>Blob</code> 进行编码时，性能和内存会有损耗。</td>\n</tr>\n</tbody></table>\n<h4 id=\"Image-转换为-blob\"><a href=\"#Image-转换为-blob\" class=\"headerlink\" title=\"Image 转换为 blob\"></a><a href=\"https://zh.javascript.info/blob#image-zhuan-huan-wei-blob\">Image 转换为 blob</a></h4><p>我们可以创建一个图像（image）的、图像的一部分、或者甚至创建一个页面截图的 <code>Blob</code>。这样方便将其上传至其他地方</p>\n<p>图像操作是通过 <code>&lt;canvas&gt;</code> 元素来实现的：</p>\n<ol>\n<li>使用 <a href=\"https://developer.mozilla.org/zh/docs/Web/api/CanvasRenderingContext2D/drawImage\">canvas.drawImage</a> 在 canvas 上绘制图像（或图像的一部分）。</li>\n<li>调用 canvas 方法 <a href=\"https://developer.mozilla.org/zh/docs/Web/api/HTMLCanvasElement/toBlob\">.toBlob(callback, format, quality)</a> 创建一个 <code>Blob</code>，并在创建完成后使用其运行 <code>callback</code>。</li>\n</ol>\n<p>在下面这个示例中，图像只是被复制了，不过我们可以在创建 blob 之前，从中裁剪图像，或者在 canvas 上对其进行转换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取任何图像</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> img = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;img&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成同尺寸的 &lt;canvas&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;canvas&quot;</span>);</span><br><span class=\"line\">canvas.width = img.clientWidth;</span><br><span class=\"line\">canvas.height = img.clientHeight;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> context = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向其中复制图像（此方法允许剪裁图像）</span></span><br><span class=\"line\">context.drawImage(img, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 我们 context.rotate()，并在 canvas 上做很多其他事情</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// toBlob 是异步操作，结束后会调用 callback</span></span><br><span class=\"line\">canvas.toBlob(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">blob</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// blob 创建完成，下载它</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> link = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">  link.download = <span class=\"string\">&quot;example.png&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  link.href = URL.createObjectURL(blob);</span><br><span class=\"line\">  link.click();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 删除内部 blob 引用，这样浏览器可以从内存中将其清除</span></span><br><span class=\"line\">  URL.revokeObjectURL(link.href);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;image/png&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果我们更喜欢 <code>async/await</code> 而不是 callback：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> blob = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span></span><br><span class=\"line\">  canvasElem.toBlob(resolve, <span class=\"string\">&quot;image/png&quot;</span>),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>对于页面截屏，我们可以使用诸如 <a href=\"https://github.com/niklasvh/html2canvas\">https://github.com/niklasvh/html2canvas</a> 之类的库。它所做的只是扫一遍浏览器页面，并将其绘制在 <code>&lt;canvas&gt;</code> 上。然后，我们就可以像上面一样获取一个它的 <code>Blob</code>。</p>\n<h4 id=\"Blob-转换为-ArrayBuffer\"><a href=\"#Blob-转换为-ArrayBuffer\" class=\"headerlink\" title=\"Blob 转换为 ArrayBuffer\"></a><a href=\"https://zh.javascript.info/blob#blob-zhuan-huan-wei-arraybuffer\">Blob 转换为 ArrayBuffer</a></h4><p><code>Blob</code> 构造器允许从几乎所有东西创建 blob，包括任何 <code>BufferSource</code>。</p>\n<p>但是，如果我们需要执行低级别的操作的话，则可以使用 <code>FileReader</code> 从 blob 中获取最低级别的 <code>ArrayBuffer</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从 blob 获取 arrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\"></span><br><span class=\"line\">fileReader.readAsArrayBuffer(blob);</span><br><span class=\"line\"></span><br><span class=\"line\">fileReader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arrayBuffer = fileReader.result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><code>ArrayBuffer</code>，<code>Uint8Array</code> 及其他 <code>BufferSource</code> 是“二进制数据”，而 <a href=\"https://www.w3.org/TR/FileAPI/#dfn-Blob\">Blob</a> 则表示“具有类型的二进制数据”（ <code>Blob</code> 类型，通常是 MIME 类型，例如 <code>image/png</code>，）。</p>\n<p>这样可以方便 <code>Blob</code> 用于在浏览器中非常常见的上传/下载操作。</p>\n<p><a href=\"https://zh.javascript.info/xmlhttprequest\">XMLHttpRequest</a>，<a href=\"https://zh.javascript.info/fetch\">fetch</a> 等进行 Web 请求的方法可以自然地使用 <code>Blob</code>，也可以使用其他类型的二进制数据。</p>\n<p>我们可以轻松地在 <code>Blob</code> 和低级别的二进制数据类型之间进行转换：</p>\n<ul>\n<li>我们可以使用 <code>new Blob(...)</code> 构造函数从一个类型化数组（typed array）创建 <code>Blob</code>。</li>\n<li>我们可以使用 <code>FileReader</code> 从 <code>Blob</code> 中取回 <code>ArrayBuffer</code>，然后在其上创建一个视图（view），用于低级别的二进制处理。</li>\n</ul>\n<p>参考</p>\n<p><a href=\"https://github.com/XiaoWinter/browser_binary_usage.git\">【服务器】二进制处理功能源码</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/98848420\">从 Fetch 到 Streams —— 以流的角度处理网络请求</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\">MDN Blob</a></p>"},{"title":"【浏览器怎么操作二进制】【四】文件File及文件读取FileReader","type":"tags","_content":"\n### File 和 FileReader\n\n[File](https://www.w3.org/TR/FileAPI/#dfn-file) 对象继承自 `Blob`，并扩展了与文件系统相关的功能。\n\n有两种方式可以获取它。\n\n<!--more-->\n\n第一种，与 `Blob` 类似，有一个构造器：\n\n```javascript\nnew File(fileParts, fileName, [options]);\n```\n\n- **`fileParts`** —— Blob/BufferSource/String 类型值的数组。\n\n- **`fileName`** —— 文件名字符串。\n\n- `options`\n\n  —— 可选对象：\n\n  - **`lastModified`** —— 最后一次修改的时间戳（整数日期）。\n\n第二种，更常见的是，我们从 `<input type=\"file\">` 或拖放或其他浏览器接口来获取文件。在这种情况下，file 将从操作系统（OS）获得 this 信息。（得查查规范）\n\n由于 `File` 是继承自 `Blob` 的，所以 `File` 对象具有相同的属性，附加：\n\n- `name` —— 文件名，\n- `lastModified` —— 最后一次修改的时间戳。\n\n这就是我们从 `<input type=\"file\">` 中获取 `File` 对象的方式：\n\n```javascript\n<input type=\"file\" onchange=\"showFile(this)\">\n\n<script>\nfunction showFile(input) {\n  let file = input.files[0];\n\n  alert(`File name: ${file.name}`); // 例如 my.png\n  alert(`Last modified: ${file.lastModified}`); // 例如 1552830408824\n}\n</script>\n```\n\n**请注意：**\n\n输入（input）可以选择多个文件，因此 `input.files` 是一个类数组对象。这里我们只有一个文件，所以我们只取 `input.files[0]`。\n\n#### [FileReader](https://zh.javascript.info/file#filereader)\n\n[FileReader](https://www.w3.org/TR/FileAPI/#dfn-filereader) 是一个对象，其唯一目的是从 `Blob`（因此也从 `File`）对象中读取数据。\n\n它使用事件来传递数据，因为从磁盘读取数据可能比较费时间。\n\n构造函数：\n\n```javascript\nlet reader = new FileReader(); // 没有参数\n```\n\n主要方法:\n\n- **`readAsArrayBuffer(blob)`** —— 将数据读取为二进制格式的 `ArrayBuffer`。\n- **`readAsText(blob, [encoding])`** —— 将数据读取为给定编码（默认为 `utf-8` 编码）的文本字符串。\n- **`readAsDataURL(blob)`** —— 读取二进制数据，并将其编码为 base64 的 data url。\n- **`abort()`** —— 取消操作。\n\n| read\\*            | 参数 | 返回        |\n| ----------------- | ---- | ----------- |\n| readAsArrayBuffer | blob | ArrayBuffer |\n| readAsText        | blob | String      |\n| readAsDataURL     | blob | DataUrl     |\n\n##### FileReader 事件\n\n读取过程中，有以下事件：\n\n- `loadstart` —— 开始加载。\n- `progress` —— 在读取过程中出现。\n- `load` —— 读取完成，没有 error。\n- `abort` —— 调用了 `abort()`。\n- `error` —— 出现 error。\n- `loadend` —— 读取完成，无论成功还是失败。\n\n读取完成后，我们可以通过以下方式访问读取结果：\n\n- `reader.result` 是结果（如果成功）\n- `reader.error` 是 error（如果失败）。\n\n使用最广泛的事件无疑是 `load` 和 `error`。\n\n这是一个读取文件的示例：\n\n```javascript\n<input type=\"file\" onchange=\"readFile(this)\">\n\n<script>\nfunction readFile(input) {\n  let file = input.files[0];\n\n  let reader = new FileReader();\n\n  reader.readAsText(file);\n\n  reader.onload = function() {\n    console.log(reader.result);\n  };\n\n  reader.onerror = function() {\n    console.log(reader.error);\n  };\n\n}\n</script>\n```\n\n**在 Web Workers 中可以使用 `FileReaderSync`**\n\n对于 Web Worker，还有一种同步的 `FileReader` 变体，称为 [FileReaderSync](https://www.w3.org/TR/FileAPI/#FileReaderSync)。\n\n它的读取方法 `read*` 不会生成事件，但是会像常规函数那样返回一个结果。\n\n不过，这仅在 Web Worker 中可用，因为在读取文件的时候，同步调用会有延迟，而在 Web Worker 中，这种延迟并不是很重要。它不会影响页面。\n\n#### [总结](https://zh.javascript.info/file#zong-jie)\n\n`File` 对象继承自 `Blob`。\n\n除了 `Blob` 方法和属性外，`File` 对象还有 `name` 和 `lastModified` 属性，以及从文件系统读取的内部功能。我们通常从用户输入如 `<input>` 或拖放事件来获取 `File` 对象。\n\n`FileReader` 对象可以从文件或 blob 中读取数据，可以读取为以下三种格式：\n\n- 字符串（`readAsText`）。\n- `ArrayBuffer`（`readAsArrayBuffer`）。\n- data url，base-64 编码（`readAsDataURL`）。\n\n但是，在很多情况下，我们不必读取文件内容。就像我们处理 blob 一样，我们可以使用 `URL.createObjectURL(file)` 创建一个短的 url，并将其赋给 `<a>` 或 `<img>`。这样，文件便可以下载文件或者将其呈现为图像，作为 canvas 等的一部分。\n\n而且，如果我们要通过网络发送一个 `File`，那也很容易：**像 `XMLHttpRequest` 或 `fetch` 等网络 API 本身就接受 `File` 对象**\n","source":"_posts/流处理4.md","raw":"---\ntitle: 【浏览器怎么操作二进制】【四】文件File及文件读取FileReader\ntype: \"tags\"\ntags:\n  - File\n  - FileReader\n  - 二进制\ncategories: 二进制数据,文件\n---\n\n### File 和 FileReader\n\n[File](https://www.w3.org/TR/FileAPI/#dfn-file) 对象继承自 `Blob`，并扩展了与文件系统相关的功能。\n\n有两种方式可以获取它。\n\n<!--more-->\n\n第一种，与 `Blob` 类似，有一个构造器：\n\n```javascript\nnew File(fileParts, fileName, [options]);\n```\n\n- **`fileParts`** —— Blob/BufferSource/String 类型值的数组。\n\n- **`fileName`** —— 文件名字符串。\n\n- `options`\n\n  —— 可选对象：\n\n  - **`lastModified`** —— 最后一次修改的时间戳（整数日期）。\n\n第二种，更常见的是，我们从 `<input type=\"file\">` 或拖放或其他浏览器接口来获取文件。在这种情况下，file 将从操作系统（OS）获得 this 信息。（得查查规范）\n\n由于 `File` 是继承自 `Blob` 的，所以 `File` 对象具有相同的属性，附加：\n\n- `name` —— 文件名，\n- `lastModified` —— 最后一次修改的时间戳。\n\n这就是我们从 `<input type=\"file\">` 中获取 `File` 对象的方式：\n\n```javascript\n<input type=\"file\" onchange=\"showFile(this)\">\n\n<script>\nfunction showFile(input) {\n  let file = input.files[0];\n\n  alert(`File name: ${file.name}`); // 例如 my.png\n  alert(`Last modified: ${file.lastModified}`); // 例如 1552830408824\n}\n</script>\n```\n\n**请注意：**\n\n输入（input）可以选择多个文件，因此 `input.files` 是一个类数组对象。这里我们只有一个文件，所以我们只取 `input.files[0]`。\n\n#### [FileReader](https://zh.javascript.info/file#filereader)\n\n[FileReader](https://www.w3.org/TR/FileAPI/#dfn-filereader) 是一个对象，其唯一目的是从 `Blob`（因此也从 `File`）对象中读取数据。\n\n它使用事件来传递数据，因为从磁盘读取数据可能比较费时间。\n\n构造函数：\n\n```javascript\nlet reader = new FileReader(); // 没有参数\n```\n\n主要方法:\n\n- **`readAsArrayBuffer(blob)`** —— 将数据读取为二进制格式的 `ArrayBuffer`。\n- **`readAsText(blob, [encoding])`** —— 将数据读取为给定编码（默认为 `utf-8` 编码）的文本字符串。\n- **`readAsDataURL(blob)`** —— 读取二进制数据，并将其编码为 base64 的 data url。\n- **`abort()`** —— 取消操作。\n\n| read\\*            | 参数 | 返回        |\n| ----------------- | ---- | ----------- |\n| readAsArrayBuffer | blob | ArrayBuffer |\n| readAsText        | blob | String      |\n| readAsDataURL     | blob | DataUrl     |\n\n##### FileReader 事件\n\n读取过程中，有以下事件：\n\n- `loadstart` —— 开始加载。\n- `progress` —— 在读取过程中出现。\n- `load` —— 读取完成，没有 error。\n- `abort` —— 调用了 `abort()`。\n- `error` —— 出现 error。\n- `loadend` —— 读取完成，无论成功还是失败。\n\n读取完成后，我们可以通过以下方式访问读取结果：\n\n- `reader.result` 是结果（如果成功）\n- `reader.error` 是 error（如果失败）。\n\n使用最广泛的事件无疑是 `load` 和 `error`。\n\n这是一个读取文件的示例：\n\n```javascript\n<input type=\"file\" onchange=\"readFile(this)\">\n\n<script>\nfunction readFile(input) {\n  let file = input.files[0];\n\n  let reader = new FileReader();\n\n  reader.readAsText(file);\n\n  reader.onload = function() {\n    console.log(reader.result);\n  };\n\n  reader.onerror = function() {\n    console.log(reader.error);\n  };\n\n}\n</script>\n```\n\n**在 Web Workers 中可以使用 `FileReaderSync`**\n\n对于 Web Worker，还有一种同步的 `FileReader` 变体，称为 [FileReaderSync](https://www.w3.org/TR/FileAPI/#FileReaderSync)。\n\n它的读取方法 `read*` 不会生成事件，但是会像常规函数那样返回一个结果。\n\n不过，这仅在 Web Worker 中可用，因为在读取文件的时候，同步调用会有延迟，而在 Web Worker 中，这种延迟并不是很重要。它不会影响页面。\n\n#### [总结](https://zh.javascript.info/file#zong-jie)\n\n`File` 对象继承自 `Blob`。\n\n除了 `Blob` 方法和属性外，`File` 对象还有 `name` 和 `lastModified` 属性，以及从文件系统读取的内部功能。我们通常从用户输入如 `<input>` 或拖放事件来获取 `File` 对象。\n\n`FileReader` 对象可以从文件或 blob 中读取数据，可以读取为以下三种格式：\n\n- 字符串（`readAsText`）。\n- `ArrayBuffer`（`readAsArrayBuffer`）。\n- data url，base-64 编码（`readAsDataURL`）。\n\n但是，在很多情况下，我们不必读取文件内容。就像我们处理 blob 一样，我们可以使用 `URL.createObjectURL(file)` 创建一个短的 url，并将其赋给 `<a>` 或 `<img>`。这样，文件便可以下载文件或者将其呈现为图像，作为 canvas 等的一部分。\n\n而且，如果我们要通过网络发送一个 `File`，那也很容易：**像 `XMLHttpRequest` 或 `fetch` 等网络 API 本身就接受 `File` 对象**\n","slug":"流处理4","published":1,"date":"2021-07-04T03:56:41.014Z","updated":"2021-07-04T07:17:14.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqoye6he00089su05678exxy","content":"<h3 id=\"File-和-FileReader\"><a href=\"#File-和-FileReader\" class=\"headerlink\" title=\"File 和 FileReader\"></a>File 和 FileReader</h3><p><a href=\"https://www.w3.org/TR/FileAPI/#dfn-file\">File</a> 对象继承自 <code>Blob</code>，并扩展了与文件系统相关的功能。</p>\n<p>有两种方式可以获取它。</p>\n<span id=\"more\"></span>\n\n<p>第一种，与 <code>Blob</code> 类似，有一个构造器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> File(fileParts, fileName, [options]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong><code>fileParts</code></strong> —— Blob/BufferSource/String 类型值的数组。</p>\n</li>\n<li><p><strong><code>fileName</code></strong> —— 文件名字符串。</p>\n</li>\n<li><p><code>options</code></p>\n<p>—— 可选对象：</p>\n<ul>\n<li><strong><code>lastModified</code></strong> —— 最后一次修改的时间戳（整数日期）。</li>\n</ul>\n</li>\n</ul>\n<p>第二种，更常见的是，我们从 <code>&lt;input type=&quot;file&quot;&gt;</code> 或拖放或其他浏览器接口来获取文件。在这种情况下，file 将从操作系统（OS）获得 this 信息。（得查查规范）</p>\n<p>由于 <code>File</code> 是继承自 <code>Blob</code> 的，所以 <code>File</code> 对象具有相同的属性，附加：</p>\n<ul>\n<li><code>name</code> —— 文件名，</li>\n<li><code>lastModified</code> —— 最后一次修改的时间戳。</li>\n</ul>\n<p>这就是我们从 <code>&lt;input type=&quot;file&quot;&gt;</code> 中获取 <code>File</code> 对象的方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">&quot;file&quot;</span> onchange=<span class=\"string\">&quot;showFile(this)&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showFile</span>(<span class=\"params\">input</span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"keyword\">let</span> file = input.files[<span class=\"number\">0</span>];</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  alert(<span class=\"string\">`File name: <span class=\"subst\">$&#123;file.name&#125;</span>`</span>); <span class=\"comment\">// 例如 my.png</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  alert(<span class=\"string\">`Last modified: <span class=\"subst\">$&#123;file.lastModified&#125;</span>`</span>); <span class=\"comment\">// 例如 1552830408824</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">&#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>请注意：</strong></p>\n<p>输入（input）可以选择多个文件，因此 <code>input.files</code> 是一个类数组对象。这里我们只有一个文件，所以我们只取 <code>input.files[0]</code>。</p>\n<h4 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a><a href=\"https://zh.javascript.info/file#filereader\">FileReader</a></h4><p><a href=\"https://www.w3.org/TR/FileAPI/#dfn-filereader\">FileReader</a> 是一个对象，其唯一目的是从 <code>Blob</code>（因此也从 <code>File</code>）对象中读取数据。</p>\n<p>它使用事件来传递数据，因为从磁盘读取数据可能比较费时间。</p>\n<p>构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> reader = <span class=\"keyword\">new</span> FileReader(); <span class=\"comment\">// 没有参数</span></span><br></pre></td></tr></table></figure>\n\n<p>主要方法:</p>\n<ul>\n<li><strong><code>readAsArrayBuffer(blob)</code></strong> —— 将数据读取为二进制格式的 <code>ArrayBuffer</code>。</li>\n<li><strong><code>readAsText(blob, [encoding])</code></strong> —— 将数据读取为给定编码（默认为 <code>utf-8</code> 编码）的文本字符串。</li>\n<li><strong><code>readAsDataURL(blob)</code></strong> —— 读取二进制数据，并将其编码为 base64 的 data url。</li>\n<li><strong><code>abort()</code></strong> —— 取消操作。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>read*</th>\n<th>参数</th>\n<th>返回</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>readAsArrayBuffer</td>\n<td>blob</td>\n<td>ArrayBuffer</td>\n</tr>\n<tr>\n<td>readAsText</td>\n<td>blob</td>\n<td>String</td>\n</tr>\n<tr>\n<td>readAsDataURL</td>\n<td>blob</td>\n<td>DataUrl</td>\n</tr>\n</tbody></table>\n<h5 id=\"FileReader-事件\"><a href=\"#FileReader-事件\" class=\"headerlink\" title=\"FileReader 事件\"></a>FileReader 事件</h5><p>读取过程中，有以下事件：</p>\n<ul>\n<li><code>loadstart</code> —— 开始加载。</li>\n<li><code>progress</code> —— 在读取过程中出现。</li>\n<li><code>load</code> —— 读取完成，没有 error。</li>\n<li><code>abort</code> —— 调用了 <code>abort()</code>。</li>\n<li><code>error</code> —— 出现 error。</li>\n<li><code>loadend</code> —— 读取完成，无论成功还是失败。</li>\n</ul>\n<p>读取完成后，我们可以通过以下方式访问读取结果：</p>\n<ul>\n<li><code>reader.result</code> 是结果（如果成功）</li>\n<li><code>reader.error</code> 是 error（如果失败）。</li>\n</ul>\n<p>使用最广泛的事件无疑是 <code>load</code> 和 <code>error</code>。</p>\n<p>这是一个读取文件的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">&quot;file&quot;</span> onchange=<span class=\"string\">&quot;readFile(this)&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFile</span>(<span class=\"params\">input</span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"keyword\">let</span> file = input.files[<span class=\"number\">0</span>];</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"keyword\">let</span> reader = <span class=\"keyword\">new</span> FileReader();</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  reader.readAsText(file);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  reader.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"built_in\">console</span>.log(reader.result);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  &#125;;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  reader.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"built_in\">console</span>.log(reader.error);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  &#125;;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">&#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>在 Web Workers 中可以使用 <code>FileReaderSync</code></strong></p>\n<p>对于 Web Worker，还有一种同步的 <code>FileReader</code> 变体，称为 <a href=\"https://www.w3.org/TR/FileAPI/#FileReaderSync\">FileReaderSync</a>。</p>\n<p>它的读取方法 <code>read*</code> 不会生成事件，但是会像常规函数那样返回一个结果。</p>\n<p>不过，这仅在 Web Worker 中可用，因为在读取文件的时候，同步调用会有延迟，而在 Web Worker 中，这种延迟并不是很重要。它不会影响页面。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><a href=\"https://zh.javascript.info/file#zong-jie\">总结</a></h4><p><code>File</code> 对象继承自 <code>Blob</code>。</p>\n<p>除了 <code>Blob</code> 方法和属性外，<code>File</code> 对象还有 <code>name</code> 和 <code>lastModified</code> 属性，以及从文件系统读取的内部功能。我们通常从用户输入如 <code>&lt;input&gt;</code> 或拖放事件来获取 <code>File</code> 对象。</p>\n<p><code>FileReader</code> 对象可以从文件或 blob 中读取数据，可以读取为以下三种格式：</p>\n<ul>\n<li>字符串（<code>readAsText</code>）。</li>\n<li><code>ArrayBuffer</code>（<code>readAsArrayBuffer</code>）。</li>\n<li>data url，base-64 编码（<code>readAsDataURL</code>）。</li>\n</ul>\n<p>但是，在很多情况下，我们不必读取文件内容。就像我们处理 blob 一样，我们可以使用 <code>URL.createObjectURL(file)</code> 创建一个短的 url，并将其赋给 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code>。这样，文件便可以下载文件或者将其呈现为图像，作为 canvas 等的一部分。</p>\n<p>而且，如果我们要通过网络发送一个 <code>File</code>，那也很容易：<strong>像 <code>XMLHttpRequest</code> 或 <code>fetch</code> 等网络 API 本身就接受 <code>File</code> 对象</strong></p>\n","site":{"data":{}},"length":2408,"excerpt":"<h3 id=\"File-和-FileReader\"><a href=\"#File-和-FileReader\" class=\"headerlink\" title=\"File 和 FileReader\"></a>File 和 FileReader</h3><p><a href=\"https://www.w3.org/TR/FileAPI/#dfn-file\">File</a> 对象继承自 <code>Blob</code>，并扩展了与文件系统相关的功能。</p>\n<p>有两种方式可以获取它。</p>","more":"<p>第一种，与 <code>Blob</code> 类似，有一个构造器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> File(fileParts, fileName, [options]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong><code>fileParts</code></strong> —— Blob/BufferSource/String 类型值的数组。</p>\n</li>\n<li><p><strong><code>fileName</code></strong> —— 文件名字符串。</p>\n</li>\n<li><p><code>options</code></p>\n<p>—— 可选对象：</p>\n<ul>\n<li><strong><code>lastModified</code></strong> —— 最后一次修改的时间戳（整数日期）。</li>\n</ul>\n</li>\n</ul>\n<p>第二种，更常见的是，我们从 <code>&lt;input type=&quot;file&quot;&gt;</code> 或拖放或其他浏览器接口来获取文件。在这种情况下，file 将从操作系统（OS）获得 this 信息。（得查查规范）</p>\n<p>由于 <code>File</code> 是继承自 <code>Blob</code> 的，所以 <code>File</code> 对象具有相同的属性，附加：</p>\n<ul>\n<li><code>name</code> —— 文件名，</li>\n<li><code>lastModified</code> —— 最后一次修改的时间戳。</li>\n</ul>\n<p>这就是我们从 <code>&lt;input type=&quot;file&quot;&gt;</code> 中获取 <code>File</code> 对象的方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">&quot;file&quot;</span> onchange=<span class=\"string\">&quot;showFile(this)&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showFile</span>(<span class=\"params\">input</span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"keyword\">let</span> file = input.files[<span class=\"number\">0</span>];</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  alert(<span class=\"string\">`File name: <span class=\"subst\">$&#123;file.name&#125;</span>`</span>); <span class=\"comment\">// 例如 my.png</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  alert(<span class=\"string\">`Last modified: <span class=\"subst\">$&#123;file.lastModified&#125;</span>`</span>); <span class=\"comment\">// 例如 1552830408824</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">&#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>请注意：</strong></p>\n<p>输入（input）可以选择多个文件，因此 <code>input.files</code> 是一个类数组对象。这里我们只有一个文件，所以我们只取 <code>input.files[0]</code>。</p>\n<h4 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a><a href=\"https://zh.javascript.info/file#filereader\">FileReader</a></h4><p><a href=\"https://www.w3.org/TR/FileAPI/#dfn-filereader\">FileReader</a> 是一个对象，其唯一目的是从 <code>Blob</code>（因此也从 <code>File</code>）对象中读取数据。</p>\n<p>它使用事件来传递数据，因为从磁盘读取数据可能比较费时间。</p>\n<p>构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> reader = <span class=\"keyword\">new</span> FileReader(); <span class=\"comment\">// 没有参数</span></span><br></pre></td></tr></table></figure>\n\n<p>主要方法:</p>\n<ul>\n<li><strong><code>readAsArrayBuffer(blob)</code></strong> —— 将数据读取为二进制格式的 <code>ArrayBuffer</code>。</li>\n<li><strong><code>readAsText(blob, [encoding])</code></strong> —— 将数据读取为给定编码（默认为 <code>utf-8</code> 编码）的文本字符串。</li>\n<li><strong><code>readAsDataURL(blob)</code></strong> —— 读取二进制数据，并将其编码为 base64 的 data url。</li>\n<li><strong><code>abort()</code></strong> —— 取消操作。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>read*</th>\n<th>参数</th>\n<th>返回</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>readAsArrayBuffer</td>\n<td>blob</td>\n<td>ArrayBuffer</td>\n</tr>\n<tr>\n<td>readAsText</td>\n<td>blob</td>\n<td>String</td>\n</tr>\n<tr>\n<td>readAsDataURL</td>\n<td>blob</td>\n<td>DataUrl</td>\n</tr>\n</tbody></table>\n<h5 id=\"FileReader-事件\"><a href=\"#FileReader-事件\" class=\"headerlink\" title=\"FileReader 事件\"></a>FileReader 事件</h5><p>读取过程中，有以下事件：</p>\n<ul>\n<li><code>loadstart</code> —— 开始加载。</li>\n<li><code>progress</code> —— 在读取过程中出现。</li>\n<li><code>load</code> —— 读取完成，没有 error。</li>\n<li><code>abort</code> —— 调用了 <code>abort()</code>。</li>\n<li><code>error</code> —— 出现 error。</li>\n<li><code>loadend</code> —— 读取完成，无论成功还是失败。</li>\n</ul>\n<p>读取完成后，我们可以通过以下方式访问读取结果：</p>\n<ul>\n<li><code>reader.result</code> 是结果（如果成功）</li>\n<li><code>reader.error</code> 是 error（如果失败）。</li>\n</ul>\n<p>使用最广泛的事件无疑是 <code>load</code> 和 <code>error</code>。</p>\n<p>这是一个读取文件的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">&quot;file&quot;</span> onchange=<span class=\"string\">&quot;readFile(this)&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFile</span>(<span class=\"params\">input</span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"keyword\">let</span> file = input.files[<span class=\"number\">0</span>];</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"keyword\">let</span> reader = <span class=\"keyword\">new</span> FileReader();</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  reader.readAsText(file);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  reader.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"built_in\">console</span>.log(reader.result);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  &#125;;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  reader.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"built_in\">console</span>.log(reader.error);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  &#125;;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">&#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>在 Web Workers 中可以使用 <code>FileReaderSync</code></strong></p>\n<p>对于 Web Worker，还有一种同步的 <code>FileReader</code> 变体，称为 <a href=\"https://www.w3.org/TR/FileAPI/#FileReaderSync\">FileReaderSync</a>。</p>\n<p>它的读取方法 <code>read*</code> 不会生成事件，但是会像常规函数那样返回一个结果。</p>\n<p>不过，这仅在 Web Worker 中可用，因为在读取文件的时候，同步调用会有延迟，而在 Web Worker 中，这种延迟并不是很重要。它不会影响页面。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><a href=\"https://zh.javascript.info/file#zong-jie\">总结</a></h4><p><code>File</code> 对象继承自 <code>Blob</code>。</p>\n<p>除了 <code>Blob</code> 方法和属性外，<code>File</code> 对象还有 <code>name</code> 和 <code>lastModified</code> 属性，以及从文件系统读取的内部功能。我们通常从用户输入如 <code>&lt;input&gt;</code> 或拖放事件来获取 <code>File</code> 对象。</p>\n<p><code>FileReader</code> 对象可以从文件或 blob 中读取数据，可以读取为以下三种格式：</p>\n<ul>\n<li>字符串（<code>readAsText</code>）。</li>\n<li><code>ArrayBuffer</code>（<code>readAsArrayBuffer</code>）。</li>\n<li>data url，base-64 编码（<code>readAsDataURL</code>）。</li>\n</ul>\n<p>但是，在很多情况下，我们不必读取文件内容。就像我们处理 blob 一样，我们可以使用 <code>URL.createObjectURL(file)</code> 创建一个短的 url，并将其赋给 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code>。这样，文件便可以下载文件或者将其呈现为图像，作为 canvas 等的一部分。</p>\n<p>而且，如果我们要通过网络发送一个 <code>File</code>，那也很容易：<strong>像 <code>XMLHttpRequest</code> 或 <code>fetch</code> 等网络 API 本身就接受 <code>File</code> 对象</strong></p>"},{"title":"【浏览器怎么操作二进制】【五】总结","type":"tags","_content":"\n![img](https://pic2.zhimg.com/80/v2-ed143b043805e01fbbea5712c7e27789_720w.jpg)\n\n<!-- more -->\n\n参考资料在最后\n大概是对前端的二进制处理入门了\n\n主要参考文献\n\n[MDN](https://developer.mozilla.org/zh-CN/)\n\n[聊聊 JS 的二进制家族：Blob、ArrayBuffer 和 Buffer](https://zhuanlan.zhihu.com/p/97768916)\n\n[[1.3 万字] 玩转前端二进制](https://juejin.cn/post/6846687590783909902#heading-27)\n\n[【服务器】二进制处理功能源码](https://github.com/XiaoWinter/browser_binary_usage.git)\n\n[现代 javascript 二进制数据，文件](https://zh.javascript.info/binary)\n","source":"_posts/流处理5.md","raw":"---\ntitle: 【浏览器怎么操作二进制】【五】总结\ntype: \"tags\"\ntags:\n  - ArrayBuffer\n  - TypeArray\n  - DataView\n  - TextDecoder\n  - TextEncoder\n  - Blob\n  - decode\n  - encode\n  - File\n  - FileReader\n  - 二进制\ncategories: 二进制数据,文件\n---\n\n![img](https://pic2.zhimg.com/80/v2-ed143b043805e01fbbea5712c7e27789_720w.jpg)\n\n<!-- more -->\n\n参考资料在最后\n大概是对前端的二进制处理入门了\n\n主要参考文献\n\n[MDN](https://developer.mozilla.org/zh-CN/)\n\n[聊聊 JS 的二进制家族：Blob、ArrayBuffer 和 Buffer](https://zhuanlan.zhihu.com/p/97768916)\n\n[[1.3 万字] 玩转前端二进制](https://juejin.cn/post/6846687590783909902#heading-27)\n\n[【服务器】二进制处理功能源码](https://github.com/XiaoWinter/browser_binary_usage.git)\n\n[现代 javascript 二进制数据，文件](https://zh.javascript.info/binary)\n","slug":"流处理5","published":1,"date":"2021-07-04T07:17:36.718Z","updated":"2021-07-04T08:53:09.362Z","_id":"ckqoye6hg000b9su039wq3f1i","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://pic2.zhimg.com/80/v2-ed143b043805e01fbbea5712c7e27789_720w.jpg\" alt=\"img\"></p>\n<span id=\"more\"></span>\n\n<p>参考资料在最后<br>大概是对前端的二进制处理入门了</p>\n<p>主要参考文献</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/\">MDN</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/97768916\">聊聊 JS 的二进制家族：Blob、ArrayBuffer 和 Buffer</a></p>\n<p><a href=\"https://juejin.cn/post/6846687590783909902#heading-27\">[1.3 万字] 玩转前端二进制</a></p>\n<p><a href=\"https://github.com/XiaoWinter/browser_binary_usage.git\">【服务器】二进制处理功能源码</a></p>\n<p><a href=\"https://zh.javascript.info/binary\">现代 javascript 二进制数据，文件</a></p>\n","site":{"data":{}},"length":113,"excerpt":"<p><img src=\"https://pic2.zhimg.com/80/v2-ed143b043805e01fbbea5712c7e27789_720w.jpg\" alt=\"img\"></p>","more":"<p>参考资料在最后<br>大概是对前端的二进制处理入门了</p>\n<p>主要参考文献</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/\">MDN</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/97768916\">聊聊 JS 的二进制家族：Blob、ArrayBuffer 和 Buffer</a></p>\n<p><a href=\"https://juejin.cn/post/6846687590783909902#heading-27\">[1.3 万字] 玩转前端二进制</a></p>\n<p><a href=\"https://github.com/XiaoWinter/browser_binary_usage.git\">【服务器】二进制处理功能源码</a></p>\n<p><a href=\"https://zh.javascript.info/binary\">现代 javascript 二进制数据，文件</a></p>"},{"title":"计算机概论","type":"tags","_content":"\n> 参考资料\n\n[Crash Course 计算机视频](https://www.bilibili.com/video/av21376839?p=1)\n\n## 一、计算机的早期历史\n\n美索不达米亚 1000 BC 算盘\n\n| time          | area                         | Instance                   | 进制 |\n| ------------- | ---------------------------- | -------------------------- | ---- |\n| 1000BC        | 美索不达米亚                 | 算盘                       | 10   |\n| 1694          | 德国                         | 步进计算器                 | 10   |\n| before 20 C   | world                        | 计算表                     |      |\n| 1822          | 英国（Charles Babbage）      | 差分机（论文）             |      |\n| 1822-1842     | 英国(Charles Babbage)        | 分析机（general computer） |      |\n| 18X（8\\|9）？ | 美国（Hollerith IBM 创始人） | 打孔卡片制表机             |      |\n\nAda Lovelace 给分析机写了假象程序(第一程序员)\n\nCharles Babbage 设计了分析机，即通用计算机 （计算机之父）\n\n<!--more-->\n\n## 二、电子计算机\n\n机械继电器（开关），利用电磁线圈的磁场把开关吸下来，联通电路\n\n二极管 （首先出现为热电子管）\n\n三级真空管（二代继电器），每秒客开闭千次\n\n1947 贝尔实验室 晶体管（半导体材料继电器），每秒万次开闭，加州硅谷，出现仙童半导体公司，仙童来变成了英特尔，目前的晶体管体积 50 纳米，每秒上百万次开闭，工作几十年，\n\n| time    | area           | instance | person        | remarks                                   |\n| ------- | -------------- | -------- | ------------- | ----------------------------------------- |\n| 1944    | IBM            | Mark II  | IBM           | 1947 pulled a bug                         |\n| 1943.12 | 英国 Bletchley | Mark I   | Tommy Flowers | 大规模使用真空管(1600)，可编程，解密 Nazi |\n| 1941    | 英国 Bletchley | Bombe    | Alan Turing   | designd to break Enigma code              |\n| 1946    | 美             | ENIAC    | Pennsylvania  | 积分，真正意义电子计算机                  |\n| 1958    | 美             | IBM608   | IBM           | 使用晶体管                                |\n\n## 三、布尔逻辑与逻辑门\n\n### [布尔代数](http://www.ruanyifeng.com/blog/2016/08/boolean-algebra.html)\n\n关于真值的逻辑运算称为布尔代数（Boolean Algebra），以它的创始人布尔命名。\n\n在编程语言中表示 T 值和 F 值的数据类型叫做布尔类型，在 C 语言中通常用`int`类型来表示，非 0 表示 T，0 表示 F。布尔逻辑是写程序的基本功之一，程序中的很多错误都可以归因于逻辑错误。\n\n```\n以下是一些布尔代数的基本定理，为了简洁易读，T和F用1和0表示，AND用*号表示，OR用+号表示（从真值表可以看出AND和OR运算确实有些类似*和+），NOT用¬表示，x、y、z的值可能是0也可能是1。\n```\n\n```\n¬¬x=x\n\nx*0=0\nx+1=1\n\nx*1=x\nx+0=x\n\nx*x=x\nx+x=x\n\nx*¬x=0\nx+¬x=1\n\nx*y=y*x\nx+y=y+x\n\nx*(y*z)=(x*y)*z\nx+(y+z)=(x+y)+z\n\nx*(y+z)=x*y+x*z\nx+y*z=(x+y)*(x+z)\n\nx+x*y=x\nx*(x+y)=x\n\nx*y+x*¬y=x\n(x+y)*(x+¬y)=x\n\n¬(x*y)=¬x+¬y\n¬(x+y)=¬x*¬y\n\nx+¬x*y=x+y\nx*(¬x+y)=x*y\n\nx*y+¬x*z+y*z=x*y+¬x*z\n(x+y)*(¬x+z)*(y+z)=(x+y)*(¬x+z)\n\n除了第1行之外，这些公式都是每两行一组的，每组的两个公式就像对联一样：把其中一个公式中的*换成+、+换成*、0换成1、1换成0，就变成了与它对称的另一个公式。这些定理都可以通过真值表证明\n```\n\n### 逻辑门 and or not xor\n\n[逻辑门的晶体管实现](https://www.cnblogs.com/sunshine-jackie/p/8137240.html)\n\nVDD 就是电源的意思\n\n#### and\n\n| true  | true  | true  |\n| ----- | ----- | ----- |\n| true  | false | false |\n| false | true  | false |\n| false | false | false |\n\n#### or\n\n| true  | true  | true  |\n| ----- | ----- | ----- |\n| true  | false | true  |\n| false | true  | true  |\n| false | false | false |\n\n#### not\n\n| true  | false |\n| ----- | ----- |\n| false | true  |\n\n#### xor\n\n| true  | true  | false |\n| ----- | ----- | ----- |\n| true  | false | true  |\n| false | true  | true  |\n| false | false | false |\n\n## 四、二进制\n\n### 二进制，逢二进一\n\n| 2^7^ | 2^6^ | 2^5^ | 2^4^ | 2^3^ | 2^2^ | 2^1^ | 2^0^ |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 1    | 0    | 1    | 1    | 0    | 1    | 0    | 0    |\n\n二进制中，\n\n一个 0 或 1 表示一位（1bit）\n\n8bit = 1byte(字节)\n\n1kb = 2^10^ byte = 1024 byte\n\n#### 数字表示\n\n##### 整数\n\n0 000 0000 0000 0000 0000 0000 0000 0000\n\n首位表示正负（sign）其余为数值\n\n##### 浮点数\n\n0 000 0000 0 000 0000 0000 0000 0000 0000\n\n浮点数是将科学计数法的数字进行存储，首位表示正负（sign）接下来八位 表示指数，剩下的 23 位表示有效位数\n\n例如\n\n153446631161563 的科学计数法表示 0.153446631161563 x 10^15^\n\n它的浮点数如下 4 字节的浮点数精度损失还是比较大\n\n0 000 0111 1 100 0101 1100 0111 1000 1001‬\n\n#### 字符的表示\n\n字符表示最简单的方法就是给字母一个编号，就有了 ASCII\n\n为了表示 the world 的所有字符，后来就出现了 Unicode 和 ISO，之后他们俩兼容了，现在常用的编码实现位 utf-8,它是一种可变长的编码，<a href=\"#####utf-8\">utf-8 编码规则</a>\n\n##### unicode\n\n```\n正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。\n\n可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。\n\nUnicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。\n```\n\n##### unicode 的问题\n\n```\n需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n\n比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n\n这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。\n```\n\n##### utf-8\n\n```\n互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。\n\nUTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8 的编码规则很简单，只有二条：\n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。\n\n2）对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。\n\n下表总结了编码规则，字母x表示可用编码的位。\n\n```\n\n| Unicode 符号范围(十六进制) | UTF-8 编码方式（二进制）            |\n| -------------------------- | ----------------------------------- |\n| 0000 0000-0000 007F        | 0xxxxxxx                            |\n| 0000 0080-0000 07FF        | 110xxxxx 10xxxxxx                   |\n| 0000 0800-0000 FFFF        | 1110xxxx 10xxxxxx 10xxxxxx          |\n| 0001 0000-0010 FFFF        | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |\n\n```\n跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。\n\n下面，还是以汉字严为例，演示如何实现 UTF-8 编码。\n\n严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。\n```\n\n引用\n\n[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n#### 字节序小知识\n\n<img src=\"http://47.103.65.182/markdown/104.png\">\n\n## 五、算数逻辑单元 ALU (Arithmetic & Logic Unit)\n\nHow Computer Calculate ——the ALU\n\n### 计算单元\n\n#### 加法实现\n\n##### a half adder\n\n进行 1bit 运算\n\n<img src=\"http://47.103.65.182/markdown/040.png\">\n\n##### 全加器\n\nfull adder 使用两个 half adder 实现\n\n<img src=\"http://47.103.65.182/markdown/041.png\">\n\n##### 8bit adder\n\n<img src=\"http://47.103.65.182/markdown/042.png\">\n\n<img src=\"http://47.103.65.182/markdown/043.png\">\n\n### 逻辑单元\n\n布尔运算 and or not xor\n\n对输入的信号，进行逻辑运算，结果符合真值表\n\n#### ALU 抽象\n\n<img src=\"http://47.103.65.182/markdown/044.png\">\n\n## 六、寄存器和内存（Registers & RAM）\n\nRAM : Random Access Memory\n\nPM : Persistent Memory\n\n存储 1bit 数据\n\n### sava 1\n\n就或门输出与输入链接，可以形成一个 1 的永久存储\n\n<img src=\"http://47.103.65.182/markdown/045.png\">\n\n### sava 0\n\n将与门输出与输入连接，可以形成一个 0 的永久存储\n\n<img src=\"http://47.103.65.182/markdown/046.png\">\n\n### 锁存（AND-OR LATCH）\n\n将上述两个电路结合起来就做成了一个锁存器\n\n<img src=\"http://47.103.65.182/markdown/047.png\">\n\nset 设为 1 后，无论 set 如何改变，输出一直为 1，即 set 将状态置为 1\n\nreset 设为 1 后，无论 reset 如何改变，输出一直为 0，即 reset 将状态置为 0\n\nset 和 reset 都为 0 的话，锁存器将会保存最后设置的状态，1bit 的记忆功能就实现了，记忆的结果取决于最后关闭的是谁\n\n### 门锁（GATED LATCH）\n\n1bit 的可控制写入存储\n\n<img src=\"http://47.103.65.182/markdown/048.png\">\n\n允许写入线为 0 时，set,reset 恒为 0,不可写入，允许写入线为 1 时，输入 0 将 reset 锁存，输入 1 将 set 锁存\n\n#### 抽象出门锁组件\n\n<img src=\"http://47.103.65.182/markdown/049.png\">\n\n### 寄存器 register\n\nA group of lanches operating like this is called a **register** ,which hlod a single number , and the number of bits in a register is called its width.\n\n寄存器是[CPU](https://baike.baidu.com/item/CPU/120556)内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。寄存器的存储电路是由锁存器或触发器构成的，因为一个锁存器或触发器能存储 1 位二进制数，所以由 N 个[锁存器](https://baike.baidu.com/item/锁存器/10801965)或触发器可以构成 N 位寄存器。寄存器是中央处理器内的组成部分。寄存器是有限存储容量的高速存储部件，它们可用来暂存指令\n\n<img src=\"http://47.103.65.182/markdown/050.png\">\n\n16x16 门锁矩阵\n\n更大位的寄存器\n\n<img src=\"http://47.103.65.182/markdown/051.png\">\n\n启用某个门锁的方式位激活相应的排线和列线\n\n<img src=\"http://47.103.65.182/markdown/052.png\">\n\n在允许写入线前加一个**与门**，与行线和列线相连，就可以具体指向某个锁存\n\n<img src=\"http://47.103.65.182/markdown/054.png\">\n\n启用行列线，再**启用写入操作线**，就可以操作这个锁存，再因为没有行列线的锁存是关闭启用写入线，所以写入操作线就算公用的（1 条线连所有），也可以做到针对某个锁存操作，\n\n<img src=\"http://47.103.65.182/markdown/055.png\">\n\n启用行列线，再启用**读取操作线**，就可以打开门锁输出线的晶体管（应该是吧），启用数据输入输出线，就可以**读取到这个锁存的输出**\n\n<img src=\"http://47.103.65.182/markdown/057.png\">\n\n启用行列线，再启用**写入操作线**，就可以开启此所存的写入操作，此时操作**数据输入输出线**，可以设置锁存的值\n\n<img src=\"http://47.103.65.182/markdown/056.png\">\n\n### 地址\n\n如何表示操作的是哪个锁存，（我们任是使用 16x16 门锁矩阵）\n\n4bit 可以表示 16 个数字（0-15），8 个 bit 就可以表示一个地址（行，列）\n\n例如 3 行 10 列（0011，1010）\n\n#### 多路复用器(multiplexer)\n\n为了将行和列转换为地址，我们需要多路复用器(multiplexer)\n\n<img src=\"http://47.103.65.182/markdown/058.png\">\n\n#### 内存（memory）\n\n<img src=\"http://47.103.65.182/markdown/059.png\">\n\n#### 静态随机地址存储（SRAM）\n\n存储 8bit 数据的方式，8 个比特位用相同的地址分别存储\n\n<img src=\"http://47.103.65.182/markdown/060.png\">\n\n\n\n这个是一个 SRAM （static random access memory）\n\n把这个内存单元，看成拥有 256 个地址，每个地址能读写一个 8bit 值，这就是 RAM\n\n<img src=\"http://47.103.65.182/markdown/061.png\">\n\n## 七、The Center Processing Unit\n\n### 基础组件\n\n<img src=\"http://47.103.65.182/markdown/063.png\">\n\n### 指令表\n\n<img src=\"http://47.103.65.182/markdown/062.png\">\n\n### cpu 基本架构\n\n我们还需要两个寄存器来完成 CPU，一个用来存储指令地址（本例是 RAM），一个用来存储指令\n\n<img src=\"http://47.103.65.182/markdown/064.png\">\n\n### cpu 执行流程\n\n1.启动计算机，所有寄存器从零开始\n\n<img src=\"http://47.103.65.182/markdown/065.png\">\n\n2.为了举例我们在 RAM 放了一个程序\n\n#### 取指令 FETCH PHASE\n\ncpu 的第一个阶段叫做`取指令阶段`FETCH PHASE ,负责拿到指令\n\n- 指令地址寄存器连到 RAM，此时寄存器地址为０,因此 RAM 返回地址 0 的值,值会复制到指令寄存器里\n\n<img src=\"http://47.103.65.182/markdown/067.png\">\n\n#### 解码指令 DECODE FHASE\n\ncpu 的第二个阶段叫做`解码阶段`DECODE FHASE,负责解析出要执行什么指令\n\n<img src=\"http://47.103.65.182/markdown/068.png\">\n\n在我们定义的指令中,一个 8 位值,前 4 位代表指令,后 4 位代表参数;对于指令寄存器的值我们需要使用一个控制单元来进行解码\n\n- 检查指令是不是 LOAD_A,我们可以用很少的逻辑门实现\n\n<img src=\"http://47.103.65.182/markdown/069.png\">\n\n#### 执行指令 EXECUTE FHASE\n\n知道了是什么指令,我们就可以进入执行阶段\n\n<img src=\"http://47.103.65.182/markdown/070.png\">\n\n- 电路的连接保证 LOAD_A 正确执行\n\n<img src=\"http://47.103.65.182/markdown/071.png\">\n\n- 关闭电路,指令地址寄存器+1\n\n<img src=\"http://47.103.65.182/markdown/072.png\">\n\n### 控制单元\n\n分析完一个指令后,其他的指令也是类似的情况,所以将所有指令封装成一个控制单元\n\n<img src=\"http://47.103.65.182/markdown/073.png\">\n\n- 对于 ADD 指令我们需要使用 ALU\n\n<img src=\"http://47.103.65.182/markdown/074.png\">\n\n- 始终以精确的间隔触发电信号,控制单元会利用这个信号,推进 cpu 的内部操作,确保一切按步骤进行,cpu\"取指令-->解码-->执行\"的速度叫\"时钟速度(CLOCK SPEED)\"\n\n<img src=\"http://47.103.65.182/markdown/075.png\">\n\n### CPU \n\n<img src=\"http://47.103.65.182/markdown/076.png\">\n\n## 八、指令和程序(Instruction&Programs)\n\ncpu 之所以强大,是因为它是可编程的,写入不同的指令就会执行不同的任务,CPU 是一个可以被软件控制的硬件\n\n这是上一节的例子,四个指令形成了一个加法的操作\n\n- RAM 地址 14 的值 加载到 RA\n- RAM 地址 15 的值加载到 RB\n- ADD RB & RA ,将结果写入 RA\n- 将 RA 的值存到 RAM 的 13 地址\n\n<img src=\"http://47.103.65.182/markdown/077.png\">\n\n### 增加一些指令\n\n<img src=\"http://47.103.65.182/markdown/078.png\">\n\n负数跳是通过 ALU 的标志位实现的\n\n<img src=\"http://47.103.65.182/markdown/079.png\">\n\n没有 halt,cpu 就会继续执行下去,由于 0 不是指令所以电脑会崩,因为指令和数据都放在内存里,他们在根本上没有区别,都是二进制数,所以 halt 很重要,能区分指令和数据\n\n### 循环的指令\n\n- RAM14 LOAD RA\n- RAM15 LOAD RB\n- ADD RB & RA into RA\n- JUMP 2 =>INST.ADDR.REGISTER change into 2=> EXECUTE RAM2 INST\n- ADD RB & RA into RA\n- JUMP 2 =>INST.ADDR.REGISTER change into 2=> EXECUTE RAM2 INST\n- ...\n\n(INFINITE LOOP)\n\n<img src=\"http://47.103.65.182/markdown/080.png\">\n\n### 有条件的循环\n\n<img src=\"http://47.103.65.182/markdown/081.png\">\n\n- RAM14 LOAD RA\n- RAM15 LOAD RB\n- SUB RA - RB into RA 11-5=6>0\n- JUMP_NEG 5 => ALU RESULT >0 =>don't EXECUTE\n- JUMP 2=>INST.ADDR.REGISTER change into 2=> EXECUTE RAM2 INST\n- SUB RB RA into RA into RA 6-5=1>0\n- JUMP_NEG 5 => ALU RESULT >0 =>don't EXECUTE\n- JUMP 2=>INST.ADDR.REGISTER change into 2=> EXECUTE RAM2 INST\n- SUB RA - RB into RA 1-5=-4>0\n- JUMP_NEG 5 => ALU RESULT <0 =>INST.ADDR.REGISTER change into 5=> EXECUTE RAM5 INST\n- ADD RB & RA into RA\n- STORE RA into RAM 13\n- HALT (结束)\n\nALU 没有除法,但是我们可以通过程序来实现,\n\n### 增加指令数量\n\n我们的指令使用 4bit 来表示,所以最多也就 16 条指令,\n\n增加指令有两种方法\n\n- 增加指令的位,即增加 INSTRUCTION LENGTH (指令长度)\n- 使用 VARIABLE LENGTH 　 INSTRUCTION 　（可变指令长度）HALT 立即执行 JUMP 看此参数,因此指令的位数可以不同,只要能保证功能即可\n\n\n## 三十三、cryptography\n\n### [模运算](https://www.cnblogs.com/jojoke/archive/2007/12/17/1003594.html)\n\n很多地方用到模运算，这里说明模运算的一些规律，并加以证明。 后续会对这些理论实际的应用加以记录和说明。\n\n1. 模运算是取余运算(记做 % 或者 mod)，具有周期性的特点。 m%n 的意思是 n 除 m 后的余数， 当 m 递增时 m%n 呈现周期性特点， 并且 n 越大，周期越长，周期等于 n。\n   例如\n   0 % 20 = 0，1 % 20 = 1， 2 % 20 = 2， 3 % 20 = 3， ...， 19 % 20 = 19\n   20 % 20 = 0，21 % 20 = 1，22 % 20 = 2，23 % 20 = 3， ...，39 % 20 = 19\n2. 如果 m % n = r，那么可以推出如下等式\n   m = k \\* n + r (k 为大于等于 0 的整数， r <= m）\n3. 同余式， 表示正整数 a，b 对 n 取模，它们的余数相同，记做 a ≡ b mod n 或者 a = b (mod n)。\n   根据 2 的等式可以推出 a = kn + b 或者 a - b = kn\n   证明： ∵ a = k1 _ n + r1\n   b = k2 _ n + r2\n   ∴ a - b = (k1 - k2) _ n + (r1 - r2)\n   a = k _ n + (r1 - r2) + b\n   ∵ a, b 对 n 取模同余，r1 = r2\n   ∴ a = k \\* n + b (k = k1 - k2)\n4. 模运算规则， 模运算与基本四则运算有些相似，但是除法例外。其规则如下\n\n```\n           \t(a + b) % n = (a % n + b % n) % n      （1）\n              (a - b) % n = (a % n - b % n) % n      （2）\n              (a * b) % n = (a % n * b % n) % n      （3）\n              a^b % n = ((a % n)b) % n           （4）\n```\n\n（1）式证明\n\n```\n∵ a = k1*n + r1\n\n  b = k2*n + r2\n\n a % n = r1\n\n b % n = r2\n\n∴(a+b) % n = ((k1+k2)*n + (r1+r2)) % n = (r1+r2) % n = (a % n + b % n)% n\n```\n\n（2）式证明同上\n\n```\n\n```\n\n（3）式证明\n\n```\n\n   a = k1*n + r1\n   b = k2*n + r2\n   (a*b) % n = (k1k2n2 + (k1r2+k2r1)n + r1r2) % n = r1r2 % n = (a %n * b %n ) % n\n```\n\n(4)式证明\n\n```\n   设 a % n = r\n   ab %n= (a * a * a * a…*a) %n = (a %n * a %n * a %n * … * a %n) %n = rb % n = ((a % n) b) % n\n\n```\n\n模运算看起来不是很直观，但是可以用来推导出一些有用的东西。 例如（4）式可以用来降幂运算，例如计算 6265 % 133,直接计算的话需要算出 6265 利用（4）式可以进行降幂运算。\n\n### Diffie-Hellman 算法\n\nhttps://www.cnblogs.com/math/p/9383231.html\n\n[离散对数](https://baike.baidu.com/item/离散对数)：定义素数 p 的原始根是能生成 1-(p-1)之间所有数的一个数，设 a 为 p 的原始根，则：a mod p，a^2^ mod p，…，a^(p-1)^ mod p 是各不相同的整数，且以某种排列方式组成了从 1 到 p-1 的所有整数。对于任意数 b 及素数 p 的原始根 a，可以找到一个唯一的指数 i，满足：b= a ^i^ mod p，其中 0≤i≤p-1，那么指数 i 称为 b 的以 a 为基数的模 p 的离散对数。\n\nDiffie-Hellman 算法的有效性依赖于计算离散对数的难度，其含义是：当已知大素数 p 和它的一个原根 a 后，对于给定的 b，要计算出 i 被认为是很困难的，而给定 i 计算 b 却相对容易。\n\n假设网络上有两个用户 A 和 B，彼此之间协商共同的密码，算法过程如图 1 所示 。\n\n假设交换密钥的值为 k 。\n\n(1)A 和 B 事先约好大素数 p 和它的原始根 a；\n\n(2)A 随机产生一个数 x，计算 X=a^x^ mod p，然后把 X 发给 B；\n\n3)B 随机产生一个数 y，计算 Y=a^y^mod p，然后把 Y 发给 A；\n\n(4)A 计算 k=Y^x^mod p；\n\n(5)B 计算 k' = X^y^mod p;\n\n因为 k=Y^x^mod p = (a^y^mod p)^x^ mod p = (a^y^)^x^ mod p = (a^x^)^y^ mod p = (a^x^mod p)^y^ mod p = X^y^mod p = k'\n\n不安全网络上的窃听者只能得到 a、p、X、Y，除非能计算离散对数 x 和 y，否则将无法得到密钥 k，但对于大素数 p，计算离散对数是十分困难的，因此 k 为用户 A 和 B 独立计算出的密钥。\n\n扩展资料\n\n- [Crash Course 字幕组](https://crashcourse.club/)\n- [Crash Course 官方](https://www.patreon.com/crashcourse)\n","source":"_posts/计算机概论.md","raw":"---\ntitle: 计算机概论\ntype: \"tags\"\ntags:\n  - 计算机概论\ncategories: 计算机基础\n---\n\n> 参考资料\n\n[Crash Course 计算机视频](https://www.bilibili.com/video/av21376839?p=1)\n\n## 一、计算机的早期历史\n\n美索不达米亚 1000 BC 算盘\n\n| time          | area                         | Instance                   | 进制 |\n| ------------- | ---------------------------- | -------------------------- | ---- |\n| 1000BC        | 美索不达米亚                 | 算盘                       | 10   |\n| 1694          | 德国                         | 步进计算器                 | 10   |\n| before 20 C   | world                        | 计算表                     |      |\n| 1822          | 英国（Charles Babbage）      | 差分机（论文）             |      |\n| 1822-1842     | 英国(Charles Babbage)        | 分析机（general computer） |      |\n| 18X（8\\|9）？ | 美国（Hollerith IBM 创始人） | 打孔卡片制表机             |      |\n\nAda Lovelace 给分析机写了假象程序(第一程序员)\n\nCharles Babbage 设计了分析机，即通用计算机 （计算机之父）\n\n<!--more-->\n\n## 二、电子计算机\n\n机械继电器（开关），利用电磁线圈的磁场把开关吸下来，联通电路\n\n二极管 （首先出现为热电子管）\n\n三级真空管（二代继电器），每秒客开闭千次\n\n1947 贝尔实验室 晶体管（半导体材料继电器），每秒万次开闭，加州硅谷，出现仙童半导体公司，仙童来变成了英特尔，目前的晶体管体积 50 纳米，每秒上百万次开闭，工作几十年，\n\n| time    | area           | instance | person        | remarks                                   |\n| ------- | -------------- | -------- | ------------- | ----------------------------------------- |\n| 1944    | IBM            | Mark II  | IBM           | 1947 pulled a bug                         |\n| 1943.12 | 英国 Bletchley | Mark I   | Tommy Flowers | 大规模使用真空管(1600)，可编程，解密 Nazi |\n| 1941    | 英国 Bletchley | Bombe    | Alan Turing   | designd to break Enigma code              |\n| 1946    | 美             | ENIAC    | Pennsylvania  | 积分，真正意义电子计算机                  |\n| 1958    | 美             | IBM608   | IBM           | 使用晶体管                                |\n\n## 三、布尔逻辑与逻辑门\n\n### [布尔代数](http://www.ruanyifeng.com/blog/2016/08/boolean-algebra.html)\n\n关于真值的逻辑运算称为布尔代数（Boolean Algebra），以它的创始人布尔命名。\n\n在编程语言中表示 T 值和 F 值的数据类型叫做布尔类型，在 C 语言中通常用`int`类型来表示，非 0 表示 T，0 表示 F。布尔逻辑是写程序的基本功之一，程序中的很多错误都可以归因于逻辑错误。\n\n```\n以下是一些布尔代数的基本定理，为了简洁易读，T和F用1和0表示，AND用*号表示，OR用+号表示（从真值表可以看出AND和OR运算确实有些类似*和+），NOT用¬表示，x、y、z的值可能是0也可能是1。\n```\n\n```\n¬¬x=x\n\nx*0=0\nx+1=1\n\nx*1=x\nx+0=x\n\nx*x=x\nx+x=x\n\nx*¬x=0\nx+¬x=1\n\nx*y=y*x\nx+y=y+x\n\nx*(y*z)=(x*y)*z\nx+(y+z)=(x+y)+z\n\nx*(y+z)=x*y+x*z\nx+y*z=(x+y)*(x+z)\n\nx+x*y=x\nx*(x+y)=x\n\nx*y+x*¬y=x\n(x+y)*(x+¬y)=x\n\n¬(x*y)=¬x+¬y\n¬(x+y)=¬x*¬y\n\nx+¬x*y=x+y\nx*(¬x+y)=x*y\n\nx*y+¬x*z+y*z=x*y+¬x*z\n(x+y)*(¬x+z)*(y+z)=(x+y)*(¬x+z)\n\n除了第1行之外，这些公式都是每两行一组的，每组的两个公式就像对联一样：把其中一个公式中的*换成+、+换成*、0换成1、1换成0，就变成了与它对称的另一个公式。这些定理都可以通过真值表证明\n```\n\n### 逻辑门 and or not xor\n\n[逻辑门的晶体管实现](https://www.cnblogs.com/sunshine-jackie/p/8137240.html)\n\nVDD 就是电源的意思\n\n#### and\n\n| true  | true  | true  |\n| ----- | ----- | ----- |\n| true  | false | false |\n| false | true  | false |\n| false | false | false |\n\n#### or\n\n| true  | true  | true  |\n| ----- | ----- | ----- |\n| true  | false | true  |\n| false | true  | true  |\n| false | false | false |\n\n#### not\n\n| true  | false |\n| ----- | ----- |\n| false | true  |\n\n#### xor\n\n| true  | true  | false |\n| ----- | ----- | ----- |\n| true  | false | true  |\n| false | true  | true  |\n| false | false | false |\n\n## 四、二进制\n\n### 二进制，逢二进一\n\n| 2^7^ | 2^6^ | 2^5^ | 2^4^ | 2^3^ | 2^2^ | 2^1^ | 2^0^ |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 1    | 0    | 1    | 1    | 0    | 1    | 0    | 0    |\n\n二进制中，\n\n一个 0 或 1 表示一位（1bit）\n\n8bit = 1byte(字节)\n\n1kb = 2^10^ byte = 1024 byte\n\n#### 数字表示\n\n##### 整数\n\n0 000 0000 0000 0000 0000 0000 0000 0000\n\n首位表示正负（sign）其余为数值\n\n##### 浮点数\n\n0 000 0000 0 000 0000 0000 0000 0000 0000\n\n浮点数是将科学计数法的数字进行存储，首位表示正负（sign）接下来八位 表示指数，剩下的 23 位表示有效位数\n\n例如\n\n153446631161563 的科学计数法表示 0.153446631161563 x 10^15^\n\n它的浮点数如下 4 字节的浮点数精度损失还是比较大\n\n0 000 0111 1 100 0101 1100 0111 1000 1001‬\n\n#### 字符的表示\n\n字符表示最简单的方法就是给字母一个编号，就有了 ASCII\n\n为了表示 the world 的所有字符，后来就出现了 Unicode 和 ISO，之后他们俩兼容了，现在常用的编码实现位 utf-8,它是一种可变长的编码，<a href=\"#####utf-8\">utf-8 编码规则</a>\n\n##### unicode\n\n```\n正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。\n\n可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。\n\nUnicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。\n```\n\n##### unicode 的问题\n\n```\n需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n\n比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n\n这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n\n它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。\n```\n\n##### utf-8\n\n```\n互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。\n\nUTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n\nUTF-8 的编码规则很简单，只有二条：\n\n1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。\n\n2）对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。\n\n下表总结了编码规则，字母x表示可用编码的位。\n\n```\n\n| Unicode 符号范围(十六进制) | UTF-8 编码方式（二进制）            |\n| -------------------------- | ----------------------------------- |\n| 0000 0000-0000 007F        | 0xxxxxxx                            |\n| 0000 0080-0000 07FF        | 110xxxxx 10xxxxxx                   |\n| 0000 0800-0000 FFFF        | 1110xxxx 10xxxxxx 10xxxxxx          |\n| 0001 0000-0010 FFFF        | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |\n\n```\n跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。\n\n下面，还是以汉字严为例，演示如何实现 UTF-8 编码。\n\n严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。\n```\n\n引用\n\n[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n\n#### 字节序小知识\n\n<img src=\"http://47.103.65.182/markdown/104.png\">\n\n## 五、算数逻辑单元 ALU (Arithmetic & Logic Unit)\n\nHow Computer Calculate ——the ALU\n\n### 计算单元\n\n#### 加法实现\n\n##### a half adder\n\n进行 1bit 运算\n\n<img src=\"http://47.103.65.182/markdown/040.png\">\n\n##### 全加器\n\nfull adder 使用两个 half adder 实现\n\n<img src=\"http://47.103.65.182/markdown/041.png\">\n\n##### 8bit adder\n\n<img src=\"http://47.103.65.182/markdown/042.png\">\n\n<img src=\"http://47.103.65.182/markdown/043.png\">\n\n### 逻辑单元\n\n布尔运算 and or not xor\n\n对输入的信号，进行逻辑运算，结果符合真值表\n\n#### ALU 抽象\n\n<img src=\"http://47.103.65.182/markdown/044.png\">\n\n## 六、寄存器和内存（Registers & RAM）\n\nRAM : Random Access Memory\n\nPM : Persistent Memory\n\n存储 1bit 数据\n\n### sava 1\n\n就或门输出与输入链接，可以形成一个 1 的永久存储\n\n<img src=\"http://47.103.65.182/markdown/045.png\">\n\n### sava 0\n\n将与门输出与输入连接，可以形成一个 0 的永久存储\n\n<img src=\"http://47.103.65.182/markdown/046.png\">\n\n### 锁存（AND-OR LATCH）\n\n将上述两个电路结合起来就做成了一个锁存器\n\n<img src=\"http://47.103.65.182/markdown/047.png\">\n\nset 设为 1 后，无论 set 如何改变，输出一直为 1，即 set 将状态置为 1\n\nreset 设为 1 后，无论 reset 如何改变，输出一直为 0，即 reset 将状态置为 0\n\nset 和 reset 都为 0 的话，锁存器将会保存最后设置的状态，1bit 的记忆功能就实现了，记忆的结果取决于最后关闭的是谁\n\n### 门锁（GATED LATCH）\n\n1bit 的可控制写入存储\n\n<img src=\"http://47.103.65.182/markdown/048.png\">\n\n允许写入线为 0 时，set,reset 恒为 0,不可写入，允许写入线为 1 时，输入 0 将 reset 锁存，输入 1 将 set 锁存\n\n#### 抽象出门锁组件\n\n<img src=\"http://47.103.65.182/markdown/049.png\">\n\n### 寄存器 register\n\nA group of lanches operating like this is called a **register** ,which hlod a single number , and the number of bits in a register is called its width.\n\n寄存器是[CPU](https://baike.baidu.com/item/CPU/120556)内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。寄存器的存储电路是由锁存器或触发器构成的，因为一个锁存器或触发器能存储 1 位二进制数，所以由 N 个[锁存器](https://baike.baidu.com/item/锁存器/10801965)或触发器可以构成 N 位寄存器。寄存器是中央处理器内的组成部分。寄存器是有限存储容量的高速存储部件，它们可用来暂存指令\n\n<img src=\"http://47.103.65.182/markdown/050.png\">\n\n16x16 门锁矩阵\n\n更大位的寄存器\n\n<img src=\"http://47.103.65.182/markdown/051.png\">\n\n启用某个门锁的方式位激活相应的排线和列线\n\n<img src=\"http://47.103.65.182/markdown/052.png\">\n\n在允许写入线前加一个**与门**，与行线和列线相连，就可以具体指向某个锁存\n\n<img src=\"http://47.103.65.182/markdown/054.png\">\n\n启用行列线，再**启用写入操作线**，就可以操作这个锁存，再因为没有行列线的锁存是关闭启用写入线，所以写入操作线就算公用的（1 条线连所有），也可以做到针对某个锁存操作，\n\n<img src=\"http://47.103.65.182/markdown/055.png\">\n\n启用行列线，再启用**读取操作线**，就可以打开门锁输出线的晶体管（应该是吧），启用数据输入输出线，就可以**读取到这个锁存的输出**\n\n<img src=\"http://47.103.65.182/markdown/057.png\">\n\n启用行列线，再启用**写入操作线**，就可以开启此所存的写入操作，此时操作**数据输入输出线**，可以设置锁存的值\n\n<img src=\"http://47.103.65.182/markdown/056.png\">\n\n### 地址\n\n如何表示操作的是哪个锁存，（我们任是使用 16x16 门锁矩阵）\n\n4bit 可以表示 16 个数字（0-15），8 个 bit 就可以表示一个地址（行，列）\n\n例如 3 行 10 列（0011，1010）\n\n#### 多路复用器(multiplexer)\n\n为了将行和列转换为地址，我们需要多路复用器(multiplexer)\n\n<img src=\"http://47.103.65.182/markdown/058.png\">\n\n#### 内存（memory）\n\n<img src=\"http://47.103.65.182/markdown/059.png\">\n\n#### 静态随机地址存储（SRAM）\n\n存储 8bit 数据的方式，8 个比特位用相同的地址分别存储\n\n<img src=\"http://47.103.65.182/markdown/060.png\">\n\n\n\n这个是一个 SRAM （static random access memory）\n\n把这个内存单元，看成拥有 256 个地址，每个地址能读写一个 8bit 值，这就是 RAM\n\n<img src=\"http://47.103.65.182/markdown/061.png\">\n\n## 七、The Center Processing Unit\n\n### 基础组件\n\n<img src=\"http://47.103.65.182/markdown/063.png\">\n\n### 指令表\n\n<img src=\"http://47.103.65.182/markdown/062.png\">\n\n### cpu 基本架构\n\n我们还需要两个寄存器来完成 CPU，一个用来存储指令地址（本例是 RAM），一个用来存储指令\n\n<img src=\"http://47.103.65.182/markdown/064.png\">\n\n### cpu 执行流程\n\n1.启动计算机，所有寄存器从零开始\n\n<img src=\"http://47.103.65.182/markdown/065.png\">\n\n2.为了举例我们在 RAM 放了一个程序\n\n#### 取指令 FETCH PHASE\n\ncpu 的第一个阶段叫做`取指令阶段`FETCH PHASE ,负责拿到指令\n\n- 指令地址寄存器连到 RAM，此时寄存器地址为０,因此 RAM 返回地址 0 的值,值会复制到指令寄存器里\n\n<img src=\"http://47.103.65.182/markdown/067.png\">\n\n#### 解码指令 DECODE FHASE\n\ncpu 的第二个阶段叫做`解码阶段`DECODE FHASE,负责解析出要执行什么指令\n\n<img src=\"http://47.103.65.182/markdown/068.png\">\n\n在我们定义的指令中,一个 8 位值,前 4 位代表指令,后 4 位代表参数;对于指令寄存器的值我们需要使用一个控制单元来进行解码\n\n- 检查指令是不是 LOAD_A,我们可以用很少的逻辑门实现\n\n<img src=\"http://47.103.65.182/markdown/069.png\">\n\n#### 执行指令 EXECUTE FHASE\n\n知道了是什么指令,我们就可以进入执行阶段\n\n<img src=\"http://47.103.65.182/markdown/070.png\">\n\n- 电路的连接保证 LOAD_A 正确执行\n\n<img src=\"http://47.103.65.182/markdown/071.png\">\n\n- 关闭电路,指令地址寄存器+1\n\n<img src=\"http://47.103.65.182/markdown/072.png\">\n\n### 控制单元\n\n分析完一个指令后,其他的指令也是类似的情况,所以将所有指令封装成一个控制单元\n\n<img src=\"http://47.103.65.182/markdown/073.png\">\n\n- 对于 ADD 指令我们需要使用 ALU\n\n<img src=\"http://47.103.65.182/markdown/074.png\">\n\n- 始终以精确的间隔触发电信号,控制单元会利用这个信号,推进 cpu 的内部操作,确保一切按步骤进行,cpu\"取指令-->解码-->执行\"的速度叫\"时钟速度(CLOCK SPEED)\"\n\n<img src=\"http://47.103.65.182/markdown/075.png\">\n\n### CPU \n\n<img src=\"http://47.103.65.182/markdown/076.png\">\n\n## 八、指令和程序(Instruction&Programs)\n\ncpu 之所以强大,是因为它是可编程的,写入不同的指令就会执行不同的任务,CPU 是一个可以被软件控制的硬件\n\n这是上一节的例子,四个指令形成了一个加法的操作\n\n- RAM 地址 14 的值 加载到 RA\n- RAM 地址 15 的值加载到 RB\n- ADD RB & RA ,将结果写入 RA\n- 将 RA 的值存到 RAM 的 13 地址\n\n<img src=\"http://47.103.65.182/markdown/077.png\">\n\n### 增加一些指令\n\n<img src=\"http://47.103.65.182/markdown/078.png\">\n\n负数跳是通过 ALU 的标志位实现的\n\n<img src=\"http://47.103.65.182/markdown/079.png\">\n\n没有 halt,cpu 就会继续执行下去,由于 0 不是指令所以电脑会崩,因为指令和数据都放在内存里,他们在根本上没有区别,都是二进制数,所以 halt 很重要,能区分指令和数据\n\n### 循环的指令\n\n- RAM14 LOAD RA\n- RAM15 LOAD RB\n- ADD RB & RA into RA\n- JUMP 2 =>INST.ADDR.REGISTER change into 2=> EXECUTE RAM2 INST\n- ADD RB & RA into RA\n- JUMP 2 =>INST.ADDR.REGISTER change into 2=> EXECUTE RAM2 INST\n- ...\n\n(INFINITE LOOP)\n\n<img src=\"http://47.103.65.182/markdown/080.png\">\n\n### 有条件的循环\n\n<img src=\"http://47.103.65.182/markdown/081.png\">\n\n- RAM14 LOAD RA\n- RAM15 LOAD RB\n- SUB RA - RB into RA 11-5=6>0\n- JUMP_NEG 5 => ALU RESULT >0 =>don't EXECUTE\n- JUMP 2=>INST.ADDR.REGISTER change into 2=> EXECUTE RAM2 INST\n- SUB RB RA into RA into RA 6-5=1>0\n- JUMP_NEG 5 => ALU RESULT >0 =>don't EXECUTE\n- JUMP 2=>INST.ADDR.REGISTER change into 2=> EXECUTE RAM2 INST\n- SUB RA - RB into RA 1-5=-4>0\n- JUMP_NEG 5 => ALU RESULT <0 =>INST.ADDR.REGISTER change into 5=> EXECUTE RAM5 INST\n- ADD RB & RA into RA\n- STORE RA into RAM 13\n- HALT (结束)\n\nALU 没有除法,但是我们可以通过程序来实现,\n\n### 增加指令数量\n\n我们的指令使用 4bit 来表示,所以最多也就 16 条指令,\n\n增加指令有两种方法\n\n- 增加指令的位,即增加 INSTRUCTION LENGTH (指令长度)\n- 使用 VARIABLE LENGTH 　 INSTRUCTION 　（可变指令长度）HALT 立即执行 JUMP 看此参数,因此指令的位数可以不同,只要能保证功能即可\n\n\n## 三十三、cryptography\n\n### [模运算](https://www.cnblogs.com/jojoke/archive/2007/12/17/1003594.html)\n\n很多地方用到模运算，这里说明模运算的一些规律，并加以证明。 后续会对这些理论实际的应用加以记录和说明。\n\n1. 模运算是取余运算(记做 % 或者 mod)，具有周期性的特点。 m%n 的意思是 n 除 m 后的余数， 当 m 递增时 m%n 呈现周期性特点， 并且 n 越大，周期越长，周期等于 n。\n   例如\n   0 % 20 = 0，1 % 20 = 1， 2 % 20 = 2， 3 % 20 = 3， ...， 19 % 20 = 19\n   20 % 20 = 0，21 % 20 = 1，22 % 20 = 2，23 % 20 = 3， ...，39 % 20 = 19\n2. 如果 m % n = r，那么可以推出如下等式\n   m = k \\* n + r (k 为大于等于 0 的整数， r <= m）\n3. 同余式， 表示正整数 a，b 对 n 取模，它们的余数相同，记做 a ≡ b mod n 或者 a = b (mod n)。\n   根据 2 的等式可以推出 a = kn + b 或者 a - b = kn\n   证明： ∵ a = k1 _ n + r1\n   b = k2 _ n + r2\n   ∴ a - b = (k1 - k2) _ n + (r1 - r2)\n   a = k _ n + (r1 - r2) + b\n   ∵ a, b 对 n 取模同余，r1 = r2\n   ∴ a = k \\* n + b (k = k1 - k2)\n4. 模运算规则， 模运算与基本四则运算有些相似，但是除法例外。其规则如下\n\n```\n           \t(a + b) % n = (a % n + b % n) % n      （1）\n              (a - b) % n = (a % n - b % n) % n      （2）\n              (a * b) % n = (a % n * b % n) % n      （3）\n              a^b % n = ((a % n)b) % n           （4）\n```\n\n（1）式证明\n\n```\n∵ a = k1*n + r1\n\n  b = k2*n + r2\n\n a % n = r1\n\n b % n = r2\n\n∴(a+b) % n = ((k1+k2)*n + (r1+r2)) % n = (r1+r2) % n = (a % n + b % n)% n\n```\n\n（2）式证明同上\n\n```\n\n```\n\n（3）式证明\n\n```\n\n   a = k1*n + r1\n   b = k2*n + r2\n   (a*b) % n = (k1k2n2 + (k1r2+k2r1)n + r1r2) % n = r1r2 % n = (a %n * b %n ) % n\n```\n\n(4)式证明\n\n```\n   设 a % n = r\n   ab %n= (a * a * a * a…*a) %n = (a %n * a %n * a %n * … * a %n) %n = rb % n = ((a % n) b) % n\n\n```\n\n模运算看起来不是很直观，但是可以用来推导出一些有用的东西。 例如（4）式可以用来降幂运算，例如计算 6265 % 133,直接计算的话需要算出 6265 利用（4）式可以进行降幂运算。\n\n### Diffie-Hellman 算法\n\nhttps://www.cnblogs.com/math/p/9383231.html\n\n[离散对数](https://baike.baidu.com/item/离散对数)：定义素数 p 的原始根是能生成 1-(p-1)之间所有数的一个数，设 a 为 p 的原始根，则：a mod p，a^2^ mod p，…，a^(p-1)^ mod p 是各不相同的整数，且以某种排列方式组成了从 1 到 p-1 的所有整数。对于任意数 b 及素数 p 的原始根 a，可以找到一个唯一的指数 i，满足：b= a ^i^ mod p，其中 0≤i≤p-1，那么指数 i 称为 b 的以 a 为基数的模 p 的离散对数。\n\nDiffie-Hellman 算法的有效性依赖于计算离散对数的难度，其含义是：当已知大素数 p 和它的一个原根 a 后，对于给定的 b，要计算出 i 被认为是很困难的，而给定 i 计算 b 却相对容易。\n\n假设网络上有两个用户 A 和 B，彼此之间协商共同的密码，算法过程如图 1 所示 。\n\n假设交换密钥的值为 k 。\n\n(1)A 和 B 事先约好大素数 p 和它的原始根 a；\n\n(2)A 随机产生一个数 x，计算 X=a^x^ mod p，然后把 X 发给 B；\n\n3)B 随机产生一个数 y，计算 Y=a^y^mod p，然后把 Y 发给 A；\n\n(4)A 计算 k=Y^x^mod p；\n\n(5)B 计算 k' = X^y^mod p;\n\n因为 k=Y^x^mod p = (a^y^mod p)^x^ mod p = (a^y^)^x^ mod p = (a^x^)^y^ mod p = (a^x^mod p)^y^ mod p = X^y^mod p = k'\n\n不安全网络上的窃听者只能得到 a、p、X、Y，除非能计算离散对数 x 和 y，否则将无法得到密钥 k，但对于大素数 p，计算离散对数是十分困难的，因此 k 为用户 A 和 B 独立计算出的密钥。\n\n扩展资料\n\n- [Crash Course 字幕组](https://crashcourse.club/)\n- [Crash Course 官方](https://www.patreon.com/crashcourse)\n","slug":"计算机概论","published":1,"date":"2021-07-03T06:10:33.061Z","updated":"2021-07-04T07:59:58.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqoye6hw00239su0h2ijhqks","content":"<blockquote>\n<p>参考资料</p>\n</blockquote>\n<p><a href=\"https://www.bilibili.com/video/av21376839?p=1\">Crash Course 计算机视频</a></p>\n<h2 id=\"一、计算机的早期历史\"><a href=\"#一、计算机的早期历史\" class=\"headerlink\" title=\"一、计算机的早期历史\"></a>一、计算机的早期历史</h2><p>美索不达米亚 1000 BC 算盘</p>\n<table>\n<thead>\n<tr>\n<th>time</th>\n<th>area</th>\n<th>Instance</th>\n<th>进制</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1000BC</td>\n<td>美索不达米亚</td>\n<td>算盘</td>\n<td>10</td>\n</tr>\n<tr>\n<td>1694</td>\n<td>德国</td>\n<td>步进计算器</td>\n<td>10</td>\n</tr>\n<tr>\n<td>before 20 C</td>\n<td>world</td>\n<td>计算表</td>\n<td></td>\n</tr>\n<tr>\n<td>1822</td>\n<td>英国（Charles Babbage）</td>\n<td>差分机（论文）</td>\n<td></td>\n</tr>\n<tr>\n<td>1822-1842</td>\n<td>英国(Charles Babbage)</td>\n<td>分析机（general computer）</td>\n<td></td>\n</tr>\n<tr>\n<td>18X（8|9）？</td>\n<td>美国（Hollerith IBM 创始人）</td>\n<td>打孔卡片制表机</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>Ada Lovelace 给分析机写了假象程序(第一程序员)</p>\n<p>Charles Babbage 设计了分析机，即通用计算机 （计算机之父）</p>\n<span id=\"more\"></span>\n\n<h2 id=\"二、电子计算机\"><a href=\"#二、电子计算机\" class=\"headerlink\" title=\"二、电子计算机\"></a>二、电子计算机</h2><p>机械继电器（开关），利用电磁线圈的磁场把开关吸下来，联通电路</p>\n<p>二极管 （首先出现为热电子管）</p>\n<p>三级真空管（二代继电器），每秒客开闭千次</p>\n<p>1947 贝尔实验室 晶体管（半导体材料继电器），每秒万次开闭，加州硅谷，出现仙童半导体公司，仙童来变成了英特尔，目前的晶体管体积 50 纳米，每秒上百万次开闭，工作几十年，</p>\n<table>\n<thead>\n<tr>\n<th>time</th>\n<th>area</th>\n<th>instance</th>\n<th>person</th>\n<th>remarks</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1944</td>\n<td>IBM</td>\n<td>Mark II</td>\n<td>IBM</td>\n<td>1947 pulled a bug</td>\n</tr>\n<tr>\n<td>1943.12</td>\n<td>英国 Bletchley</td>\n<td>Mark I</td>\n<td>Tommy Flowers</td>\n<td>大规模使用真空管(1600)，可编程，解密 Nazi</td>\n</tr>\n<tr>\n<td>1941</td>\n<td>英国 Bletchley</td>\n<td>Bombe</td>\n<td>Alan Turing</td>\n<td>designd to break Enigma code</td>\n</tr>\n<tr>\n<td>1946</td>\n<td>美</td>\n<td>ENIAC</td>\n<td>Pennsylvania</td>\n<td>积分，真正意义电子计算机</td>\n</tr>\n<tr>\n<td>1958</td>\n<td>美</td>\n<td>IBM608</td>\n<td>IBM</td>\n<td>使用晶体管</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、布尔逻辑与逻辑门\"><a href=\"#三、布尔逻辑与逻辑门\" class=\"headerlink\" title=\"三、布尔逻辑与逻辑门\"></a>三、布尔逻辑与逻辑门</h2><h3 id=\"布尔代数\"><a href=\"#布尔代数\" class=\"headerlink\" title=\"布尔代数\"></a><a href=\"http://www.ruanyifeng.com/blog/2016/08/boolean-algebra.html\">布尔代数</a></h3><p>关于真值的逻辑运算称为布尔代数（Boolean Algebra），以它的创始人布尔命名。</p>\n<p>在编程语言中表示 T 值和 F 值的数据类型叫做布尔类型，在 C 语言中通常用<code>int</code>类型来表示，非 0 表示 T，0 表示 F。布尔逻辑是写程序的基本功之一，程序中的很多错误都可以归因于逻辑错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下是一些布尔代数的基本定理，为了简洁易读，T和F用1和0表示，AND用*号表示，OR用+号表示（从真值表可以看出AND和OR运算确实有些类似*和+），NOT用¬表示，x、y、z的值可能是0也可能是1。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">¬¬x=x</span><br><span class=\"line\"></span><br><span class=\"line\">x*0=0</span><br><span class=\"line\">x+1=1</span><br><span class=\"line\"></span><br><span class=\"line\">x*1=x</span><br><span class=\"line\">x+0=x</span><br><span class=\"line\"></span><br><span class=\"line\">x*x=x</span><br><span class=\"line\">x+x=x</span><br><span class=\"line\"></span><br><span class=\"line\">x*¬x=0</span><br><span class=\"line\">x+¬x=1</span><br><span class=\"line\"></span><br><span class=\"line\">x*y=y*x</span><br><span class=\"line\">x+y=y+x</span><br><span class=\"line\"></span><br><span class=\"line\">x*(y*z)=(x*y)*z</span><br><span class=\"line\">x+(y+z)=(x+y)+z</span><br><span class=\"line\"></span><br><span class=\"line\">x*(y+z)=x*y+x*z</span><br><span class=\"line\">x+y*z=(x+y)*(x+z)</span><br><span class=\"line\"></span><br><span class=\"line\">x+x*y=x</span><br><span class=\"line\">x*(x+y)=x</span><br><span class=\"line\"></span><br><span class=\"line\">x*y+x*¬y=x</span><br><span class=\"line\">(x+y)*(x+¬y)=x</span><br><span class=\"line\"></span><br><span class=\"line\">¬(x*y)=¬x+¬y</span><br><span class=\"line\">¬(x+y)=¬x*¬y</span><br><span class=\"line\"></span><br><span class=\"line\">x+¬x*y=x+y</span><br><span class=\"line\">x*(¬x+y)=x*y</span><br><span class=\"line\"></span><br><span class=\"line\">x*y+¬x*z+y*z=x*y+¬x*z</span><br><span class=\"line\">(x+y)*(¬x+z)*(y+z)=(x+y)*(¬x+z)</span><br><span class=\"line\"></span><br><span class=\"line\">除了第1行之外，这些公式都是每两行一组的，每组的两个公式就像对联一样：把其中一个公式中的*换成+、+换成*、0换成1、1换成0，就变成了与它对称的另一个公式。这些定理都可以通过真值表证明</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"逻辑门-and-or-not-xor\"><a href=\"#逻辑门-and-or-not-xor\" class=\"headerlink\" title=\"逻辑门 and or not xor\"></a>逻辑门 and or not xor</h3><p><a href=\"https://www.cnblogs.com/sunshine-jackie/p/8137240.html\">逻辑门的晶体管实现</a></p>\n<p>VDD 就是电源的意思</p>\n<h4 id=\"and\"><a href=\"#and\" class=\"headerlink\" title=\"and\"></a>and</h4><table>\n<thead>\n<tr>\n<th>true</th>\n<th>true</th>\n<th>true</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>true</td>\n<td>false</td>\n<td>false</td>\n</tr>\n<tr>\n<td>false</td>\n<td>true</td>\n<td>false</td>\n</tr>\n<tr>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h4 id=\"or\"><a href=\"#or\" class=\"headerlink\" title=\"or\"></a>or</h4><table>\n<thead>\n<tr>\n<th>true</th>\n<th>true</th>\n<th>true</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>true</td>\n<td>false</td>\n<td>true</td>\n</tr>\n<tr>\n<td>false</td>\n<td>true</td>\n<td>true</td>\n</tr>\n<tr>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h4 id=\"not\"><a href=\"#not\" class=\"headerlink\" title=\"not\"></a>not</h4><table>\n<thead>\n<tr>\n<th>true</th>\n<th>false</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>false</td>\n<td>true</td>\n</tr>\n</tbody></table>\n<h4 id=\"xor\"><a href=\"#xor\" class=\"headerlink\" title=\"xor\"></a>xor</h4><table>\n<thead>\n<tr>\n<th>true</th>\n<th>true</th>\n<th>false</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>true</td>\n<td>false</td>\n<td>true</td>\n</tr>\n<tr>\n<td>false</td>\n<td>true</td>\n<td>true</td>\n</tr>\n<tr>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h2 id=\"四、二进制\"><a href=\"#四、二进制\" class=\"headerlink\" title=\"四、二进制\"></a>四、二进制</h2><h3 id=\"二进制，逢二进一\"><a href=\"#二进制，逢二进一\" class=\"headerlink\" title=\"二进制，逢二进一\"></a>二进制，逢二进一</h3><table>\n<thead>\n<tr>\n<th>2^7^</th>\n<th>2^6^</th>\n<th>2^5^</th>\n<th>2^4^</th>\n<th>2^3^</th>\n<th>2^2^</th>\n<th>2^1^</th>\n<th>2^0^</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p>二进制中，</p>\n<p>一个 0 或 1 表示一位（1bit）</p>\n<p>8bit = 1byte(字节)</p>\n<p>1kb = 2^10^ byte = 1024 byte</p>\n<h4 id=\"数字表示\"><a href=\"#数字表示\" class=\"headerlink\" title=\"数字表示\"></a>数字表示</h4><h5 id=\"整数\"><a href=\"#整数\" class=\"headerlink\" title=\"整数\"></a>整数</h5><p>0 000 0000 0000 0000 0000 0000 0000 0000</p>\n<p>首位表示正负（sign）其余为数值</p>\n<h5 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h5><p>0 000 0000 0 000 0000 0000 0000 0000 0000</p>\n<p>浮点数是将科学计数法的数字进行存储，首位表示正负（sign）接下来八位 表示指数，剩下的 23 位表示有效位数</p>\n<p>例如</p>\n<p>153446631161563 的科学计数法表示 0.153446631161563 x 10^15^</p>\n<p>它的浮点数如下 4 字节的浮点数精度损失还是比较大</p>\n<p>0 000 0111 1 100 0101 1100 0111 1000 1001‬</p>\n<h4 id=\"字符的表示\"><a href=\"#字符的表示\" class=\"headerlink\" title=\"字符的表示\"></a>字符的表示</h4><p>字符表示最简单的方法就是给字母一个编号，就有了 ASCII</p>\n<p>为了表示 the world 的所有字符，后来就出现了 Unicode 和 ISO，之后他们俩兼容了，现在常用的编码实现位 utf-8,它是一种可变长的编码，<a href=\"#####utf-8\">utf-8 编码规则</a></p>\n<h5 id=\"unicode\"><a href=\"#unicode\" class=\"headerlink\" title=\"unicode\"></a>unicode</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</span><br><span class=\"line\"></span><br><span class=\"line\">可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</span><br><span class=\"line\"></span><br><span class=\"line\">Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"unicode-的问题\"><a href=\"#unicode-的问题\" class=\"headerlink\" title=\"unicode 的问题\"></a>unicode 的问题</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</span><br><span class=\"line\"></span><br><span class=\"line\">比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</span><br><span class=\"line\"></span><br><span class=\"line\">这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</span><br><span class=\"line\"></span><br><span class=\"line\">它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"utf-8\"><a href=\"#utf-8\" class=\"headerlink\" title=\"utf-8\"></a>utf-8</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</span><br><span class=\"line\"></span><br><span class=\"line\">UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</span><br><span class=\"line\"></span><br><span class=\"line\">UTF-8 的编码规则很简单，只有二条：</span><br><span class=\"line\"></span><br><span class=\"line\">1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</span><br><span class=\"line\"></span><br><span class=\"line\">2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</span><br><span class=\"line\"></span><br><span class=\"line\">下表总结了编码规则，字母x表示可用编码的位。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>Unicode 符号范围(十六进制)</th>\n<th>UTF-8 编码方式（二进制）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0000 0000-0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080-0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800-0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000-0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</span><br><span class=\"line\"></span><br><span class=\"line\">下面，还是以汉字严为例，演示如何实现 UTF-8 编码。</span><br><span class=\"line\"></span><br><span class=\"line\">严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。</span><br></pre></td></tr></table></figure>\n\n<p>引用</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>\n<h4 id=\"字节序小知识\"><a href=\"#字节序小知识\" class=\"headerlink\" title=\"字节序小知识\"></a>字节序小知识</h4><img src=\"http://47.103.65.182/markdown/104.png\">\n\n<h2 id=\"五、算数逻辑单元-ALU-Arithmetic-amp-Logic-Unit\"><a href=\"#五、算数逻辑单元-ALU-Arithmetic-amp-Logic-Unit\" class=\"headerlink\" title=\"五、算数逻辑单元 ALU (Arithmetic &amp; Logic Unit)\"></a>五、算数逻辑单元 ALU (Arithmetic &amp; Logic Unit)</h2><p>How Computer Calculate ——the ALU</p>\n<h3 id=\"计算单元\"><a href=\"#计算单元\" class=\"headerlink\" title=\"计算单元\"></a>计算单元</h3><h4 id=\"加法实现\"><a href=\"#加法实现\" class=\"headerlink\" title=\"加法实现\"></a>加法实现</h4><h5 id=\"a-half-adder\"><a href=\"#a-half-adder\" class=\"headerlink\" title=\"a half adder\"></a>a half adder</h5><p>进行 1bit 运算</p>\n<img src=\"http://47.103.65.182/markdown/040.png\">\n\n<h5 id=\"全加器\"><a href=\"#全加器\" class=\"headerlink\" title=\"全加器\"></a>全加器</h5><p>full adder 使用两个 half adder 实现</p>\n<img src=\"http://47.103.65.182/markdown/041.png\">\n\n<h5 id=\"8bit-adder\"><a href=\"#8bit-adder\" class=\"headerlink\" title=\"8bit adder\"></a>8bit adder</h5><img src=\"http://47.103.65.182/markdown/042.png\">\n\n<img src=\"http://47.103.65.182/markdown/043.png\">\n\n<h3 id=\"逻辑单元\"><a href=\"#逻辑单元\" class=\"headerlink\" title=\"逻辑单元\"></a>逻辑单元</h3><p>布尔运算 and or not xor</p>\n<p>对输入的信号，进行逻辑运算，结果符合真值表</p>\n<h4 id=\"ALU-抽象\"><a href=\"#ALU-抽象\" class=\"headerlink\" title=\"ALU 抽象\"></a>ALU 抽象</h4><img src=\"http://47.103.65.182/markdown/044.png\">\n\n<h2 id=\"六、寄存器和内存（Registers-amp-RAM）\"><a href=\"#六、寄存器和内存（Registers-amp-RAM）\" class=\"headerlink\" title=\"六、寄存器和内存（Registers &amp; RAM）\"></a>六、寄存器和内存（Registers &amp; RAM）</h2><p>RAM : Random Access Memory</p>\n<p>PM : Persistent Memory</p>\n<p>存储 1bit 数据</p>\n<h3 id=\"sava-1\"><a href=\"#sava-1\" class=\"headerlink\" title=\"sava 1\"></a>sava 1</h3><p>就或门输出与输入链接，可以形成一个 1 的永久存储</p>\n<img src=\"http://47.103.65.182/markdown/045.png\">\n\n<h3 id=\"sava-0\"><a href=\"#sava-0\" class=\"headerlink\" title=\"sava 0\"></a>sava 0</h3><p>将与门输出与输入连接，可以形成一个 0 的永久存储</p>\n<img src=\"http://47.103.65.182/markdown/046.png\">\n\n<h3 id=\"锁存（AND-OR-LATCH）\"><a href=\"#锁存（AND-OR-LATCH）\" class=\"headerlink\" title=\"锁存（AND-OR LATCH）\"></a>锁存（AND-OR LATCH）</h3><p>将上述两个电路结合起来就做成了一个锁存器</p>\n<img src=\"http://47.103.65.182/markdown/047.png\">\n\n<p>set 设为 1 后，无论 set 如何改变，输出一直为 1，即 set 将状态置为 1</p>\n<p>reset 设为 1 后，无论 reset 如何改变，输出一直为 0，即 reset 将状态置为 0</p>\n<p>set 和 reset 都为 0 的话，锁存器将会保存最后设置的状态，1bit 的记忆功能就实现了，记忆的结果取决于最后关闭的是谁</p>\n<h3 id=\"门锁（GATED-LATCH）\"><a href=\"#门锁（GATED-LATCH）\" class=\"headerlink\" title=\"门锁（GATED LATCH）\"></a>门锁（GATED LATCH）</h3><p>1bit 的可控制写入存储</p>\n<img src=\"http://47.103.65.182/markdown/048.png\">\n\n<p>允许写入线为 0 时，set,reset 恒为 0,不可写入，允许写入线为 1 时，输入 0 将 reset 锁存，输入 1 将 set 锁存</p>\n<h4 id=\"抽象出门锁组件\"><a href=\"#抽象出门锁组件\" class=\"headerlink\" title=\"抽象出门锁组件\"></a>抽象出门锁组件</h4><img src=\"http://47.103.65.182/markdown/049.png\">\n\n<h3 id=\"寄存器-register\"><a href=\"#寄存器-register\" class=\"headerlink\" title=\"寄存器 register\"></a>寄存器 register</h3><p>A group of lanches operating like this is called a <strong>register</strong> ,which hlod a single number , and the number of bits in a register is called its width.</p>\n<p>寄存器是<a href=\"https://baike.baidu.com/item/CPU/120556\">CPU</a>内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。寄存器的存储电路是由锁存器或触发器构成的，因为一个锁存器或触发器能存储 1 位二进制数，所以由 N 个<a href=\"https://baike.baidu.com/item/%E9%94%81%E5%AD%98%E5%99%A8/10801965\">锁存器</a>或触发器可以构成 N 位寄存器。寄存器是中央处理器内的组成部分。寄存器是有限存储容量的高速存储部件，它们可用来暂存指令</p>\n<img src=\"http://47.103.65.182/markdown/050.png\">\n\n<p>16x16 门锁矩阵</p>\n<p>更大位的寄存器</p>\n<img src=\"http://47.103.65.182/markdown/051.png\">\n\n<p>启用某个门锁的方式位激活相应的排线和列线</p>\n<img src=\"http://47.103.65.182/markdown/052.png\">\n\n<p>在允许写入线前加一个<strong>与门</strong>，与行线和列线相连，就可以具体指向某个锁存</p>\n<img src=\"http://47.103.65.182/markdown/054.png\">\n\n<p>启用行列线，再<strong>启用写入操作线</strong>，就可以操作这个锁存，再因为没有行列线的锁存是关闭启用写入线，所以写入操作线就算公用的（1 条线连所有），也可以做到针对某个锁存操作，</p>\n<img src=\"http://47.103.65.182/markdown/055.png\">\n\n<p>启用行列线，再启用<strong>读取操作线</strong>，就可以打开门锁输出线的晶体管（应该是吧），启用数据输入输出线，就可以<strong>读取到这个锁存的输出</strong></p>\n<img src=\"http://47.103.65.182/markdown/057.png\">\n\n<p>启用行列线，再启用<strong>写入操作线</strong>，就可以开启此所存的写入操作，此时操作<strong>数据输入输出线</strong>，可以设置锁存的值</p>\n<img src=\"http://47.103.65.182/markdown/056.png\">\n\n<h3 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h3><p>如何表示操作的是哪个锁存，（我们任是使用 16x16 门锁矩阵）</p>\n<p>4bit 可以表示 16 个数字（0-15），8 个 bit 就可以表示一个地址（行，列）</p>\n<p>例如 3 行 10 列（0011，1010）</p>\n<h4 id=\"多路复用器-multiplexer\"><a href=\"#多路复用器-multiplexer\" class=\"headerlink\" title=\"多路复用器(multiplexer)\"></a>多路复用器(multiplexer)</h4><p>为了将行和列转换为地址，我们需要多路复用器(multiplexer)</p>\n<img src=\"http://47.103.65.182/markdown/058.png\">\n\n<h4 id=\"内存（memory）\"><a href=\"#内存（memory）\" class=\"headerlink\" title=\"内存（memory）\"></a>内存（memory）</h4><img src=\"http://47.103.65.182/markdown/059.png\">\n\n<h4 id=\"静态随机地址存储（SRAM）\"><a href=\"#静态随机地址存储（SRAM）\" class=\"headerlink\" title=\"静态随机地址存储（SRAM）\"></a>静态随机地址存储（SRAM）</h4><p>存储 8bit 数据的方式，8 个比特位用相同的地址分别存储</p>\n<img src=\"http://47.103.65.182/markdown/060.png\">\n\n\n\n<p>这个是一个 SRAM （static random access memory）</p>\n<p>把这个内存单元，看成拥有 256 个地址，每个地址能读写一个 8bit 值，这就是 RAM</p>\n<img src=\"http://47.103.65.182/markdown/061.png\">\n\n<h2 id=\"七、The-Center-Processing-Unit\"><a href=\"#七、The-Center-Processing-Unit\" class=\"headerlink\" title=\"七、The Center Processing Unit\"></a>七、The Center Processing Unit</h2><h3 id=\"基础组件\"><a href=\"#基础组件\" class=\"headerlink\" title=\"基础组件\"></a>基础组件</h3><img src=\"http://47.103.65.182/markdown/063.png\">\n\n<h3 id=\"指令表\"><a href=\"#指令表\" class=\"headerlink\" title=\"指令表\"></a>指令表</h3><img src=\"http://47.103.65.182/markdown/062.png\">\n\n<h3 id=\"cpu-基本架构\"><a href=\"#cpu-基本架构\" class=\"headerlink\" title=\"cpu 基本架构\"></a>cpu 基本架构</h3><p>我们还需要两个寄存器来完成 CPU，一个用来存储指令地址（本例是 RAM），一个用来存储指令</p>\n<img src=\"http://47.103.65.182/markdown/064.png\">\n\n<h3 id=\"cpu-执行流程\"><a href=\"#cpu-执行流程\" class=\"headerlink\" title=\"cpu 执行流程\"></a>cpu 执行流程</h3><p>1.启动计算机，所有寄存器从零开始</p>\n<img src=\"http://47.103.65.182/markdown/065.png\">\n\n<p>2.为了举例我们在 RAM 放了一个程序</p>\n<h4 id=\"取指令-FETCH-PHASE\"><a href=\"#取指令-FETCH-PHASE\" class=\"headerlink\" title=\"取指令 FETCH PHASE\"></a>取指令 FETCH PHASE</h4><p>cpu 的第一个阶段叫做<code>取指令阶段</code>FETCH PHASE ,负责拿到指令</p>\n<ul>\n<li>指令地址寄存器连到 RAM，此时寄存器地址为０,因此 RAM 返回地址 0 的值,值会复制到指令寄存器里</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/067.png\">\n\n<h4 id=\"解码指令-DECODE-FHASE\"><a href=\"#解码指令-DECODE-FHASE\" class=\"headerlink\" title=\"解码指令 DECODE FHASE\"></a>解码指令 DECODE FHASE</h4><p>cpu 的第二个阶段叫做<code>解码阶段</code>DECODE FHASE,负责解析出要执行什么指令</p>\n<img src=\"http://47.103.65.182/markdown/068.png\">\n\n<p>在我们定义的指令中,一个 8 位值,前 4 位代表指令,后 4 位代表参数;对于指令寄存器的值我们需要使用一个控制单元来进行解码</p>\n<ul>\n<li>检查指令是不是 LOAD_A,我们可以用很少的逻辑门实现</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/069.png\">\n\n<h4 id=\"执行指令-EXECUTE-FHASE\"><a href=\"#执行指令-EXECUTE-FHASE\" class=\"headerlink\" title=\"执行指令 EXECUTE FHASE\"></a>执行指令 EXECUTE FHASE</h4><p>知道了是什么指令,我们就可以进入执行阶段</p>\n<img src=\"http://47.103.65.182/markdown/070.png\">\n\n<ul>\n<li>电路的连接保证 LOAD_A 正确执行</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/071.png\">\n\n<ul>\n<li>关闭电路,指令地址寄存器+1</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/072.png\">\n\n<h3 id=\"控制单元\"><a href=\"#控制单元\" class=\"headerlink\" title=\"控制单元\"></a>控制单元</h3><p>分析完一个指令后,其他的指令也是类似的情况,所以将所有指令封装成一个控制单元</p>\n<img src=\"http://47.103.65.182/markdown/073.png\">\n\n<ul>\n<li>对于 ADD 指令我们需要使用 ALU</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/074.png\">\n\n<ul>\n<li>始终以精确的间隔触发电信号,控制单元会利用这个信号,推进 cpu 的内部操作,确保一切按步骤进行,cpu”取指令–&gt;解码–&gt;执行”的速度叫”时钟速度(CLOCK SPEED)”</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/075.png\">\n\n<h3 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h3><img src=\"http://47.103.65.182/markdown/076.png\">\n\n<h2 id=\"八、指令和程序-Instruction-amp-Programs\"><a href=\"#八、指令和程序-Instruction-amp-Programs\" class=\"headerlink\" title=\"八、指令和程序(Instruction&amp;Programs)\"></a>八、指令和程序(Instruction&amp;Programs)</h2><p>cpu 之所以强大,是因为它是可编程的,写入不同的指令就会执行不同的任务,CPU 是一个可以被软件控制的硬件</p>\n<p>这是上一节的例子,四个指令形成了一个加法的操作</p>\n<ul>\n<li>RAM 地址 14 的值 加载到 RA</li>\n<li>RAM 地址 15 的值加载到 RB</li>\n<li>ADD RB &amp; RA ,将结果写入 RA</li>\n<li>将 RA 的值存到 RAM 的 13 地址</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/077.png\">\n\n<h3 id=\"增加一些指令\"><a href=\"#增加一些指令\" class=\"headerlink\" title=\"增加一些指令\"></a>增加一些指令</h3><img src=\"http://47.103.65.182/markdown/078.png\">\n\n<p>负数跳是通过 ALU 的标志位实现的</p>\n<img src=\"http://47.103.65.182/markdown/079.png\">\n\n<p>没有 halt,cpu 就会继续执行下去,由于 0 不是指令所以电脑会崩,因为指令和数据都放在内存里,他们在根本上没有区别,都是二进制数,所以 halt 很重要,能区分指令和数据</p>\n<h3 id=\"循环的指令\"><a href=\"#循环的指令\" class=\"headerlink\" title=\"循环的指令\"></a>循环的指令</h3><ul>\n<li>RAM14 LOAD RA</li>\n<li>RAM15 LOAD RB</li>\n<li>ADD RB &amp; RA into RA</li>\n<li>JUMP 2 =&gt;INST.ADDR.REGISTER change into 2=&gt; EXECUTE RAM2 INST</li>\n<li>ADD RB &amp; RA into RA</li>\n<li>JUMP 2 =&gt;INST.ADDR.REGISTER change into 2=&gt; EXECUTE RAM2 INST</li>\n<li>…</li>\n</ul>\n<p>(INFINITE LOOP)</p>\n<img src=\"http://47.103.65.182/markdown/080.png\">\n\n<h3 id=\"有条件的循环\"><a href=\"#有条件的循环\" class=\"headerlink\" title=\"有条件的循环\"></a>有条件的循环</h3><img src=\"http://47.103.65.182/markdown/081.png\">\n\n<ul>\n<li>RAM14 LOAD RA</li>\n<li>RAM15 LOAD RB</li>\n<li>SUB RA - RB into RA 11-5=6&gt;0</li>\n<li>JUMP_NEG 5 =&gt; ALU RESULT &gt;0 =&gt;don’t EXECUTE</li>\n<li>JUMP 2=&gt;INST.ADDR.REGISTER change into 2=&gt; EXECUTE RAM2 INST</li>\n<li>SUB RB RA into RA into RA 6-5=1&gt;0</li>\n<li>JUMP_NEG 5 =&gt; ALU RESULT &gt;0 =&gt;don’t EXECUTE</li>\n<li>JUMP 2=&gt;INST.ADDR.REGISTER change into 2=&gt; EXECUTE RAM2 INST</li>\n<li>SUB RA - RB into RA 1-5=-4&gt;0</li>\n<li>JUMP_NEG 5 =&gt; ALU RESULT &lt;0 =&gt;INST.ADDR.REGISTER change into 5=&gt; EXECUTE RAM5 INST</li>\n<li>ADD RB &amp; RA into RA</li>\n<li>STORE RA into RAM 13</li>\n<li>HALT (结束)</li>\n</ul>\n<p>ALU 没有除法,但是我们可以通过程序来实现,</p>\n<h3 id=\"增加指令数量\"><a href=\"#增加指令数量\" class=\"headerlink\" title=\"增加指令数量\"></a>增加指令数量</h3><p>我们的指令使用 4bit 来表示,所以最多也就 16 条指令,</p>\n<p>增加指令有两种方法</p>\n<ul>\n<li>增加指令的位,即增加 INSTRUCTION LENGTH (指令长度)</li>\n<li>使用 VARIABLE LENGTH 　 INSTRUCTION 　（可变指令长度）HALT 立即执行 JUMP 看此参数,因此指令的位数可以不同,只要能保证功能即可</li>\n</ul>\n<h2 id=\"三十三、cryptography\"><a href=\"#三十三、cryptography\" class=\"headerlink\" title=\"三十三、cryptography\"></a>三十三、cryptography</h2><h3 id=\"模运算\"><a href=\"#模运算\" class=\"headerlink\" title=\"模运算\"></a><a href=\"https://www.cnblogs.com/jojoke/archive/2007/12/17/1003594.html\">模运算</a></h3><p>很多地方用到模运算，这里说明模运算的一些规律，并加以证明。 后续会对这些理论实际的应用加以记录和说明。</p>\n<ol>\n<li>模运算是取余运算(记做 % 或者 mod)，具有周期性的特点。 m%n 的意思是 n 除 m 后的余数， 当 m 递增时 m%n 呈现周期性特点， 并且 n 越大，周期越长，周期等于 n。<br>例如<br>0 % 20 = 0，1 % 20 = 1， 2 % 20 = 2， 3 % 20 = 3， …， 19 % 20 = 19<br>20 % 20 = 0，21 % 20 = 1，22 % 20 = 2，23 % 20 = 3， …，39 % 20 = 19</li>\n<li>如果 m % n = r，那么可以推出如下等式<br>m = k * n + r (k 为大于等于 0 的整数， r &lt;= m）</li>\n<li>同余式， 表示正整数 a，b 对 n 取模，它们的余数相同，记做 a ≡ b mod n 或者 a = b (mod n)。<br>根据 2 的等式可以推出 a = kn + b 或者 a - b = kn<br>证明： ∵ a = k1 _ n + r1<br>b = k2 _ n + r2<br>∴ a - b = (k1 - k2) _ n + (r1 - r2)<br>a = k _ n + (r1 - r2) + b<br>∵ a, b 对 n 取模同余，r1 = r2<br>∴ a = k * n + b (k = k1 - k2)</li>\n<li>模运算规则， 模运算与基本四则运算有些相似，但是除法例外。其规则如下</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a + b) % n = (a % n + b % n) % n      （1）</span><br><span class=\"line\">  (a - b) % n = (a % n - b % n) % n      （2）</span><br><span class=\"line\">  (a * b) % n = (a % n * b % n) % n      （3）</span><br><span class=\"line\">  a^b % n = ((a % n)b) % n           （4）</span><br></pre></td></tr></table></figure>\n\n<p>（1）式证明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">∵ a = k1*n + r1</span><br><span class=\"line\"></span><br><span class=\"line\">  b = k2*n + r2</span><br><span class=\"line\"></span><br><span class=\"line\"> a % n = r1</span><br><span class=\"line\"></span><br><span class=\"line\"> b % n = r2</span><br><span class=\"line\"></span><br><span class=\"line\">∴(a+b) % n = ((k1+k2)*n + (r1+r2)) % n = (r1+r2) % n = (a % n + b % n)% n</span><br></pre></td></tr></table></figure>\n\n<p>（2）式证明同上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>（3）式证明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">a = k1*n + r1</span><br><span class=\"line\">b = k2*n + r2</span><br><span class=\"line\">(a*b) % n = (k1k2n2 + (k1r2+k2r1)n + r1r2) % n = r1r2 % n = (a %n * b %n ) % n</span><br></pre></td></tr></table></figure>\n\n<p>(4)式证明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设 a % n = r</span><br><span class=\"line\">ab %n= (a * a * a * a…*a) %n = (a %n * a %n * a %n * … * a %n) %n = rb % n = ((a % n) b) % n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>模运算看起来不是很直观，但是可以用来推导出一些有用的东西。 例如（4）式可以用来降幂运算，例如计算 6265 % 133,直接计算的话需要算出 6265 利用（4）式可以进行降幂运算。</p>\n<h3 id=\"Diffie-Hellman-算法\"><a href=\"#Diffie-Hellman-算法\" class=\"headerlink\" title=\"Diffie-Hellman 算法\"></a>Diffie-Hellman 算法</h3><p><a href=\"https://www.cnblogs.com/math/p/9383231.html\">https://www.cnblogs.com/math/p/9383231.html</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0\">离散对数</a>：定义素数 p 的原始根是能生成 1-(p-1)之间所有数的一个数，设 a 为 p 的原始根，则：a mod p，a^2^ mod p，…，a^(p-1)^ mod p 是各不相同的整数，且以某种排列方式组成了从 1 到 p-1 的所有整数。对于任意数 b 及素数 p 的原始根 a，可以找到一个唯一的指数 i，满足：b= a ^i^ mod p，其中 0≤i≤p-1，那么指数 i 称为 b 的以 a 为基数的模 p 的离散对数。</p>\n<p>Diffie-Hellman 算法的有效性依赖于计算离散对数的难度，其含义是：当已知大素数 p 和它的一个原根 a 后，对于给定的 b，要计算出 i 被认为是很困难的，而给定 i 计算 b 却相对容易。</p>\n<p>假设网络上有两个用户 A 和 B，彼此之间协商共同的密码，算法过程如图 1 所示 。</p>\n<p>假设交换密钥的值为 k 。</p>\n<p>(1)A 和 B 事先约好大素数 p 和它的原始根 a；</p>\n<p>(2)A 随机产生一个数 x，计算 X=a^x^ mod p，然后把 X 发给 B；</p>\n<p>3)B 随机产生一个数 y，计算 Y=a^y^mod p，然后把 Y 发给 A；</p>\n<p>(4)A 计算 k=Y^x^mod p；</p>\n<p>(5)B 计算 k’ = X^y^mod p;</p>\n<p>因为 k=Y^x^mod p = (a^y^mod p)^x^ mod p = (a^y^)^x^ mod p = (a^x^)^y^ mod p = (a^x^mod p)^y^ mod p = X^y^mod p = k’</p>\n<p>不安全网络上的窃听者只能得到 a、p、X、Y，除非能计算离散对数 x 和 y，否则将无法得到密钥 k，但对于大素数 p，计算离散对数是十分困难的，因此 k 为用户 A 和 B 独立计算出的密钥。</p>\n<p>扩展资料</p>\n<ul>\n<li><a href=\"https://crashcourse.club/\">Crash Course 字幕组</a></li>\n<li><a href=\"https://www.patreon.com/crashcourse\">Crash Course 官方</a></li>\n</ul>\n","site":{"data":{}},"length":8479,"excerpt":"<blockquote>\n<p>参考资料</p>\n</blockquote>\n<p><a href=\"https://www.bilibili.com/video/av21376839?p=1\">Crash Course 计算机视频</a></p>\n<h2 id=\"一、计算机的早期历史\"><a href=\"#一、计算机的早期历史\" class=\"headerlink\" title=\"一、计算机的早期历史\"></a>一、计算机的早期历史</h2><p>美索不达米亚 1000 BC 算盘</p>\n<table>\n<thead>\n<tr>\n<th>time</th>\n<th>area</th>\n<th>Instance</th>\n<th>进制</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1000BC</td>\n<td>美索不达米亚</td>\n<td>算盘</td>\n<td>10</td>\n</tr>\n<tr>\n<td>1694</td>\n<td>德国</td>\n<td>步进计算器</td>\n<td>10</td>\n</tr>\n<tr>\n<td>before 20 C</td>\n<td>world</td>\n<td>计算表</td>\n<td></td>\n</tr>\n<tr>\n<td>1822</td>\n<td>英国（Charles Babbage）</td>\n<td>差分机（论文）</td>\n<td></td>\n</tr>\n<tr>\n<td>1822-1842</td>\n<td>英国(Charles Babbage)</td>\n<td>分析机（general computer）</td>\n<td></td>\n</tr>\n<tr>\n<td>18X（8|9）？</td>\n<td>美国（Hollerith IBM 创始人）</td>\n<td>打孔卡片制表机</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>Ada Lovelace 给分析机写了假象程序(第一程序员)</p>\n<p>Charles Babbage 设计了分析机，即通用计算机 （计算机之父）</p>","more":"<h2 id=\"二、电子计算机\"><a href=\"#二、电子计算机\" class=\"headerlink\" title=\"二、电子计算机\"></a>二、电子计算机</h2><p>机械继电器（开关），利用电磁线圈的磁场把开关吸下来，联通电路</p>\n<p>二极管 （首先出现为热电子管）</p>\n<p>三级真空管（二代继电器），每秒客开闭千次</p>\n<p>1947 贝尔实验室 晶体管（半导体材料继电器），每秒万次开闭，加州硅谷，出现仙童半导体公司，仙童来变成了英特尔，目前的晶体管体积 50 纳米，每秒上百万次开闭，工作几十年，</p>\n<table>\n<thead>\n<tr>\n<th>time</th>\n<th>area</th>\n<th>instance</th>\n<th>person</th>\n<th>remarks</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1944</td>\n<td>IBM</td>\n<td>Mark II</td>\n<td>IBM</td>\n<td>1947 pulled a bug</td>\n</tr>\n<tr>\n<td>1943.12</td>\n<td>英国 Bletchley</td>\n<td>Mark I</td>\n<td>Tommy Flowers</td>\n<td>大规模使用真空管(1600)，可编程，解密 Nazi</td>\n</tr>\n<tr>\n<td>1941</td>\n<td>英国 Bletchley</td>\n<td>Bombe</td>\n<td>Alan Turing</td>\n<td>designd to break Enigma code</td>\n</tr>\n<tr>\n<td>1946</td>\n<td>美</td>\n<td>ENIAC</td>\n<td>Pennsylvania</td>\n<td>积分，真正意义电子计算机</td>\n</tr>\n<tr>\n<td>1958</td>\n<td>美</td>\n<td>IBM608</td>\n<td>IBM</td>\n<td>使用晶体管</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、布尔逻辑与逻辑门\"><a href=\"#三、布尔逻辑与逻辑门\" class=\"headerlink\" title=\"三、布尔逻辑与逻辑门\"></a>三、布尔逻辑与逻辑门</h2><h3 id=\"布尔代数\"><a href=\"#布尔代数\" class=\"headerlink\" title=\"布尔代数\"></a><a href=\"http://www.ruanyifeng.com/blog/2016/08/boolean-algebra.html\">布尔代数</a></h3><p>关于真值的逻辑运算称为布尔代数（Boolean Algebra），以它的创始人布尔命名。</p>\n<p>在编程语言中表示 T 值和 F 值的数据类型叫做布尔类型，在 C 语言中通常用<code>int</code>类型来表示，非 0 表示 T，0 表示 F。布尔逻辑是写程序的基本功之一，程序中的很多错误都可以归因于逻辑错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下是一些布尔代数的基本定理，为了简洁易读，T和F用1和0表示，AND用*号表示，OR用+号表示（从真值表可以看出AND和OR运算确实有些类似*和+），NOT用¬表示，x、y、z的值可能是0也可能是1。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">¬¬x=x</span><br><span class=\"line\"></span><br><span class=\"line\">x*0=0</span><br><span class=\"line\">x+1=1</span><br><span class=\"line\"></span><br><span class=\"line\">x*1=x</span><br><span class=\"line\">x+0=x</span><br><span class=\"line\"></span><br><span class=\"line\">x*x=x</span><br><span class=\"line\">x+x=x</span><br><span class=\"line\"></span><br><span class=\"line\">x*¬x=0</span><br><span class=\"line\">x+¬x=1</span><br><span class=\"line\"></span><br><span class=\"line\">x*y=y*x</span><br><span class=\"line\">x+y=y+x</span><br><span class=\"line\"></span><br><span class=\"line\">x*(y*z)=(x*y)*z</span><br><span class=\"line\">x+(y+z)=(x+y)+z</span><br><span class=\"line\"></span><br><span class=\"line\">x*(y+z)=x*y+x*z</span><br><span class=\"line\">x+y*z=(x+y)*(x+z)</span><br><span class=\"line\"></span><br><span class=\"line\">x+x*y=x</span><br><span class=\"line\">x*(x+y)=x</span><br><span class=\"line\"></span><br><span class=\"line\">x*y+x*¬y=x</span><br><span class=\"line\">(x+y)*(x+¬y)=x</span><br><span class=\"line\"></span><br><span class=\"line\">¬(x*y)=¬x+¬y</span><br><span class=\"line\">¬(x+y)=¬x*¬y</span><br><span class=\"line\"></span><br><span class=\"line\">x+¬x*y=x+y</span><br><span class=\"line\">x*(¬x+y)=x*y</span><br><span class=\"line\"></span><br><span class=\"line\">x*y+¬x*z+y*z=x*y+¬x*z</span><br><span class=\"line\">(x+y)*(¬x+z)*(y+z)=(x+y)*(¬x+z)</span><br><span class=\"line\"></span><br><span class=\"line\">除了第1行之外，这些公式都是每两行一组的，每组的两个公式就像对联一样：把其中一个公式中的*换成+、+换成*、0换成1、1换成0，就变成了与它对称的另一个公式。这些定理都可以通过真值表证明</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"逻辑门-and-or-not-xor\"><a href=\"#逻辑门-and-or-not-xor\" class=\"headerlink\" title=\"逻辑门 and or not xor\"></a>逻辑门 and or not xor</h3><p><a href=\"https://www.cnblogs.com/sunshine-jackie/p/8137240.html\">逻辑门的晶体管实现</a></p>\n<p>VDD 就是电源的意思</p>\n<h4 id=\"and\"><a href=\"#and\" class=\"headerlink\" title=\"and\"></a>and</h4><table>\n<thead>\n<tr>\n<th>true</th>\n<th>true</th>\n<th>true</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>true</td>\n<td>false</td>\n<td>false</td>\n</tr>\n<tr>\n<td>false</td>\n<td>true</td>\n<td>false</td>\n</tr>\n<tr>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h4 id=\"or\"><a href=\"#or\" class=\"headerlink\" title=\"or\"></a>or</h4><table>\n<thead>\n<tr>\n<th>true</th>\n<th>true</th>\n<th>true</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>true</td>\n<td>false</td>\n<td>true</td>\n</tr>\n<tr>\n<td>false</td>\n<td>true</td>\n<td>true</td>\n</tr>\n<tr>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h4 id=\"not\"><a href=\"#not\" class=\"headerlink\" title=\"not\"></a>not</h4><table>\n<thead>\n<tr>\n<th>true</th>\n<th>false</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>false</td>\n<td>true</td>\n</tr>\n</tbody></table>\n<h4 id=\"xor\"><a href=\"#xor\" class=\"headerlink\" title=\"xor\"></a>xor</h4><table>\n<thead>\n<tr>\n<th>true</th>\n<th>true</th>\n<th>false</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>true</td>\n<td>false</td>\n<td>true</td>\n</tr>\n<tr>\n<td>false</td>\n<td>true</td>\n<td>true</td>\n</tr>\n<tr>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h2 id=\"四、二进制\"><a href=\"#四、二进制\" class=\"headerlink\" title=\"四、二进制\"></a>四、二进制</h2><h3 id=\"二进制，逢二进一\"><a href=\"#二进制，逢二进一\" class=\"headerlink\" title=\"二进制，逢二进一\"></a>二进制，逢二进一</h3><table>\n<thead>\n<tr>\n<th>2^7^</th>\n<th>2^6^</th>\n<th>2^5^</th>\n<th>2^4^</th>\n<th>2^3^</th>\n<th>2^2^</th>\n<th>2^1^</th>\n<th>2^0^</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p>二进制中，</p>\n<p>一个 0 或 1 表示一位（1bit）</p>\n<p>8bit = 1byte(字节)</p>\n<p>1kb = 2^10^ byte = 1024 byte</p>\n<h4 id=\"数字表示\"><a href=\"#数字表示\" class=\"headerlink\" title=\"数字表示\"></a>数字表示</h4><h5 id=\"整数\"><a href=\"#整数\" class=\"headerlink\" title=\"整数\"></a>整数</h5><p>0 000 0000 0000 0000 0000 0000 0000 0000</p>\n<p>首位表示正负（sign）其余为数值</p>\n<h5 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h5><p>0 000 0000 0 000 0000 0000 0000 0000 0000</p>\n<p>浮点数是将科学计数法的数字进行存储，首位表示正负（sign）接下来八位 表示指数，剩下的 23 位表示有效位数</p>\n<p>例如</p>\n<p>153446631161563 的科学计数法表示 0.153446631161563 x 10^15^</p>\n<p>它的浮点数如下 4 字节的浮点数精度损失还是比较大</p>\n<p>0 000 0111 1 100 0101 1100 0111 1000 1001‬</p>\n<h4 id=\"字符的表示\"><a href=\"#字符的表示\" class=\"headerlink\" title=\"字符的表示\"></a>字符的表示</h4><p>字符表示最简单的方法就是给字母一个编号，就有了 ASCII</p>\n<p>为了表示 the world 的所有字符，后来就出现了 Unicode 和 ISO，之后他们俩兼容了，现在常用的编码实现位 utf-8,它是一种可变长的编码，<a href=\"#####utf-8\">utf-8 编码规则</a></p>\n<h5 id=\"unicode\"><a href=\"#unicode\" class=\"headerlink\" title=\"unicode\"></a>unicode</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</span><br><span class=\"line\"></span><br><span class=\"line\">可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</span><br><span class=\"line\"></span><br><span class=\"line\">Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"unicode-的问题\"><a href=\"#unicode-的问题\" class=\"headerlink\" title=\"unicode 的问题\"></a>unicode 的问题</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</span><br><span class=\"line\"></span><br><span class=\"line\">比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</span><br><span class=\"line\"></span><br><span class=\"line\">这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</span><br><span class=\"line\"></span><br><span class=\"line\">它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"utf-8\"><a href=\"#utf-8\" class=\"headerlink\" title=\"utf-8\"></a>utf-8</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</span><br><span class=\"line\"></span><br><span class=\"line\">UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</span><br><span class=\"line\"></span><br><span class=\"line\">UTF-8 的编码规则很简单，只有二条：</span><br><span class=\"line\"></span><br><span class=\"line\">1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</span><br><span class=\"line\"></span><br><span class=\"line\">2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</span><br><span class=\"line\"></span><br><span class=\"line\">下表总结了编码规则，字母x表示可用编码的位。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>Unicode 符号范围(十六进制)</th>\n<th>UTF-8 编码方式（二进制）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0000 0000-0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080-0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800-0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000-0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</span><br><span class=\"line\"></span><br><span class=\"line\">下面，还是以汉字严为例，演示如何实现 UTF-8 编码。</span><br><span class=\"line\"></span><br><span class=\"line\">严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。</span><br></pre></td></tr></table></figure>\n\n<p>引用</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>\n<h4 id=\"字节序小知识\"><a href=\"#字节序小知识\" class=\"headerlink\" title=\"字节序小知识\"></a>字节序小知识</h4><img src=\"http://47.103.65.182/markdown/104.png\">\n\n<h2 id=\"五、算数逻辑单元-ALU-Arithmetic-amp-Logic-Unit\"><a href=\"#五、算数逻辑单元-ALU-Arithmetic-amp-Logic-Unit\" class=\"headerlink\" title=\"五、算数逻辑单元 ALU (Arithmetic &amp; Logic Unit)\"></a>五、算数逻辑单元 ALU (Arithmetic &amp; Logic Unit)</h2><p>How Computer Calculate ——the ALU</p>\n<h3 id=\"计算单元\"><a href=\"#计算单元\" class=\"headerlink\" title=\"计算单元\"></a>计算单元</h3><h4 id=\"加法实现\"><a href=\"#加法实现\" class=\"headerlink\" title=\"加法实现\"></a>加法实现</h4><h5 id=\"a-half-adder\"><a href=\"#a-half-adder\" class=\"headerlink\" title=\"a half adder\"></a>a half adder</h5><p>进行 1bit 运算</p>\n<img src=\"http://47.103.65.182/markdown/040.png\">\n\n<h5 id=\"全加器\"><a href=\"#全加器\" class=\"headerlink\" title=\"全加器\"></a>全加器</h5><p>full adder 使用两个 half adder 实现</p>\n<img src=\"http://47.103.65.182/markdown/041.png\">\n\n<h5 id=\"8bit-adder\"><a href=\"#8bit-adder\" class=\"headerlink\" title=\"8bit adder\"></a>8bit adder</h5><img src=\"http://47.103.65.182/markdown/042.png\">\n\n<img src=\"http://47.103.65.182/markdown/043.png\">\n\n<h3 id=\"逻辑单元\"><a href=\"#逻辑单元\" class=\"headerlink\" title=\"逻辑单元\"></a>逻辑单元</h3><p>布尔运算 and or not xor</p>\n<p>对输入的信号，进行逻辑运算，结果符合真值表</p>\n<h4 id=\"ALU-抽象\"><a href=\"#ALU-抽象\" class=\"headerlink\" title=\"ALU 抽象\"></a>ALU 抽象</h4><img src=\"http://47.103.65.182/markdown/044.png\">\n\n<h2 id=\"六、寄存器和内存（Registers-amp-RAM）\"><a href=\"#六、寄存器和内存（Registers-amp-RAM）\" class=\"headerlink\" title=\"六、寄存器和内存（Registers &amp; RAM）\"></a>六、寄存器和内存（Registers &amp; RAM）</h2><p>RAM : Random Access Memory</p>\n<p>PM : Persistent Memory</p>\n<p>存储 1bit 数据</p>\n<h3 id=\"sava-1\"><a href=\"#sava-1\" class=\"headerlink\" title=\"sava 1\"></a>sava 1</h3><p>就或门输出与输入链接，可以形成一个 1 的永久存储</p>\n<img src=\"http://47.103.65.182/markdown/045.png\">\n\n<h3 id=\"sava-0\"><a href=\"#sava-0\" class=\"headerlink\" title=\"sava 0\"></a>sava 0</h3><p>将与门输出与输入连接，可以形成一个 0 的永久存储</p>\n<img src=\"http://47.103.65.182/markdown/046.png\">\n\n<h3 id=\"锁存（AND-OR-LATCH）\"><a href=\"#锁存（AND-OR-LATCH）\" class=\"headerlink\" title=\"锁存（AND-OR LATCH）\"></a>锁存（AND-OR LATCH）</h3><p>将上述两个电路结合起来就做成了一个锁存器</p>\n<img src=\"http://47.103.65.182/markdown/047.png\">\n\n<p>set 设为 1 后，无论 set 如何改变，输出一直为 1，即 set 将状态置为 1</p>\n<p>reset 设为 1 后，无论 reset 如何改变，输出一直为 0，即 reset 将状态置为 0</p>\n<p>set 和 reset 都为 0 的话，锁存器将会保存最后设置的状态，1bit 的记忆功能就实现了，记忆的结果取决于最后关闭的是谁</p>\n<h3 id=\"门锁（GATED-LATCH）\"><a href=\"#门锁（GATED-LATCH）\" class=\"headerlink\" title=\"门锁（GATED LATCH）\"></a>门锁（GATED LATCH）</h3><p>1bit 的可控制写入存储</p>\n<img src=\"http://47.103.65.182/markdown/048.png\">\n\n<p>允许写入线为 0 时，set,reset 恒为 0,不可写入，允许写入线为 1 时，输入 0 将 reset 锁存，输入 1 将 set 锁存</p>\n<h4 id=\"抽象出门锁组件\"><a href=\"#抽象出门锁组件\" class=\"headerlink\" title=\"抽象出门锁组件\"></a>抽象出门锁组件</h4><img src=\"http://47.103.65.182/markdown/049.png\">\n\n<h3 id=\"寄存器-register\"><a href=\"#寄存器-register\" class=\"headerlink\" title=\"寄存器 register\"></a>寄存器 register</h3><p>A group of lanches operating like this is called a <strong>register</strong> ,which hlod a single number , and the number of bits in a register is called its width.</p>\n<p>寄存器是<a href=\"https://baike.baidu.com/item/CPU/120556\">CPU</a>内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。寄存器的存储电路是由锁存器或触发器构成的，因为一个锁存器或触发器能存储 1 位二进制数，所以由 N 个<a href=\"https://baike.baidu.com/item/%E9%94%81%E5%AD%98%E5%99%A8/10801965\">锁存器</a>或触发器可以构成 N 位寄存器。寄存器是中央处理器内的组成部分。寄存器是有限存储容量的高速存储部件，它们可用来暂存指令</p>\n<img src=\"http://47.103.65.182/markdown/050.png\">\n\n<p>16x16 门锁矩阵</p>\n<p>更大位的寄存器</p>\n<img src=\"http://47.103.65.182/markdown/051.png\">\n\n<p>启用某个门锁的方式位激活相应的排线和列线</p>\n<img src=\"http://47.103.65.182/markdown/052.png\">\n\n<p>在允许写入线前加一个<strong>与门</strong>，与行线和列线相连，就可以具体指向某个锁存</p>\n<img src=\"http://47.103.65.182/markdown/054.png\">\n\n<p>启用行列线，再<strong>启用写入操作线</strong>，就可以操作这个锁存，再因为没有行列线的锁存是关闭启用写入线，所以写入操作线就算公用的（1 条线连所有），也可以做到针对某个锁存操作，</p>\n<img src=\"http://47.103.65.182/markdown/055.png\">\n\n<p>启用行列线，再启用<strong>读取操作线</strong>，就可以打开门锁输出线的晶体管（应该是吧），启用数据输入输出线，就可以<strong>读取到这个锁存的输出</strong></p>\n<img src=\"http://47.103.65.182/markdown/057.png\">\n\n<p>启用行列线，再启用<strong>写入操作线</strong>，就可以开启此所存的写入操作，此时操作<strong>数据输入输出线</strong>，可以设置锁存的值</p>\n<img src=\"http://47.103.65.182/markdown/056.png\">\n\n<h3 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h3><p>如何表示操作的是哪个锁存，（我们任是使用 16x16 门锁矩阵）</p>\n<p>4bit 可以表示 16 个数字（0-15），8 个 bit 就可以表示一个地址（行，列）</p>\n<p>例如 3 行 10 列（0011，1010）</p>\n<h4 id=\"多路复用器-multiplexer\"><a href=\"#多路复用器-multiplexer\" class=\"headerlink\" title=\"多路复用器(multiplexer)\"></a>多路复用器(multiplexer)</h4><p>为了将行和列转换为地址，我们需要多路复用器(multiplexer)</p>\n<img src=\"http://47.103.65.182/markdown/058.png\">\n\n<h4 id=\"内存（memory）\"><a href=\"#内存（memory）\" class=\"headerlink\" title=\"内存（memory）\"></a>内存（memory）</h4><img src=\"http://47.103.65.182/markdown/059.png\">\n\n<h4 id=\"静态随机地址存储（SRAM）\"><a href=\"#静态随机地址存储（SRAM）\" class=\"headerlink\" title=\"静态随机地址存储（SRAM）\"></a>静态随机地址存储（SRAM）</h4><p>存储 8bit 数据的方式，8 个比特位用相同的地址分别存储</p>\n<img src=\"http://47.103.65.182/markdown/060.png\">\n\n\n\n<p>这个是一个 SRAM （static random access memory）</p>\n<p>把这个内存单元，看成拥有 256 个地址，每个地址能读写一个 8bit 值，这就是 RAM</p>\n<img src=\"http://47.103.65.182/markdown/061.png\">\n\n<h2 id=\"七、The-Center-Processing-Unit\"><a href=\"#七、The-Center-Processing-Unit\" class=\"headerlink\" title=\"七、The Center Processing Unit\"></a>七、The Center Processing Unit</h2><h3 id=\"基础组件\"><a href=\"#基础组件\" class=\"headerlink\" title=\"基础组件\"></a>基础组件</h3><img src=\"http://47.103.65.182/markdown/063.png\">\n\n<h3 id=\"指令表\"><a href=\"#指令表\" class=\"headerlink\" title=\"指令表\"></a>指令表</h3><img src=\"http://47.103.65.182/markdown/062.png\">\n\n<h3 id=\"cpu-基本架构\"><a href=\"#cpu-基本架构\" class=\"headerlink\" title=\"cpu 基本架构\"></a>cpu 基本架构</h3><p>我们还需要两个寄存器来完成 CPU，一个用来存储指令地址（本例是 RAM），一个用来存储指令</p>\n<img src=\"http://47.103.65.182/markdown/064.png\">\n\n<h3 id=\"cpu-执行流程\"><a href=\"#cpu-执行流程\" class=\"headerlink\" title=\"cpu 执行流程\"></a>cpu 执行流程</h3><p>1.启动计算机，所有寄存器从零开始</p>\n<img src=\"http://47.103.65.182/markdown/065.png\">\n\n<p>2.为了举例我们在 RAM 放了一个程序</p>\n<h4 id=\"取指令-FETCH-PHASE\"><a href=\"#取指令-FETCH-PHASE\" class=\"headerlink\" title=\"取指令 FETCH PHASE\"></a>取指令 FETCH PHASE</h4><p>cpu 的第一个阶段叫做<code>取指令阶段</code>FETCH PHASE ,负责拿到指令</p>\n<ul>\n<li>指令地址寄存器连到 RAM，此时寄存器地址为０,因此 RAM 返回地址 0 的值,值会复制到指令寄存器里</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/067.png\">\n\n<h4 id=\"解码指令-DECODE-FHASE\"><a href=\"#解码指令-DECODE-FHASE\" class=\"headerlink\" title=\"解码指令 DECODE FHASE\"></a>解码指令 DECODE FHASE</h4><p>cpu 的第二个阶段叫做<code>解码阶段</code>DECODE FHASE,负责解析出要执行什么指令</p>\n<img src=\"http://47.103.65.182/markdown/068.png\">\n\n<p>在我们定义的指令中,一个 8 位值,前 4 位代表指令,后 4 位代表参数;对于指令寄存器的值我们需要使用一个控制单元来进行解码</p>\n<ul>\n<li>检查指令是不是 LOAD_A,我们可以用很少的逻辑门实现</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/069.png\">\n\n<h4 id=\"执行指令-EXECUTE-FHASE\"><a href=\"#执行指令-EXECUTE-FHASE\" class=\"headerlink\" title=\"执行指令 EXECUTE FHASE\"></a>执行指令 EXECUTE FHASE</h4><p>知道了是什么指令,我们就可以进入执行阶段</p>\n<img src=\"http://47.103.65.182/markdown/070.png\">\n\n<ul>\n<li>电路的连接保证 LOAD_A 正确执行</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/071.png\">\n\n<ul>\n<li>关闭电路,指令地址寄存器+1</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/072.png\">\n\n<h3 id=\"控制单元\"><a href=\"#控制单元\" class=\"headerlink\" title=\"控制单元\"></a>控制单元</h3><p>分析完一个指令后,其他的指令也是类似的情况,所以将所有指令封装成一个控制单元</p>\n<img src=\"http://47.103.65.182/markdown/073.png\">\n\n<ul>\n<li>对于 ADD 指令我们需要使用 ALU</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/074.png\">\n\n<ul>\n<li>始终以精确的间隔触发电信号,控制单元会利用这个信号,推进 cpu 的内部操作,确保一切按步骤进行,cpu”取指令–&gt;解码–&gt;执行”的速度叫”时钟速度(CLOCK SPEED)”</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/075.png\">\n\n<h3 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h3><img src=\"http://47.103.65.182/markdown/076.png\">\n\n<h2 id=\"八、指令和程序-Instruction-amp-Programs\"><a href=\"#八、指令和程序-Instruction-amp-Programs\" class=\"headerlink\" title=\"八、指令和程序(Instruction&amp;Programs)\"></a>八、指令和程序(Instruction&amp;Programs)</h2><p>cpu 之所以强大,是因为它是可编程的,写入不同的指令就会执行不同的任务,CPU 是一个可以被软件控制的硬件</p>\n<p>这是上一节的例子,四个指令形成了一个加法的操作</p>\n<ul>\n<li>RAM 地址 14 的值 加载到 RA</li>\n<li>RAM 地址 15 的值加载到 RB</li>\n<li>ADD RB &amp; RA ,将结果写入 RA</li>\n<li>将 RA 的值存到 RAM 的 13 地址</li>\n</ul>\n<img src=\"http://47.103.65.182/markdown/077.png\">\n\n<h3 id=\"增加一些指令\"><a href=\"#增加一些指令\" class=\"headerlink\" title=\"增加一些指令\"></a>增加一些指令</h3><img src=\"http://47.103.65.182/markdown/078.png\">\n\n<p>负数跳是通过 ALU 的标志位实现的</p>\n<img src=\"http://47.103.65.182/markdown/079.png\">\n\n<p>没有 halt,cpu 就会继续执行下去,由于 0 不是指令所以电脑会崩,因为指令和数据都放在内存里,他们在根本上没有区别,都是二进制数,所以 halt 很重要,能区分指令和数据</p>\n<h3 id=\"循环的指令\"><a href=\"#循环的指令\" class=\"headerlink\" title=\"循环的指令\"></a>循环的指令</h3><ul>\n<li>RAM14 LOAD RA</li>\n<li>RAM15 LOAD RB</li>\n<li>ADD RB &amp; RA into RA</li>\n<li>JUMP 2 =&gt;INST.ADDR.REGISTER change into 2=&gt; EXECUTE RAM2 INST</li>\n<li>ADD RB &amp; RA into RA</li>\n<li>JUMP 2 =&gt;INST.ADDR.REGISTER change into 2=&gt; EXECUTE RAM2 INST</li>\n<li>…</li>\n</ul>\n<p>(INFINITE LOOP)</p>\n<img src=\"http://47.103.65.182/markdown/080.png\">\n\n<h3 id=\"有条件的循环\"><a href=\"#有条件的循环\" class=\"headerlink\" title=\"有条件的循环\"></a>有条件的循环</h3><img src=\"http://47.103.65.182/markdown/081.png\">\n\n<ul>\n<li>RAM14 LOAD RA</li>\n<li>RAM15 LOAD RB</li>\n<li>SUB RA - RB into RA 11-5=6&gt;0</li>\n<li>JUMP_NEG 5 =&gt; ALU RESULT &gt;0 =&gt;don’t EXECUTE</li>\n<li>JUMP 2=&gt;INST.ADDR.REGISTER change into 2=&gt; EXECUTE RAM2 INST</li>\n<li>SUB RB RA into RA into RA 6-5=1&gt;0</li>\n<li>JUMP_NEG 5 =&gt; ALU RESULT &gt;0 =&gt;don’t EXECUTE</li>\n<li>JUMP 2=&gt;INST.ADDR.REGISTER change into 2=&gt; EXECUTE RAM2 INST</li>\n<li>SUB RA - RB into RA 1-5=-4&gt;0</li>\n<li>JUMP_NEG 5 =&gt; ALU RESULT &lt;0 =&gt;INST.ADDR.REGISTER change into 5=&gt; EXECUTE RAM5 INST</li>\n<li>ADD RB &amp; RA into RA</li>\n<li>STORE RA into RAM 13</li>\n<li>HALT (结束)</li>\n</ul>\n<p>ALU 没有除法,但是我们可以通过程序来实现,</p>\n<h3 id=\"增加指令数量\"><a href=\"#增加指令数量\" class=\"headerlink\" title=\"增加指令数量\"></a>增加指令数量</h3><p>我们的指令使用 4bit 来表示,所以最多也就 16 条指令,</p>\n<p>增加指令有两种方法</p>\n<ul>\n<li>增加指令的位,即增加 INSTRUCTION LENGTH (指令长度)</li>\n<li>使用 VARIABLE LENGTH 　 INSTRUCTION 　（可变指令长度）HALT 立即执行 JUMP 看此参数,因此指令的位数可以不同,只要能保证功能即可</li>\n</ul>\n<h2 id=\"三十三、cryptography\"><a href=\"#三十三、cryptography\" class=\"headerlink\" title=\"三十三、cryptography\"></a>三十三、cryptography</h2><h3 id=\"模运算\"><a href=\"#模运算\" class=\"headerlink\" title=\"模运算\"></a><a href=\"https://www.cnblogs.com/jojoke/archive/2007/12/17/1003594.html\">模运算</a></h3><p>很多地方用到模运算，这里说明模运算的一些规律，并加以证明。 后续会对这些理论实际的应用加以记录和说明。</p>\n<ol>\n<li>模运算是取余运算(记做 % 或者 mod)，具有周期性的特点。 m%n 的意思是 n 除 m 后的余数， 当 m 递增时 m%n 呈现周期性特点， 并且 n 越大，周期越长，周期等于 n。<br>例如<br>0 % 20 = 0，1 % 20 = 1， 2 % 20 = 2， 3 % 20 = 3， …， 19 % 20 = 19<br>20 % 20 = 0，21 % 20 = 1，22 % 20 = 2，23 % 20 = 3， …，39 % 20 = 19</li>\n<li>如果 m % n = r，那么可以推出如下等式<br>m = k * n + r (k 为大于等于 0 的整数， r &lt;= m）</li>\n<li>同余式， 表示正整数 a，b 对 n 取模，它们的余数相同，记做 a ≡ b mod n 或者 a = b (mod n)。<br>根据 2 的等式可以推出 a = kn + b 或者 a - b = kn<br>证明： ∵ a = k1 _ n + r1<br>b = k2 _ n + r2<br>∴ a - b = (k1 - k2) _ n + (r1 - r2)<br>a = k _ n + (r1 - r2) + b<br>∵ a, b 对 n 取模同余，r1 = r2<br>∴ a = k * n + b (k = k1 - k2)</li>\n<li>模运算规则， 模运算与基本四则运算有些相似，但是除法例外。其规则如下</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a + b) % n = (a % n + b % n) % n      （1）</span><br><span class=\"line\">  (a - b) % n = (a % n - b % n) % n      （2）</span><br><span class=\"line\">  (a * b) % n = (a % n * b % n) % n      （3）</span><br><span class=\"line\">  a^b % n = ((a % n)b) % n           （4）</span><br></pre></td></tr></table></figure>\n\n<p>（1）式证明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">∵ a = k1*n + r1</span><br><span class=\"line\"></span><br><span class=\"line\">  b = k2*n + r2</span><br><span class=\"line\"></span><br><span class=\"line\"> a % n = r1</span><br><span class=\"line\"></span><br><span class=\"line\"> b % n = r2</span><br><span class=\"line\"></span><br><span class=\"line\">∴(a+b) % n = ((k1+k2)*n + (r1+r2)) % n = (r1+r2) % n = (a % n + b % n)% n</span><br></pre></td></tr></table></figure>\n\n<p>（2）式证明同上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>（3）式证明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">a = k1*n + r1</span><br><span class=\"line\">b = k2*n + r2</span><br><span class=\"line\">(a*b) % n = (k1k2n2 + (k1r2+k2r1)n + r1r2) % n = r1r2 % n = (a %n * b %n ) % n</span><br></pre></td></tr></table></figure>\n\n<p>(4)式证明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设 a % n = r</span><br><span class=\"line\">ab %n= (a * a * a * a…*a) %n = (a %n * a %n * a %n * … * a %n) %n = rb % n = ((a % n) b) % n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>模运算看起来不是很直观，但是可以用来推导出一些有用的东西。 例如（4）式可以用来降幂运算，例如计算 6265 % 133,直接计算的话需要算出 6265 利用（4）式可以进行降幂运算。</p>\n<h3 id=\"Diffie-Hellman-算法\"><a href=\"#Diffie-Hellman-算法\" class=\"headerlink\" title=\"Diffie-Hellman 算法\"></a>Diffie-Hellman 算法</h3><p><a href=\"https://www.cnblogs.com/math/p/9383231.html\">https://www.cnblogs.com/math/p/9383231.html</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0\">离散对数</a>：定义素数 p 的原始根是能生成 1-(p-1)之间所有数的一个数，设 a 为 p 的原始根，则：a mod p，a^2^ mod p，…，a^(p-1)^ mod p 是各不相同的整数，且以某种排列方式组成了从 1 到 p-1 的所有整数。对于任意数 b 及素数 p 的原始根 a，可以找到一个唯一的指数 i，满足：b= a ^i^ mod p，其中 0≤i≤p-1，那么指数 i 称为 b 的以 a 为基数的模 p 的离散对数。</p>\n<p>Diffie-Hellman 算法的有效性依赖于计算离散对数的难度，其含义是：当已知大素数 p 和它的一个原根 a 后，对于给定的 b，要计算出 i 被认为是很困难的，而给定 i 计算 b 却相对容易。</p>\n<p>假设网络上有两个用户 A 和 B，彼此之间协商共同的密码，算法过程如图 1 所示 。</p>\n<p>假设交换密钥的值为 k 。</p>\n<p>(1)A 和 B 事先约好大素数 p 和它的原始根 a；</p>\n<p>(2)A 随机产生一个数 x，计算 X=a^x^ mod p，然后把 X 发给 B；</p>\n<p>3)B 随机产生一个数 y，计算 Y=a^y^mod p，然后把 Y 发给 A；</p>\n<p>(4)A 计算 k=Y^x^mod p；</p>\n<p>(5)B 计算 k’ = X^y^mod p;</p>\n<p>因为 k=Y^x^mod p = (a^y^mod p)^x^ mod p = (a^y^)^x^ mod p = (a^x^)^y^ mod p = (a^x^mod p)^y^ mod p = X^y^mod p = k’</p>\n<p>不安全网络上的窃听者只能得到 a、p、X、Y，除非能计算离散对数 x 和 y，否则将无法得到密钥 k，但对于大素数 p，计算离散对数是十分困难的，因此 k 为用户 A 和 B 独立计算出的密钥。</p>\n<p>扩展资料</p>\n<ul>\n<li><a href=\"https://crashcourse.club/\">Crash Course 字幕组</a></li>\n<li><a href=\"https://www.patreon.com/crashcourse\">Crash Course 官方</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckqoye6h700019su016lrhia9","category_id":"ckqoye6hb00049su09fhueh0h","_id":"ckqoye6hh000c9su0bxczh4jy"},{"post_id":"ckqoye6hg000b9su039wq3f1i","category_id":"ckqoye6hf00099su0517bazn3","_id":"ckqoye6hi000f9su0hgnz3300"},{"post_id":"ckqoye6ha00039su0bjhk8rwp","category_id":"ckqoye6hf00099su0517bazn3","_id":"ckqoye6hj000i9su0fgvhcf27"},{"post_id":"ckqoye6hd00069su03yf8csmn","category_id":"ckqoye6hf00099su0517bazn3","_id":"ckqoye6hk000l9su09gn1f50k"},{"post_id":"ckqoye6he00079su04qcb6wjr","category_id":"ckqoye6hf00099su0517bazn3","_id":"ckqoye6hl000p9su05hgjhlrw"},{"post_id":"ckqoye6he00089su05678exxy","category_id":"ckqoye6hf00099su0517bazn3","_id":"ckqoye6hl000r9su0f9t4gznp"},{"post_id":"ckqoye6hw00239su0h2ijhqks","category_id":"ckqoye6hx00249su0cg257anm","_id":"ckqoye6hy00279su04cab8rmn"}],"PostTag":[{"post_id":"ckqoye6h700019su016lrhia9","tag_id":"ckqoye6hc00059su0b7dxhlyo","_id":"ckqoye6hk000j9su01hijeqy7"},{"post_id":"ckqoye6h700019su016lrhia9","tag_id":"ckqoye6hf000a9su01csgf2k0","_id":"ckqoye6hk000m9su0hwgw5dav"},{"post_id":"ckqoye6h700019su016lrhia9","tag_id":"ckqoye6hh000e9su0bkx9cck8","_id":"ckqoye6hk000o9su02du5cmwc"},{"post_id":"ckqoye6ha00039su0bjhk8rwp","tag_id":"ckqoye6hj000h9su0a9d58pve","_id":"ckqoye6hm000u9su0g8dqeqtb"},{"post_id":"ckqoye6ha00039su0bjhk8rwp","tag_id":"ckqoye6hk000n9su07wzs1f4e","_id":"ckqoye6hm000v9su0ajmu2voa"},{"post_id":"ckqoye6ha00039su0bjhk8rwp","tag_id":"ckqoye6hl000q9su0bjxacgkw","_id":"ckqoye6hm000x9su0ax2tae1s"},{"post_id":"ckqoye6ha00039su0bjhk8rwp","tag_id":"ckqoye6hl000s9su03zztgyhw","_id":"ckqoye6hm000y9su02cmz1oo9"},{"post_id":"ckqoye6hd00069su03yf8csmn","tag_id":"ckqoye6hl000t9su0gzll5wjl","_id":"ckqoye6ho00139su07vas7o9v"},{"post_id":"ckqoye6hd00069su03yf8csmn","tag_id":"ckqoye6hm000w9su08ee77vkw","_id":"ckqoye6ho00149su04a9v3rzr"},{"post_id":"ckqoye6hd00069su03yf8csmn","tag_id":"ckqoye6hm000z9su05m512bap","_id":"ckqoye6hp00169su0gsw76dpk"},{"post_id":"ckqoye6hd00069su03yf8csmn","tag_id":"ckqoye6hn00109su07555gdmy","_id":"ckqoye6hp00179su03d3the37"},{"post_id":"ckqoye6hd00069su03yf8csmn","tag_id":"ckqoye6hl000s9su03zztgyhw","_id":"ckqoye6hp00199su0gx9z81kr"},{"post_id":"ckqoye6he00079su04qcb6wjr","tag_id":"ckqoye6ho00129su0d62kg8xe","_id":"ckqoye6hp001a9su07814g7mm"},{"post_id":"ckqoye6he00079su04qcb6wjr","tag_id":"ckqoye6hl000s9su03zztgyhw","_id":"ckqoye6hq001c9su002nz615f"},{"post_id":"ckqoye6he00089su05678exxy","tag_id":"ckqoye6hp00189su0g25q0eid","_id":"ckqoye6hr001f9su030wafsx0"},{"post_id":"ckqoye6he00089su05678exxy","tag_id":"ckqoye6hp001b9su057hs1lz7","_id":"ckqoye6hr001g9su01zcyhguk"},{"post_id":"ckqoye6he00089su05678exxy","tag_id":"ckqoye6hl000s9su03zztgyhw","_id":"ckqoye6hr001i9su0hk1659wp"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hj000h9su0a9d58pve","_id":"ckqoye6hv001s9su03tebdjkw"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hk000n9su07wzs1f4e","_id":"ckqoye6hv001t9su04omug6nu"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hl000q9su0bjxacgkw","_id":"ckqoye6hv001u9su0bru09vb1"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hl000t9su0gzll5wjl","_id":"ckqoye6hv001v9su08a0f78b1"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hm000w9su08ee77vkw","_id":"ckqoye6hv001w9su06m5k7rnq"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6ho00129su0d62kg8xe","_id":"ckqoye6hv001x9su0gxwy9ggf"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hm000z9su05m512bap","_id":"ckqoye6hv001y9su0cpot3aje"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hn00109su07555gdmy","_id":"ckqoye6hv001z9su05re1bxaj"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hp00189su0g25q0eid","_id":"ckqoye6hv00209su0f24w92vc"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hp001b9su057hs1lz7","_id":"ckqoye6hv00219su03oc7dwp1"},{"post_id":"ckqoye6hg000b9su039wq3f1i","tag_id":"ckqoye6hl000s9su03zztgyhw","_id":"ckqoye6hv00229su0dw7x6ou9"},{"post_id":"ckqoye6hw00239su0h2ijhqks","tag_id":"ckqoye6hx00259su09l614165","_id":"ckqoye6hy00269su00aqd30jd"}],"Tag":[{"name":"权力","_id":"ckqoye6hc00059su0b7dxhlyo"},{"name":"体制内","_id":"ckqoye6hf000a9su01csgf2k0"},{"name":"安排定律","_id":"ckqoye6hh000e9su0bkx9cck8"},{"name":"ArrayBuffer","_id":"ckqoye6hj000h9su0a9d58pve"},{"name":"TypeArray","_id":"ckqoye6hk000n9su07wzs1f4e"},{"name":"DataView","_id":"ckqoye6hl000q9su0bjxacgkw"},{"name":"二进制","_id":"ckqoye6hl000s9su03zztgyhw"},{"name":"TextDecoder","_id":"ckqoye6hl000t9su0gzll5wjl"},{"name":"TextEncoder","_id":"ckqoye6hm000w9su08ee77vkw"},{"name":"decode","_id":"ckqoye6hm000z9su05m512bap"},{"name":"encode","_id":"ckqoye6hn00109su07555gdmy"},{"name":"Blob","_id":"ckqoye6ho00129su0d62kg8xe"},{"name":"File","_id":"ckqoye6hp00189su0g25q0eid"},{"name":"FileReader","_id":"ckqoye6hp001b9su057hs1lz7"},{"name":"计算机概论","_id":"ckqoye6hx00259su09l614165"},{"name":"测试","_id":"ckqoym55k0002i4u0a7fbbrms"}]}}